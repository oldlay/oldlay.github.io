<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>CS on 欧德雷-oldlay</title>
        <link>https://oldlay.github.io/categories/cs/</link>
        <description>Recent content in CS on 欧德雷-oldlay</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>欧德雷-oldlay</copyright>
        <lastBuildDate>Mon, 11 Aug 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://oldlay.github.io/categories/cs/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>AI-Chess</title>
        <link>https://oldlay.github.io/p/ai-chess/</link>
        <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>https://oldlay.github.io/p/ai-chess/</guid>
        <description>&lt;img src="https://oldlay.github.io/p/ai-chess/chess.jpg" alt="Featured image of post AI-Chess" /&gt;&lt;blockquote&gt;
&lt;p&gt;在我看来比较好的理解方式是，先通过阅读代码理解整体和细节，再看算法和论文会更好。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;注意：有什么代码设计逻辑上解决不了的问题，尝试抽象出一个中间层或者控制器类型的东西看看能不能解决&lt;/p&gt;
&lt;p&gt;记录一下毕设&lt;/p&gt;
&lt;h2 id=&#34;环境配置&#34;&gt;环境配置
&lt;/h2&gt;&lt;p&gt;在工程目录下创建conda虚拟环境：
&lt;strong&gt;使用 &lt;code&gt;--prefix&lt;/code&gt;&lt;/strong&gt;，环境会被创建在你指定的精确路径（这里是项目文件夹下的 &lt;code&gt;env&lt;/code&gt; 子目录）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 推荐：直接在工程文件夹内创建环境，当前已经处于工程目录下&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;conda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;prefix&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;./&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;python&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;3.9&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;conda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;activate&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;./&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;env&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 导出环境配置（方便共享）：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;conda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;yml&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 从 YAML 文件创建环境：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;conda&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;env&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;yml&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;随着项目增多，每个项目都创建独立的 Conda 环境确实会占用大量磁盘空间，小型数据分析项目可共用一个环境，核心项目使用单独环境。&lt;/p&gt;
&lt;p&gt;通过克隆基础环境减少重复安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 创建基础环境
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;conda create --name base_py39 python=3.9
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 克隆出项目专用环境（共享基础包）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;conda create --name projectA --clone base_py39
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;conda activate projectA
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;conda install packageA  # 仅安装项目特有包
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;code&gt;--name&lt;/code&gt;是创建全局环境的，而&lt;code&gt;--prefix&lt;/code&gt;是项目内环境的，不需要名字。&lt;/p&gt;
&lt;h2 id=&#34;pytorch库结构&#34;&gt;PyTorch库结构
&lt;/h2&gt;&lt;p&gt;由于每次用PyTorch导入，不知道应该导入哪一个是什么功能，记录以下PyTorch库的结构。&lt;/p&gt;
&lt;h3 id=&#34;1-核心模块&#34;&gt;1. 核心模块
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch&lt;/code&gt;&lt;/strong&gt;: 这是 PyTorch 的核心包，提供了所有基本的数据结构（如张量）和张量操作。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.Tensor&lt;/code&gt;&lt;/strong&gt;: PyTorch 中最基本的数据结构，类似于 NumPy 的 &lt;code&gt;ndarray&lt;/code&gt;，但支持 GPU 加速和自动微分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.autograd&lt;/code&gt;&lt;/strong&gt;: 实现了自动微分系统。当你对张量执行操作时，PyTorch 会构建一个计算图。&lt;code&gt;autograd&lt;/code&gt; 利用这个图来自动计算梯度。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.autograd.Function&lt;/code&gt;: 用户可以自定义操作并提供其前向和反向传播的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.nn&lt;/code&gt;&lt;/strong&gt;: 这是构建神经网络的核心模块。它提供了各种预定义的层（如 &lt;code&gt;Linear&lt;/code&gt;, &lt;code&gt;Conv2d&lt;/code&gt;, &lt;code&gt;ReLU&lt;/code&gt; 等）、损失函数（如 &lt;code&gt;MSELoss&lt;/code&gt;, &lt;code&gt;CrossEntropyLoss&lt;/code&gt; 等）和模型容器（如 &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Sequential&lt;/code&gt;）。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.nn.Module&lt;/code&gt;: 所有神经网络模块的基类。你的自定义模型都应该继承自它。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.nn.functional&lt;/code&gt;: 包含了函数式的神经网络操作，这些操作没有自己的可学习参数（例如 &lt;code&gt;F.relu&lt;/code&gt;, &lt;code&gt;F.softmax&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.optim&lt;/code&gt;&lt;/strong&gt;: 包含了各种优化算法（如 &lt;code&gt;SGD&lt;/code&gt;, &lt;code&gt;Adam&lt;/code&gt;, &lt;code&gt;RMSprop&lt;/code&gt; 等），用于更新模型的参数。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.optim.Optimizer&lt;/code&gt;: 所有优化器的基类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.cuda&lt;/code&gt;&lt;/strong&gt;: 提供了 CUDA 支持，允许你在 NVIDIA GPU 上进行张量操作和模型训练。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.cuda.is_available()&lt;/code&gt;: 检查 CUDA 是否可用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.cuda.empty_cache()&lt;/code&gt;: 清空 CUDA 缓存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.linalg&lt;/code&gt;&lt;/strong&gt;: 提供了线性代数操作，例如矩阵乘法、分解、特征值计算等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.jit&lt;/code&gt;&lt;/strong&gt;: 提供了 JIT (Just-In-Time) 编译器，可以将 PyTorch 模型转换为可序列化的、优化的表示，用于推理部署。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.jit.script&lt;/code&gt;: 将 Python 代码转换为 TorchScript。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.jit.trace&lt;/code&gt;: 通过执行示例输入来记录模型的计算图。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-实用工具和领域特定库&#34;&gt;2. 实用工具和领域特定库
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.utils&lt;/code&gt;&lt;/strong&gt;: 提供了各种实用工具。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.utils.data&lt;/code&gt;&lt;/strong&gt;: 数据加载和处理工具。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.utils.data.Dataset&lt;/code&gt;: 用于封装数据样本及其标签的抽象类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.utils.data.DataLoader&lt;/code&gt;: 迭代数据集并提供批量数据加载、并行加载和数据混洗等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.utils.tensorboard&lt;/code&gt;: 集成了 TensorBoard，用于可视化训练过程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.utils.bottleneck&lt;/code&gt;: 用于性能分析和调试。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torchvision&lt;/code&gt;&lt;/strong&gt;: PyTorch 官方提供的计算机视觉库。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torchvision.datasets&lt;/code&gt;: 包含常用视觉数据集（如 ImageNet, CIFAR10, MNIST）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torchvision.models&lt;/code&gt;: 包含预训练的计算机视觉模型（如 ResNet, VGG, AlexNet）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torchvision.transforms&lt;/code&gt;: 图像预处理和数据增强变换。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torchvision.utils&lt;/code&gt;: 图像保存、网格显示等实用工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torchaudio&lt;/code&gt;&lt;/strong&gt;: PyTorch 官方提供的音频处理库。
&lt;ul&gt;
&lt;li&gt;包含音频数据集、模型和转换工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torchtext&lt;/code&gt;&lt;/strong&gt;: PyTorch 官方提供的自然语言处理 (NLP) 库。
&lt;ul&gt;
&lt;li&gt;包含文本数据集、词汇表、词嵌入和常用的 NLP 模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch_geometric&lt;/code&gt;&lt;/strong&gt;: (第三方库，但非常流行) 用于图神经网络 (GNN)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch_scatter&lt;/code&gt;&lt;/strong&gt;: (第三方库，但非常流行) 提供散列操作，常与 &lt;code&gt;torch_geometric&lt;/code&gt; 配合使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torchmetrics&lt;/code&gt;&lt;/strong&gt;: (第三方库，但非常流行) 提供各种机器学习指标的实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-分布式训练&#34;&gt;3. 分布式训练
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.distributed&lt;/code&gt;&lt;/strong&gt;: 用于多 GPU 或多节点分布式训练。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.distributed.init_process_group&lt;/code&gt;: 初始化分布式环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.distributed.all_reduce&lt;/code&gt;, &lt;code&gt;torch.distributed.broadcast&lt;/code&gt;: 实现张量在不同进程间的通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.nn.parallel&lt;/code&gt;&lt;/strong&gt;: 提供一些简单的并行化策略。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.nn.DataParallel&lt;/code&gt;: 单机多 GPU 数据并行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.nn.parallel.DistributedDataParallel (DDP)&lt;/code&gt;: 推荐的多 GPU/多节点并行化方法，更高效、更灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-混合精度训练&#34;&gt;4. 混合精度训练
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.amp&lt;/code&gt;&lt;/strong&gt;: (Automatic Mixed Precision) 用于自动混合精度训练，利用 FP16 和 FP32 混合计算，以加速训练和减少内存消耗。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;torch.amp.autocast&lt;/code&gt;: 自动进行类型转换的上下文管理器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;torch.cuda.amp.GradScaler&lt;/code&gt;: 用于解决混合精度训练中梯度过小的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-高级特性和生态系统&#34;&gt;5. 高级特性和生态系统
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;torch.compile&lt;/code&gt; (PyTorch 2.0+):&lt;/strong&gt; 引入的编译功能，可以显著提升模型训练和推理的速度，通过将 PyTorch 代码编译成优化的图表示。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TorchScript&lt;/strong&gt;: PyTorch 的中间表示 (IR)，允许你将模型从 Python 转换为一个可独立运行的图表示，方便部署到 C++ 或移动设备。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ONNX (Open Neural Network Exchange)&lt;/strong&gt;: PyTorch 可以方便地导出模型到 ONNX 格式，这是一种开放标准，允许在不同深度学习框架之间进行模型互操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PyTorch Lightning&lt;/strong&gt;: 一个轻量级的 PyTorch 封装，提供了一个高级接口，用于管理训练循环、分布式训练、日志记录等，从而减少样板代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hugging Face Transformers&lt;/strong&gt;: 虽然不是 PyTorch 核心库的一部分，但它是 PyTorch 生态系统的重要组成部分，提供了大量预训练的 NLP 模型和工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;整体架构&#34;&gt;整体架构
&lt;/h2&gt;&lt;p&gt;主要说来，程序主要由两个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;神经网络和MCTS组成的算法&lt;/li&gt;
&lt;li&gt;根据象棋规则来生成动作&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;主要算法&#34;&gt;主要算法
&lt;/h2&gt;&lt;p&gt;主要算法就是AlphaGo Zero提出的算法。AlphaZero 的自我对弈（Self-Play）更新机制是其核心创新之一，它使得 AlphaZero 能够从零开始，在没有人类专家数据的情况下，学习并超越人类顶尖棋手的水平。这个机制是强化学习的一个典范。&lt;/p&gt;
&lt;p&gt;主要流程为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;神经网络初始化&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;训练开始时，神经网络的参数是随机初始化的&lt;/li&gt;
&lt;li&gt;神经网络双分支输出，一个策略(policy)输出$p$，一个价值(value)输出$v$
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;策略（Policy）输出 p：&lt;/strong&gt; 预测在当前状态下，每个合法走法的概率分布。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;价值（Value）输出 v：&lt;/strong&gt; 预测当前状态下，当前玩家最终获胜的概率（或预期回报）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自我对弈生成训练数据：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;在每轮自我对弈中，程序会利用当前的神经网络来指导蒙特卡洛树搜索（MCTS）进行决策，并生成一盘完整的对局。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;蒙特卡洛树搜索（MCTS）的迭代过程：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;选择（Selection）：&lt;/strong&gt; 从根节点（当前局面）开始，根据 MCTS 的 UCB（Upper Confidence Bound）或 PUCB（Polynomial Upper Confidence Bound）公式（结合了神经网络的先验概率 p 和访问次数 N）选择一条路径，直到达到一个未完全扩展的节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展（Expansion）：&lt;/strong&gt; 如果到达的节点不是一个终止局面，就使用神经网络对该节点进行一次评估，得到该局面的策略 p 和价值 v。同时，将这个新节点及其子节点添加到搜索树中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模拟（Simulation，在AlphaZero中通常省略或简化）：&lt;/strong&gt; 但在AlphaZero中，神经网络的价值输出 v 直接取代了随机模拟，提供了更准确的估计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向传播（Backpropagation）：&lt;/strong&gt; 将神经网络评估得到的价值 v 以及对局的最终结果（胜利或失败，通常为 +1 或 -1）沿着选择路径向上回传，更新路径上所有节点的访问次数 N、总价值 Q 和平均价值 W。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成走法策略 π：&lt;/strong&gt; 在 MCTS 进行了一定数量的模拟（例如800次）后，不再直接使用神经网络的策略输出 p 来选择走法。而是根据 MCTS 树中每个走法的访问次数 N(s,a) 来生成一个更强大的走法策略 π，通常是按访问次数的幂次方（如 N(s,a)1/t，其中 t 是一个温度参数，用于控制探索与利用的平衡）进行归一化。访问次数越多的走法，表明 MCTS 认为该走法越有潜力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;收集训练样本：&lt;/strong&gt; 每一步棋的 (状态 $s_t$​, MCTS 策略 $π_t$​, 最终胜负 z) 作为一个训练样本被收集起来。其中 $s_t$​ 是当前局面，$π_t$​ 是由 MCTS 产生的走法概率分布， z 是最终游戏结果（胜利为 +1，失败为 -1，和棋为 0）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;神经网络训练&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;收集到足够的数据就能展开训练了，就是深度学习中最小化损失函数的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型更新与迭代&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;每次训练我们希望得到的是新的强化过程，也就是比之前更强的模型。训练好的新神经网络会与旧的神经网络进行评估。如果新网络表现更好（通常通过在竞技场中进行对局来判断，胜率高过一个阈值就更新），它就会取代旧网络，成为下一轮自我对弈生成数据的基准模型。&lt;/li&gt;
&lt;li&gt;这个过程持续迭代：自我对弈生成数据 -&amp;gt; 训练更新神经网络 -&amp;gt; 评估新旧模型 -&amp;gt; 替换模型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;杂项&#34;&gt;杂项
&lt;/h2&gt;&lt;h3 id=&#34;清零梯度&#34;&gt;清零梯度
&lt;/h3&gt;&lt;p&gt;我们对一个批次训练时每次都要清零梯度。原因是PyTorch 的设计理念是，默认情况下，&lt;strong&gt;梯度是累积的（accumulated）&lt;/strong&gt;。这意味着当你调用 &lt;code&gt;loss.backward()&lt;/code&gt; 时，新计算出的梯度会&lt;strong&gt;加到&lt;/strong&gt;张量（&lt;code&gt;torch.Tensor&lt;/code&gt;）的 &lt;code&gt;.grad&lt;/code&gt; 属性中（如果该张量是模型的可学习参数）。
举个例子：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第一次 &lt;code&gt;loss.backward()&lt;/code&gt;&lt;/strong&gt;：计算并生成梯度 G1​，将其存储在参数的 &lt;code&gt;.grad&lt;/code&gt; 属性中。此时，&lt;code&gt;param.grad&lt;/code&gt; 等于 G1​。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二次 &lt;code&gt;loss.backward()&lt;/code&gt;&lt;/strong&gt;：计算并生成梯度 G2​。如果此时不清零，PyTorch 会将 G2​ &lt;strong&gt;加到&lt;/strong&gt;现有的 &lt;code&gt;param.grad&lt;/code&gt; 上。所以，&lt;code&gt;param.grad&lt;/code&gt; 会变成 G1​+G2​。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;唯一例外梯度累积gradient-accumulation&#34;&gt;唯一例外：梯度累积（Gradient Accumulation）
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;梯度积累技术&lt;/strong&gt;是唯一一个有意不清零梯度的场景。在这种情况下，我们确实需要将多个小批次的梯度累加起来，以模拟更大的有效批量大小。但即使在这种情况下，当累积到一定步数并执行 &lt;code&gt;optimizer.step()&lt;/code&gt; 后，我们仍然会调用 &lt;code&gt;optimizer.zero_grad()&lt;/code&gt; 来清零，为下一轮的梯度积累做准备。&lt;/p&gt;
&lt;h3 id=&#34;pytorch训练一个批次的流程&#34;&gt;PyTorch训练一个批次的流程
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;每个批次的训练步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;设置模型为训练模式&lt;/strong&gt;: &lt;code&gt;model.train()&lt;/code&gt; (非常重要，影响 Dropout 和 BatchNorm 的行为)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;获取输入和目标&lt;/strong&gt;: 从数据加载器中获取一个批次的输入数据和对应的真实标签。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;设备转移&lt;/strong&gt;: 将数据移动到与模型相同的设备上 (CPU 或 GPU)：&lt;code&gt;inputs, labels = inputs.to(device), labels.to(device)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;清零梯度&lt;/strong&gt;: &lt;code&gt;optimizer.zero_grad()&lt;/code&gt;。在每次迭代前，清除上次计算的梯度，因为 PyTorch 默认会累积梯度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前向传播 (Forward Pass)&lt;/strong&gt;: 将输入数据输入模型，获得模型的预测输出。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;outputs = model(inputs)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计算损失 (Calculate Loss)&lt;/strong&gt;: 将模型的输出与真实标签输入损失函数，计算当前的损失值。
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;loss = criterion(outputs, labels)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;反向传播 (Backward Pass)&lt;/strong&gt;: &lt;code&gt;loss.backward()&lt;/code&gt;。根据损失值，自动计算所有可学习参数的梯度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数更新 (Optimizer Step)&lt;/strong&gt;: &lt;code&gt;optimizer.step()&lt;/code&gt;。使用计算出的梯度来更新模型的参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;（可选）学习率调度&lt;/strong&gt;: &lt;code&gt;scheduler.step()&lt;/code&gt; (如果使用了学习率调度器)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;detach分离计算图&#34;&gt;detach分离计算图
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;detach()&lt;/code&gt; 是 PyTorch 中 &lt;code&gt;torch.Tensor&lt;/code&gt; 对象的一个方法，它的核心作用是&lt;strong&gt;将一个张量从当前的计算图中分离出来，使其不再跟踪梯度&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;停止跟踪梯度（Stop Tracking Gradients）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;被 &lt;code&gt;detach()&lt;/code&gt; 后的张量，其 &lt;code&gt;requires_grad&lt;/code&gt; 属性会变为 &lt;code&gt;False&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;即使原始张量 &lt;code&gt;x&lt;/code&gt; 的 &lt;code&gt;requires_grad&lt;/code&gt; 是 &lt;code&gt;True&lt;/code&gt;，&lt;code&gt;x.detach()&lt;/code&gt; 得到的张量 &lt;code&gt;y&lt;/code&gt; 的 &lt;code&gt;requires_grad&lt;/code&gt; 也会是 &lt;code&gt;False&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;当对 &lt;code&gt;y&lt;/code&gt; 进行后续操作时，这些操作将不再被记录到计算图中，也不会为 &lt;code&gt;y&lt;/code&gt; 或其后续操作的张量计算梯度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;共享底层存储（Share Underlying Storage）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;detach()&lt;/code&gt; 返回的张量与原始张量共享相同的底层数据存储。&lt;/li&gt;
&lt;li&gt;这意味着，如果你修改了其中一个张量的数据（例如，通过 &lt;code&gt;y.add_(1)&lt;/code&gt; 进行原地操作），那么另一个张量的数据也会相应改变。&lt;/li&gt;
&lt;li&gt;但是，这种数据共享是单向的：对分离出的张量 &lt;code&gt;y&lt;/code&gt; 的任何&lt;strong&gt;会导致其值改变的操作&lt;/strong&gt;（如 &lt;code&gt;y.add_(1)&lt;/code&gt;），虽然会修改原始张量 &lt;code&gt;x&lt;/code&gt; 的值，但&lt;strong&gt;不会在 &lt;code&gt;x&lt;/code&gt; 的计算图中记录这个操作&lt;/strong&gt;。PyTorch 会在反向传播时检测到这种“原地修改”并报错，因为它无法正确地计算梯度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;防止不必要的梯度计算和内存开销&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在某些情况下，你可能需要使用某个张量的值进行计算，但你并不希望这个计算过程被记录到计算图中，也不希望为这个张量计算梯度。&lt;/li&gt;
&lt;li&gt;例如，在训练循环中，如果你想记录损失值但不希望损失值的计算过程影响到模型参数的梯度计算，你可以 &lt;code&gt;loss.detach().item()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;另一个例子是，当某个中间结果在后续计算中&lt;strong&gt;不需要&lt;/strong&gt;通过反向传播来更新其上游参数时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;多进程&#34;&gt;多进程
&lt;/h3&gt;&lt;p&gt;由于自我对弈是CPU上计算的，显然可以采用多线程或者多进程。但由于Python存在GIL锁的机制，无法真正实现多线程。全局解释器锁（GIL, Global Interpreter Lock）是 Python（尤其是 CPython 解释器）中的一个机制。它的作用是&lt;strong&gt;同一时刻只允许一个线程执行 Python 字节码&lt;/strong&gt;，即使你在多核 CPU 上开启了多个线程，实际上同一时刻只有一个线程在执行 Python 代码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何线程在执行 Python 代码前，必须先获得 GIL。&lt;/li&gt;
&lt;li&gt;这意味着即使你创建了多个线程，这些线程也不能真正并行地执行 Python 代码（C 扩展库释放 GIL 时除外）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以Python的多线程适用于I/O密集型任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O 密集型任务（如网络请求、文件读写、数据库操作等）大部分时间都在等待外部资源响应，而不是消耗 CPU。&lt;/li&gt;
&lt;li&gt;当线程遇到 I/O 操作时，GIL 会被释放，其他线程可以获得 GIL 并继续执行。&lt;/li&gt;
&lt;li&gt;这样，多线程可以在等待 I/O 的间隙切换执行，提高程序整体的资源利用率和吞吐量。&lt;/li&gt;
&lt;li&gt;典型场景：爬虫、网络服务器、日志处理等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而对于本任务是计算密集型的，不适合使用多线程，采用&lt;strong&gt;多进程&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;multiprocessing&lt;/code&gt; 模块通过创建多个独立的 Python 进程，每个进程都有自己的 Python 解释器和内存空间，各自拥有独立的 GIL。&lt;/li&gt;
&lt;li&gt;这样可以实现真正的多核并行运算，充分利用多核 CPU 的计算能力。&lt;/li&gt;
&lt;li&gt;适合 CPU 密集型任务，如自我对弈、神经网络推理、数据处理等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果是多线程，线程与线程之间属于同一个进程的话，是同属一个内存空间的，共享全局变量和内存。而如果是多进程，进程间内存独立，数据不能直接共享，需要用队列、管道、共享内存等方式通信，开销较大。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;日志模块&#34;&gt;日志模块
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;logging&lt;/code&gt; 模块采用模块化设计，主要包含以下四类组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Logger (记录器)&lt;/strong&gt;: 这是应用程序代码直接使用的接口。你可以通过 &lt;code&gt;logging.getLogger(name)&lt;/code&gt; 来获取一个 Logger 实例。&lt;code&gt;name&lt;/code&gt; 参数是可选的，如果提供，则会创建一个具名的 Logger；如果不提供，则会返回根 Logger (root logger)。Logger 有不同的日志级别，只有级别高于或等于 Logger 设定阈值的日志消息才会被处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Handler (处理器)&lt;/strong&gt;: 处理器负责将 Logger 创建的日志记录（LogRecord）发送到适当的目标。常见的 Handler 有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StreamHandler&lt;/code&gt;: 将日志输出到控制台（标准输出或标准错误）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FileHandler&lt;/code&gt;: 将日志输出到文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RotatingFileHandler&lt;/code&gt;: 类似于 &lt;code&gt;FileHandler&lt;/code&gt;，但会在文件达到一定大小时自动轮转（创建新的日志文件）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TimedRotatingFileHandler&lt;/code&gt;: 类似于 &lt;code&gt;RotatingFileHandler&lt;/code&gt;，但会根据时间（例如每天、每周）进行日志轮转。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMTPHandler&lt;/code&gt;: 将日志通过电子邮件发送。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HTTPHandler&lt;/code&gt;: 将日志通过 HTTP GET 或 POST 请求发送到 Web 服务器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Formatter (格式化器)&lt;/strong&gt;: 格式化器指定最终输出中日志记录的样式。你可以定义日志消息的格式，包括时间、文件名、行号、日志级别、消息内容等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Filter (过滤器)&lt;/strong&gt;: 过滤器提供了更细粒度的控制，用于决定哪些日志记录应该被输出。你可以在 Logger 或 Handler 上添加过滤器，以进一步筛选日志。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;日志级别-logging-levels&#34;&gt;日志级别 (Logging Levels)
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;logging&lt;/code&gt; 模块定义了以下标准日志级别（从低到高）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DEBUG (10)&lt;/strong&gt;: 详细的调试信息，通常只在开发阶段使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;INFO (20)&lt;/strong&gt;: 确认程序按预期工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WARNING (30)&lt;/strong&gt;: 表示发生了一些意外事件，或将来可能会出现问题（但程序仍在正常运行）。这是默认的级别。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ERROR (40)&lt;/strong&gt;: 表示由于严重问题，程序无法执行某些功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CRITICAL (50)&lt;/strong&gt;: 表示发生了非常严重的错误，程序可能无法继续运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;层级结构&#34;&gt;层级结构
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Logger 的层级结构 (Hierarchical Loggers)&lt;/strong&gt;: 当你使用 &lt;code&gt;logging.getLogger(__name__)&lt;/code&gt; 时，&lt;code&gt;__name__&lt;/code&gt; 会是模块的完全限定名。例如，&lt;code&gt;main.py&lt;/code&gt; 中的 Logger 名称是 &lt;code&gt;&#39;main&#39;&lt;/code&gt;，&lt;code&gt;module_a.py&lt;/code&gt; 中的 Logger 名称是 &lt;code&gt;&#39;module_a&#39;&lt;/code&gt;，&lt;code&gt;my_package.sub_module&lt;/code&gt; 中的 Logger 名称是 &lt;code&gt;&#39;my_package.sub_module&#39;&lt;/code&gt;。 &lt;code&gt;logging&lt;/code&gt; 模块有一个层级结构，Logger 会将其日志消息传递（“传播”）给它们的父 Logger，直到根 Logger。根 Logger 是所有 Logger 的祖先。 在 &lt;code&gt;main.py&lt;/code&gt; 中，我们配置了根 Logger。因此，&lt;code&gt;module_a&lt;/code&gt; 和 &lt;code&gt;module_b&lt;/code&gt; 中 Logger 发出的日志消息会向上冒泡到根 Logger，然后被根 Logger 的 Handler 处理，最终输出到控制台和文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;logging&lt;/code&gt; 模块的 Logger 形成一个&lt;strong&gt;树状的层级结构&lt;/strong&gt;。这种层级结构是通过 Logger 名称中的&lt;strong&gt;点号（&lt;code&gt;.&lt;/code&gt;&lt;/strong&gt;）来表示的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;根 Logger (Root Logger):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;logging.getLogger()&lt;/code&gt;（不带任何参数）返回的是&lt;strong&gt;根 Logger&lt;/strong&gt;。它是所有其他 Logger 的祖先。&lt;/li&gt;
&lt;li&gt;它的名称是一个空字符串 &lt;code&gt;&#39;&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;具名 Logger (Named Loggers):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你调用 &lt;code&gt;logging.getLogger(&#39;some_name&#39;)&lt;/code&gt; 时，你获取的是一个具名 Logger。&lt;/li&gt;
&lt;li&gt;如果 Logger 的名称包含点号，那么点号前面的部分就是它的父 Logger 的名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;父子关系的确定规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;名称是前缀：&lt;/strong&gt; 如果一个 Logger 的名称是另一个 Logger 名称的&lt;strong&gt;点分隔前缀&lt;/strong&gt;，那么前者就是后者的父 Logger。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如：Logger &lt;code&gt;&#39;a.b&#39;&lt;/code&gt; 的父 Logger 是 &lt;code&gt;&#39;a&#39;&lt;/code&gt;。Logger &lt;code&gt;&#39;a&#39;&lt;/code&gt; 的父 Logger 是根 Logger &lt;code&gt;&#39;&#39;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;根 Logger 是所有 Logger 的祖先：&lt;/strong&gt; 所有的具名 Logger 最终都追溯到根 Logger。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;logging&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 1. 根 Logger&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;root_logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 名称是 &amp;#39;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 2. 具名 Logger &amp;#39;app&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;app_logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;app&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 3. 具名 Logger &amp;#39;app.module_a&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;module_a_logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;app.module_a&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 4. 具名 Logger &amp;#39;app.module_b&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;module_b_logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;app.module_b&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 5. 具名 Logger &amp;#39;app.module_a.sub_module&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sub_module_logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;app.module_a.sub_module&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;它们之间的父子关系如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;root_logger&lt;/code&gt; (名称 &lt;code&gt;&#39;&#39;&lt;/code&gt;) 是所有 Logger 的父 Logger。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;app_logger&lt;/code&gt; (名称 &lt;code&gt;&#39;app&#39;&lt;/code&gt;) 的父 Logger 是 &lt;code&gt;root_logger&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module_a_logger&lt;/code&gt; (名称 &lt;code&gt;&#39;app.module_a&#39;&lt;/code&gt;) 的父 Logger 是 &lt;code&gt;app_logger&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;module_b_logger&lt;/code&gt; (名称 &lt;code&gt;&#39;app.module_b&#39;&lt;/code&gt;) 的父 Logger 是 &lt;code&gt;app_logger&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sub_module_logger&lt;/code&gt; (名称 &lt;code&gt;&#39;app.module_a.sub_module&#39;&lt;/code&gt;) 的父 Logger 是 &lt;code&gt;module_a_logger&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;要点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;日志传播 (Propagation):&lt;/strong&gt; 默认情况下，子 Logger 会将它收到的日志消息传递给它的父 Logger，这个过程会一直持续到根 Logger。根 Logger 会将这些日志消息传递给它所关联的所有 Handler 进行实际的输出。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;__name__&lt;/code&gt; 的作用：&lt;/strong&gt; 在模块文件中使用 &lt;code&gt;logging.getLogger(__name__)&lt;/code&gt; 是一个最佳实践。&lt;code&gt;__name__&lt;/code&gt; 会自动设置为当前模块的完全限定名（例如，如果文件是 &lt;code&gt;my_package/my_module.py&lt;/code&gt;，那么 &lt;code&gt;__name__&lt;/code&gt; 就是 &lt;code&gt;&#39;my_package.my_module&#39;&lt;/code&gt;）。这使得日志的层级结构自然地与你的代码模块结构对应起来，便于管理和追踪日志来源。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;记录一个bug&#34;&gt;记录一个BUG
&lt;/h3&gt;&lt;p&gt;报错信息是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Traceback (most recent call last):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  File &amp;#34;D:\PycharmProjects\AlphaZero\main.py&amp;#34;, line 66, in &amp;lt;module&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    train_p.start()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  File &amp;#34;D:\app\anaconda3\Lib\multiprocessing\process.py&amp;#34;, line 121, in start
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    self._popen = self._Popen(self)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                  ^^^^^^^^^^^^^^^^^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  File &amp;#34;D:\app\anaconda3\Lib\multiprocessing\context.py&amp;#34;, line 224, in _Popen
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return _default_context.get_context().Process._Popen(process_obj)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  File &amp;#34;D:\app\anaconda3\Lib\multiprocessing\context.py&amp;#34;, line 337, in _Popen
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return Popen(process_obj)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;           ^^^^^^^^^^^^^^^^^^
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  File &amp;#34;D:\app\anaconda3\Lib\multiprocessing\popen_spawn_win32.py&amp;#34;, line 95, in __init__
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    reduction.dump(process_obj, to_child)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  File &amp;#34;D:\app\anaconda3\Lib\multiprocessing\reduction.py&amp;#34;, line 60, in dump
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    ForkingPickler(file, protocol).dump(obj)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TypeError: cannot pickle &amp;#39;_thread.RLock&amp;#39; object
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Exception in thread Thread-1 (_monitor):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Traceback (most recent call last):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  File &amp;#34;D:\app\anaconda3\Lib\multiprocessing\connection.py&amp;#34;, line 328, in _recv_bytes
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;关键在于&lt;code&gt;TypeError: cannot pickle &#39;_thread.RLock&#39; object Exception in thread Thread-1 (_monitor):&lt;/code&gt;。这个错误发生在 &lt;code&gt;multiprocessing&lt;/code&gt; 模块尝试&lt;strong&gt;序列化 (pickle)&lt;/strong&gt; 对象以在进程间传递时。&lt;/p&gt;
&lt;h4 id=&#34;错误的根本原因&#34;&gt;错误的根本原因：
&lt;/h4&gt;&lt;p&gt;&lt;code&gt;multiprocessing&lt;/code&gt; 模块在 Windows 系统上默认使用 &amp;ldquo;spawn&amp;rdquo; 启动方式。当它启动一个新进程时，它需要将父进程中的一些对象&lt;strong&gt;序列化&lt;/strong&gt;（使用 &lt;code&gt;pickle&lt;/code&gt; 模块）并传递给子进程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_thread.RLock&lt;/code&gt; 是一个&lt;strong&gt;递归锁 (Reentrant Lock)&lt;/strong&gt; 对象，它通常用于线程同步。&lt;strong&gt;&lt;code&gt;RLock&lt;/code&gt; 对象是不能被 pickle 化的。&lt;/strong&gt; 这意味着你不能直接将一个包含 &lt;code&gt;RLock&lt;/code&gt; 对象的 Logger 或 Handler 实例传递给子进程。&lt;/p&gt;
&lt;p&gt;在 Windows 系统上，&lt;code&gt;multiprocessing&lt;/code&gt; 模块默认使用 &amp;ldquo;spawn&amp;rdquo; 或 &amp;ldquo;forkserver&amp;rdquo; 启动方法（而不是 Unix 上的 &amp;ldquo;fork&amp;rdquo;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;spawn&lt;/code&gt; (Windows 默认，macOS 也建议使用):&lt;/strong&gt; 子进程是通过导入父进程模块来启动的。这意味着当一个子进程启动时，它会&lt;strong&gt;重新执行&lt;/strong&gt;父进程模块中的所有代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;fork&lt;/code&gt; (Unix/Linux 默认):&lt;/strong&gt; 子进程是父进程的副本，它会继承父进程的所有内存空间和打开的文件描述符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果在 &lt;code&gt;if __name__ == &amp;quot;__main__&amp;quot;:&lt;/code&gt; 块之外定义了像 &lt;code&gt;FileHandler&lt;/code&gt; 或 &lt;code&gt;StreamHandler&lt;/code&gt; 这样的对象，那么当子进程重新导入模块时，它们也会被重新创建。这些 Handler 内部可能包含 &lt;code&gt;RLock&lt;/code&gt; 或其他不可 pickle 的对象，导致 &lt;code&gt;TypeError: cannot pickle &#39;_thread.RLock&#39; object&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我在 &lt;code&gt;TrainPipeline&lt;/code&gt; 类的 &lt;code&gt;__init__&lt;/code&gt; 方法中直接实例化了 &lt;code&gt;logging.handlers.QueueHandler&lt;/code&gt; 并将其添加到了 &lt;code&gt;self.root&lt;/code&gt; Logger。当主进程启动一个子进程时，它需要将子进程要执行的 &lt;code&gt;target&lt;/code&gt; 函数以及 &lt;code&gt;args&lt;/code&gt; 中传递的所有对象进行序列化 (pickle)，然后传递给新进程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;train&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TrainPipeline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;current_policy.pkl&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;train_p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,))&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# &amp;lt;--- 问题在这！&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;原因分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;training_pipeline = train.TrainPipeline(...)&lt;/code&gt;：&lt;/strong&gt; 这一行代码在 &lt;strong&gt;主进程&lt;/strong&gt; 的 &lt;code&gt;if __name__ == &#39;__main__&#39;:&lt;/code&gt; 块内执行。这意味着 &lt;code&gt;TrainPipeline&lt;/code&gt; 的一个实例 &lt;code&gt;training_pipeline&lt;/code&gt; 在主进程中被创建了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;TrainPipeline&lt;/code&gt; 的 &lt;code&gt;__init__&lt;/code&gt; 方法：&lt;/strong&gt; 在 &lt;code&gt;TrainPipeline&lt;/code&gt; 的 &lt;code&gt;__init__&lt;/code&gt; 方法中，有以下代码：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setLevel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DEBUG&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QueueHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;worker_logger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;vm&#34;&gt;__name__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;err&#34;&gt;```&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;当&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;在主进程中被实例化时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，`&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;获取的是主进程的根&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Logger&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;虽然&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QueueHandler&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;本身可以被&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pickle&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;但&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;logging&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getLogger&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;获取的&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Logger&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;对象&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;尤其是根&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Logger&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;及其内部状态&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;包括可能关联的&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Manager&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;对象&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;），&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;在某些情况下可能包含&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;不可&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pickle&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;的内部锁对象&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;例如&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_thread&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`）。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mf&#34;&gt;3.&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`：&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;当将一个&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;实例方法&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`）&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;作为&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;的&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;multiprocessing&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;模块会隐式地尝试序列化&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;这个&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;实例本身&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;以便在子进程中重新构建它并调用其&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;方法&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;如果&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TrainPipeline&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;实例本身被当作参数传递给&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;或者&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;方法被当作&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;且&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;隐式传递&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;那么&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TrainPipeline&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;实例及其所有属性&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;包括&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;和&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qh&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`）&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;都将被尝试&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pickle&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;由于&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;实例在主进程中创建时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;其属性&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;如&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;和&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;qh&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`）&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;已经关联了主进程的日志系统内部对象&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;可能包含&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`），&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;因此在尝试序列化&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;实例时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;就会遇到&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;TypeError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cannot&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pickle&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;_thread.RLock&amp;#39;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#### 解决方案&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;核心思想是&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;所有涉及到进程间通信&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;如&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QueueHandler&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;和&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QueueListener&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`）&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;的日志配置&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;以及那些会在子进程中运行的类实例的创建&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;都应该在&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;子进程的上下文&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;中完成&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mf&#34;&gt;1.&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;创建包装函数作为&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;的&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`：&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;而不是直接将&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;training_pipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;作为&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;而是创建一个新的函数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;这个函数将作为&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Process&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;的&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`。&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;在这个新函数内部&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;再实例化&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TrainPipeline&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;和&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollectPipeline&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;并调用它们的&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;方法&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mf&#34;&gt;2.&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;将&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;作为参数传递&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;确保&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;被正确地作为参数传递给子进程的&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;函数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;以便子进程能够使用它来配置自己的&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QueueHandler&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;`。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;```&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;python&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 为训练进程定义一个包装函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# main.py&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 为训练进程定义一个包装函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run_train_pipeline_in_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init_model_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shared_lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;  此函数将在一个单独的进程中运行。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;  TrainPipeline 的实例化及其日志配置在此进程内部完成。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;  &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 在子进程中实例化 TrainPipeline&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;train_pipeline&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;train&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TrainPipeline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init_model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_model_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 调用 TrainPipeline 的 run 方法，并传入共享锁&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;train_pipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shared_lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 为数据收集进程定义一个包装函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run_collect_pipeline_in_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;process_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init_model_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shared_lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;  此函数将在一个单独的进程中运行。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;  CollectPipeline 的实例化及其日志配置在此进程内部完成。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;  &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# collect.CollectPipeline 的 __init__ 方法可能也需要 log_queue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 如果 collect.py 也有自己的日志配置，它也应该像 train.py 一样接收 log_queue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 这里假设 collect.py 也会使用 QueueHandler，所以需要传入 log_queue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;# 注意：你需要修改 collect.py 的 CollectPipeline.__init__ 以接受 log_queue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;collecting_pipeline&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollectPipeline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;process_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;init_model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;init_model_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_queue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;collecting_pipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shared_lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;pyqt5&#34;&gt;PyQt5
&lt;/h3&gt;&lt;h4 id=&#34;pyqt5-基本概念&#34;&gt;PyQt5 基本概念
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QApplication&lt;/code&gt;&lt;/strong&gt;: 每个 PyQt5 应用程序都需要一个 &lt;code&gt;QApplication&lt;/code&gt; 对象。它负责处理事件循环、命令行参数解析等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QWidget&lt;/code&gt;&lt;/strong&gt;: 所有用户界面对象的基类。它可以是窗口、按钮、标签等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;QtCore&lt;/strong&gt; : 主要和时间、文件与文件夹、各种数据、流、URLs、mime 类文件、进程与线程一起使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;QtGui&lt;/strong&gt; : 图形用户界面组件,包含了窗口系统、事件处理、2D 图像、基本绘画、字体和文字类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布局管理器 (Layout Managers)&lt;/strong&gt;: 用于组织和排列窗口中的小部件。常见的有 &lt;code&gt;QVBoxLayout&lt;/code&gt; (垂直布局)、&lt;code&gt;QHBoxLayout&lt;/code&gt; (水平布局)、&lt;code&gt;QGridLayout&lt;/code&gt; (网格布局) 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信号与槽 (Signals and Slots)&lt;/strong&gt;: 这是 PyQt5 的核心机制。当一个事件发生时（例如按钮被点击），会发出一个“信号”，你可以将这个信号连接到某个“槽”函数上，槽函数会在信号发出时被执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件处理 (Event Handling)&lt;/strong&gt;: PyQt5 通过事件循环来处理用户的输入和其他系统事件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绘图 (Painting)&lt;/strong&gt;: 你可以使用 &lt;code&gt;QPainter&lt;/code&gt; 在 &lt;code&gt;QWidget&lt;/code&gt; 上绘制图形、文本和图像。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Qt 框架中，对象的继承关系是其核心设计模式之一，它构建了 Qt 强大的功能和灵活的架构。理解 Qt 的继承体系对于有效使用 Qt 进行开发至关重要。&lt;/p&gt;
&lt;h4 id=&#34;qt-对象模型的基石qobject&#34;&gt;Qt 对象模型的基石：&lt;code&gt;QObject&lt;/code&gt;
&lt;/h4&gt;&lt;p&gt;Qt 中所有可交互的、支持信号与槽机制的对象都继承自一个共同的基类：&lt;code&gt;QObject&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;QObject&lt;/code&gt; 的关键特性：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;信号与槽（Signals &amp;amp; Slots）：&lt;/strong&gt; 这是 Qt 独有的机制，用于对象之间的通信。&lt;code&gt;QObject&lt;/code&gt; 提供了实现这一机制所需的基础设施。任何继承自 &lt;code&gt;QObject&lt;/code&gt; 的类都可以定义信号和槽，实现解耦的事件处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象树（Object Tree）：&lt;/strong&gt; &lt;code&gt;QObject&lt;/code&gt; 对象可以组织成一个父子层次结构，形成一个“对象树”。当父对象被删除时，它的所有子对象也会自动被删除（即子对象会被 &lt;code&gt;deleteLater()&lt;/code&gt; 标记为删除），这有助于管理内存，避免内存泄漏。
&lt;ul&gt;
&lt;li&gt;例如，你在窗口上放置一个按钮，按钮就是窗口的子对象。当你关闭窗口时，按钮也会随之销毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性系统（Property System）：&lt;/strong&gt; &lt;code&gt;QObject&lt;/code&gt; 提供了一个元对象系统（Meta-Object System），允许在运行时查询对象的属性、调用槽、发出信号等。属性系统允许你定义自定义属性，并进行持久化、动画等操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态类型信息：&lt;/strong&gt; 运行时类型信息（RTTI）在 Qt 中通过 &lt;code&gt;qobject_cast&amp;lt;T&amp;gt;()&lt;/code&gt; 和 &lt;code&gt;inherits()&lt;/code&gt; 等方法实现，允许你在运行时安全地进行类型转换和检查。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;qt-主要的继承层次&#34;&gt;Qt 主要的继承层次
&lt;/h4&gt;&lt;p&gt;从 &lt;code&gt;QObject&lt;/code&gt; 派生出了 Qt 应用程序中常见的各种类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;QObject&lt;/code&gt; (基类)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有需要信号与槽、对象树等功能的类都继承自它。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;QObject&lt;/code&gt; → &lt;code&gt;QPaintDevice&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;QPaintDevice&lt;/code&gt; 是所有可以被 &lt;code&gt;QPainter&lt;/code&gt; 绘制的对象的基类。它定义了绘图操作所需的基本接口。&lt;/li&gt;
&lt;li&gt;例子：&lt;code&gt;QPixmap&lt;/code&gt;, &lt;code&gt;QImage&lt;/code&gt;, &lt;code&gt;QWidget&lt;/code&gt;, &lt;code&gt;QPrinter&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;QObject&lt;/code&gt; → &lt;code&gt;QWidget&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;QWidget&lt;/code&gt; 是所有用户界面（UI）对象的基类。它代表了一个可见的、可以接收鼠标和键盘事件的矩形区域。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QWidget&lt;/code&gt; 继承自 &lt;code&gt;QObject&lt;/code&gt; (因此支持信号与槽、对象树) 和 &lt;code&gt;QPaintDevice&lt;/code&gt; (因此可以被绘制)。&lt;/li&gt;
&lt;li&gt;它提供基本的几何管理（大小、位置）、事件处理（鼠标、键盘）、绘画事件等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重要子类（构成大部分 GUI 界面）：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QMainWindow&lt;/code&gt;&lt;/strong&gt;: 提供一个带有菜单栏、工具栏、状态栏和中心部件的主应用程序窗口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QDialog&lt;/code&gt;&lt;/strong&gt;: 用于弹出对话框，例如文件选择对话框、设置对话框等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QPushButton&lt;/code&gt;&lt;/strong&gt;: 按钮。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QLabel&lt;/code&gt;&lt;/strong&gt;: 显示文本或图片。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QLineEdit&lt;/code&gt;&lt;/strong&gt;: 单行文本输入框。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QTextEdit&lt;/code&gt;&lt;/strong&gt;: 多行文本编辑器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QCheckBox&lt;/code&gt;&lt;/strong&gt;: 复选框。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QRadioButton&lt;/code&gt;&lt;/strong&gt;: 单选按钮。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QComboBox&lt;/code&gt;&lt;/strong&gt;: 下拉列表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;QListWidget&lt;/code&gt;&lt;/strong&gt;, &lt;code&gt;QTableWidget&lt;/code&gt;, &lt;code&gt;QTreeWidget&lt;/code&gt;: 用于显示列表、表格和树形结构数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布局管理器&lt;/strong&gt;（虽然它们不是 &lt;code&gt;QWidget&lt;/code&gt; 的子类，但与 &lt;code&gt;QWidget&lt;/code&gt; 紧密协作）：&lt;code&gt;QVBoxLayout&lt;/code&gt;, &lt;code&gt;QHBoxLayout&lt;/code&gt;, &lt;code&gt;QGridLayout&lt;/code&gt;, &lt;code&gt;QFormLayout&lt;/code&gt; 等。它们是 &lt;code&gt;QLayout&lt;/code&gt; 的子类，而 &lt;code&gt;QLayout&lt;/code&gt; 又是 &lt;code&gt;QObject&lt;/code&gt; 的子类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;QObject&lt;/code&gt; → &lt;code&gt;QAbstractItemModel&lt;/code&gt; / &lt;code&gt;QAbstractItemView&lt;/code&gt; (模型/视图框架)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Qt 的模型/视图编程提供了一种将数据（模型）和显示数据的方式（视图）分离的强大机制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QAbstractItemModel&lt;/code&gt; 是所有数据模型的抽象基类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QAbstractItemView&lt;/code&gt; 是所有视图的抽象基类。&lt;/li&gt;
&lt;li&gt;例子：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模型：&lt;/strong&gt; &lt;code&gt;QStringListModel&lt;/code&gt;, &lt;code&gt;QStandardItemModel&lt;/code&gt; (自定义数据模型通常会继承 &lt;code&gt;QAbstractItemModel&lt;/code&gt; 或其子类)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视图：&lt;/strong&gt; &lt;code&gt;QListView&lt;/code&gt;, &lt;code&gt;QTableView&lt;/code&gt;, &lt;code&gt;QTreeView&lt;/code&gt; (这些视图类也继承自 &lt;code&gt;QWidget&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;QObject&lt;/code&gt; → &lt;code&gt;QNetworkAccessManager&lt;/code&gt; (网络)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于执行网络请求，如 HTTP、FTP 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;QObject&lt;/code&gt; → &lt;code&gt;QTimer&lt;/code&gt; (定时器)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于在指定时间间隔后发出信号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;hellip;还有许多其他领域特定的类，如数据库（&lt;code&gt;QSqlDatabase&lt;/code&gt;）、多媒体（&lt;code&gt;QMediaPlayer&lt;/code&gt;）、图形视图框架（&lt;code&gt;QGraphicsView&lt;/code&gt;, &lt;code&gt;QGraphicsScene&lt;/code&gt;）等，它们也大多直接或间接继承自 &lt;code&gt;QObject&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&#34;继承关系图示简化版&#34;&gt;继承关系图示（简化版）
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     QObject
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        +----------------------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                |                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QPaintDevice         QLayout                 QNetworkAccessManager
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                |                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        |                |                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        +-- QWidget -----+                       |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               |                                 |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  +------------+------------+                    |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  |            |            |                    |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;QMainWindow    QDialog    QPushButton, QLabel,   |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           QLineEdit, ...        |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                                 |
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       QAbstractItemModel        QTimer
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                       QAbstractItemView
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;为什么-qt-采用这种继承结构&#34;&gt;为什么 Qt 采用这种继承结构？
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;统一的事件处理：&lt;/strong&gt; 所有的 &lt;code&gt;QObject&lt;/code&gt; 实例都可以参与到 Qt 的事件循环中，通过信号与槽进行通信。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理：&lt;/strong&gt; 对象树简化了内存管理，减少了程序员手动管理对象生命周期的负担。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性：&lt;/strong&gt; 通过继承，开发者可以在现有控件的基础上轻松创建自定义控件，复用大量现有功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;元对象系统：&lt;/strong&gt; 这是 Qt 强大的动态特性（如属性系统、翻译、信号与槽的反射）的基础，而 &lt;code&gt;QObject&lt;/code&gt; 及其继承体系是启用这些特性的关键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一致的 API：&lt;/strong&gt; 开发者在 Qt 应用程序中与不同类型的对象交互时，会发现其 API 风格和行为非常一致，降低了学习曲线。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;理解 Qt 的继承关系有助于你更好地选择合适的基类来开发自己的组件，利用 Qt 提供的丰富功能，并遵循其推荐的设计模式。&lt;/p&gt;
&lt;p&gt;在 Qt 的对象模型中，&lt;strong&gt;父子关系（Parent-Child Relationship）&lt;/strong&gt; 是通过 &lt;code&gt;QObject&lt;/code&gt; 类及其派生类来确立的，它是 Qt 内存管理和对象生命周期管理的核心机制之一。这种关系主要通过两种方式确立：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;在构造函数中指定父对象（最常见且推荐的方式）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过 &lt;code&gt;setParent()&lt;/code&gt; 方法设置父对象&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;父对象&#34;&gt;父对象
&lt;/h4&gt;&lt;h5 id=&#34;在构造函数中指定父对象-constructor-parameter&#34;&gt;在构造函数中指定父对象 (Constructor Parameter)
&lt;/h5&gt;&lt;p&gt;这是在 Qt 中确立父子关系最常见、最直接也是最推荐的方式。几乎所有继承自 &lt;code&gt;QObject&lt;/code&gt; 的类，包括所有的 &lt;code&gt;QWidget&lt;/code&gt; 控件，它们的构造函数都带有一个可选的 &lt;code&gt;parent&lt;/code&gt; 参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;child_object = ChildClass(parent_object)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;import sys
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QVBoxLayout, QWidget
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;class MyWindow(QMainWindow):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    def __init__(self):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        super().__init__()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        self.setWindowTitle(&amp;#34;父子关系示例&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        self.setGeometry(100, 100, 400, 300)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        central_widget = QWidget()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        self.setCentralWidget(central_widget)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        layout = QVBoxLayout(central_widget) # 布局管理器通常将其父部件作为参数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        # 创建一个按钮，并将其父对象设置为 central_widget
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        self.button1 = QPushButton(&amp;#34;按钮 1&amp;#34;, central_widget)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        layout.addWidget(self.button1)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        # 创建另一个按钮，也将其父对象设置为 central_widget
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        self.button2 = QPushButton(&amp;#34;按钮 2&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        self.button2.setParent(central_widget) # 也可以这样设置，但不如构造函数直接
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        layout.addWidget(self.button2)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;if __name__ == &amp;#39;__main__&amp;#39;:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    app = QApplication(sys.argv)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    window = MyWindow()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    window.show()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    sys.exit(app.exec_())
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在上面的例子中，&lt;code&gt;QPushButton(&amp;quot;按钮 1&amp;quot;, central_widget)&lt;/code&gt; 这一行代码，将 &lt;code&gt;central_widget&lt;/code&gt; 指定为 &lt;code&gt;button1&lt;/code&gt; 的父对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;QVBoxLayout(central_widget)&lt;/code&gt; 也是类似，布局管理器会自动将其管理的控件添加到其父部件上。&lt;/li&gt;
&lt;li&gt;当一个 &lt;code&gt;QObject&lt;/code&gt; 实例的构造函数接收一个 &lt;code&gt;QObject&lt;/code&gt; 类型的 &lt;code&gt;parent&lt;/code&gt; 参数时，它会将自身（子对象）添加到 &lt;code&gt;parent&lt;/code&gt; 对象的子对象列表中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;通过-setparent-方法设置父对象&#34;&gt;通过 &lt;code&gt;setParent()&lt;/code&gt; 方法设置父对象
&lt;/h5&gt;&lt;p&gt;你也可以在对象创建之后，通过调用其 &lt;code&gt;setParent()&lt;/code&gt; 方法来确立或修改父子关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;child_object.setParent(parent_object)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;示例（接上文）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 创建另一个按钮，先不指定父对象
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;self.button2 = QPushButton(&amp;#34;按钮 2&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 之后再将其父对象设置为 central_widget
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;self.button2.setParent(central_widget)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;layout.addWidget(self.button2) # 注意：布局管理器会把其添加的部件自动设为布局的父部件的子部件
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;需要注意的几点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个子对象只能有一个父对象。&lt;/strong&gt; 如果你多次调用 &lt;code&gt;setParent()&lt;/code&gt;，最新的调用会覆盖之前的父子关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存管理：&lt;/strong&gt; 当父对象被销毁时，所有作为其子对象的 &lt;code&gt;QObject&lt;/code&gt; 实例也会被自动销毁。这是 Qt 强大的内存管理机制。你通常不需要手动 &lt;code&gt;del&lt;/code&gt; 子对象，除非它们没有父对象。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重要提示：&lt;/strong&gt; 如果一个 &lt;code&gt;QObject&lt;/code&gt; 没有父对象，那么它的生命周期需要你手动管理。这在创建独立的窗口（如 &lt;code&gt;QMainWindow&lt;/code&gt; 或 &lt;code&gt;QDialog&lt;/code&gt;）时很常见，因为它们是应用程序的顶级窗口，通常没有父对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可见性：&lt;/strong&gt; 如果一个 &lt;code&gt;QWidget&lt;/code&gt; 有父对象，通常它的显示会受到父对象的限制。子部件不会显示在父部件之外。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;布局管理器：&lt;/strong&gt; 当你使用布局管理器 (&lt;code&gt;QHBoxLayout&lt;/code&gt;, &lt;code&gt;QVBoxLayout&lt;/code&gt;, &lt;code&gt;QGridLayout&lt;/code&gt; 等) 将控件添加到布局中时，布局管理器会自动处理控件的父子关系，通常会将布局的父部件设置为被添加控件的父部件。这也是为什么在上面的例子中，即使 &lt;code&gt;button2&lt;/code&gt; 最初没有指定父对象，但通过 &lt;code&gt;layout.addWidget(self.button2)&lt;/code&gt; 后，它最终也会成为 &lt;code&gt;central_widget&lt;/code&gt; 的子部件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;父子关系的好处&#34;&gt;父子关系的好处：
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自动内存管理：&lt;/strong&gt; 最重要的好处是避免了内存泄漏。你不需要担心何时释放子对象，Qt 会在父对象销毁时自动清理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;层次结构组织：&lt;/strong&gt; 方便管理和组织复杂的 UI 界面，形成清晰的对象树。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件传播：&lt;/strong&gt; 事件（如键盘事件、鼠标事件）可以沿着对象树从父对象传播到子对象，或反之，方便事件处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;属性继承：&lt;/strong&gt; 某些属性（如字体、调色板）可能会从父部件传递给子部件，简化了样式设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总而言之，在 Qt 中确立父子关系最常见的做法是在&lt;strong&gt;构造函数&lt;/strong&gt;中指定父对象，这不仅简洁，也确保了内存管理的正确性。&lt;/p&gt;
&lt;h4 id=&#34;qt-的事件传播机制&#34;&gt;Qt 的事件传播机制
&lt;/h4&gt;&lt;p&gt;当一个鼠标事件（比如 &lt;code&gt;mousePressEvent&lt;/code&gt;）发生时，Qt 的事件系统会遵循一套规则来决定哪个部件应该处理这个事件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;事件发生并首先发送给最顶层的部件：&lt;/strong&gt; 当用户点击屏幕上的某个点时，Qt 首先会确定哪个 &lt;strong&gt;最顶层（top-level）&lt;/strong&gt; 的 &lt;code&gt;QWidget&lt;/code&gt; 包含这个点击点（例如，你的主窗口）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件向下传播到最深层的子部件：&lt;/strong&gt; 然后，Qt 会从这个顶级部件开始，沿着对象树向下遍历，找到位于点击点下方的 &lt;strong&gt;最深层（innermost）&lt;/strong&gt; 的子部件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件分发给最深层部件：&lt;/strong&gt; Qt 会将 &lt;code&gt;mousePressEvent&lt;/code&gt; 首先分发给这个最深层的子部件（也就是你实际点击的那个控件）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件冒泡（Bubble Up）/ 默认处理：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;如果最深层的子部件重写了 &lt;code&gt;mousePressEvent&lt;/code&gt; 并且没有调用 &lt;code&gt;super().mousePressEvent(event)&lt;/code&gt;：&lt;/strong&gt; 那么这个事件就被这个子部件“消费”了，它不会继续向上冒泡到它的父部件。这意味着父部件的 &lt;code&gt;mousePressEvent&lt;/code&gt; 不会被触发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果最深层的子部件没有重写 &lt;code&gt;mousePressEvent&lt;/code&gt;：&lt;/strong&gt; 那么 Qt 会调用其父类的默认 &lt;code&gt;mousePressEvent&lt;/code&gt; 实现，事件会继续向上冒泡到其父部件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果最深层的子部件重写了 &lt;code&gt;mousePressEvent&lt;/code&gt; 但调用了 &lt;code&gt;super().mousePressEvent(event)&lt;/code&gt;：&lt;/strong&gt; 那么子部件的逻辑会先执行，然后事件会继续向上冒泡，触发父部件的 &lt;code&gt;mousePressEvent&lt;/code&gt;（如果父部件也重写了）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;信号与槽&#34;&gt;信号与槽
&lt;/h4&gt;&lt;p&gt;Qt 的信号与槽（Signals &amp;amp; Slots）机制是 Qt 框架的核心特性之一，它用于对象之间进行通信。这种机制替代了传统的 C++ 回调函数（callbacks）或函数指针，提供了一种类型安全、松散耦合的方式来处理事件和实现模块之间的通信。&lt;/p&gt;
&lt;h5 id=&#34;什么是信号signals&#34;&gt;什么是信号（Signals）？
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：当一个特定事件发生时，一个对象会发出（emit）一个信号。例如，&lt;code&gt;QPushButton&lt;/code&gt; 在被点击时会发出 &lt;code&gt;clicked()&lt;/code&gt; 信号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;触发&lt;/strong&gt;：信号由对象自动生成，以响应某些内部状态变化或用户操作。例如，当用户点击按钮时，按钮对象就会自动发出 &lt;code&gt;clicked()&lt;/code&gt; 信号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;自动生成&lt;/strong&gt;：信号是自动生成的，你不需要手动编写代码来发出它们，只需声明并连接。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数&lt;/strong&gt;：信号可以带有参数，这些参数可以传递事件的相关信息。例如，&lt;code&gt;QSlider&lt;/code&gt; 的 &lt;code&gt;valueChanged()&lt;/code&gt; 信号可以传递当前滑块的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无返回类型&lt;/strong&gt;：信号没有返回类型，它们不能返回任何值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;独立于接收者&lt;/strong&gt;：发出信号的对象（发送者）不需要知道是哪个对象（或哪些对象）在接收它的信号。这种松散耦合是信号与槽机制的关键优势。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;什么是槽slots&#34;&gt;什么是槽（Slots）？
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：槽是普通的 C++ 函数（或 Python 方法），当与之连接的信号被发出时，槽就会被调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：槽用于响应信号。例如，当 &lt;code&gt;QPushButton&lt;/code&gt; 发出 &lt;code&gt;clicked()&lt;/code&gt; 信号时，你可以将这个信号连接到一个槽，该槽负责执行某个操作，如更新文本标签或打开新窗口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;普通函数&lt;/strong&gt;：槽可以是任何普通的 Python 方法或 C++ 函数（包括静态函数、全局函数、或类的成员函数）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;参数匹配&lt;/strong&gt;：槽的参数必须与连接到它的信号的参数兼容。这意味着槽可以接受信号传递的所有参数，或者更少的参数（从右侧开始省略）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以是虚函数&lt;/strong&gt;：槽可以是虚函数，这使得它们可以在子类中被重写，从而实现多态行为。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以是私有、保护或公共&lt;/strong&gt;：槽的访问权限没有限制，但通常为了与其他类通信，它们会被声明为公共的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;如何连接connecting信号和槽&#34;&gt;如何连接（Connecting）信号和槽？
&lt;/h5&gt;&lt;p&gt;使用 &lt;code&gt;connect()&lt;/code&gt; 方法来建立信号与槽之间的连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基本语法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sender&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sender&lt;/code&gt;：发出信号的对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;signal&lt;/code&gt;：发送者对象的某个信号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;receiver&lt;/code&gt;：接收信号的对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slot&lt;/code&gt;：接收者对象的某个槽（方法）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;from PyQt5.QtWidgets import QApplication, QPushButton, QLabel, QVBoxLayout, QWidget
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;from PyQt5.QtCore import Qt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;app = QApplication([])
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;window = QWidget()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;layout = QVBoxLayout()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;button = QPushButton(&amp;#34;点击我&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;label = QLabel(&amp;#34;你好，世界！&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;label.setAlignment(Qt.AlignCenter)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 连接信号和槽
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;# 当 button 发出 clicked() 信号时，调用 label 的 setText() 槽
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;button.clicked.connect(lambda: label.setText(&amp;#34;按钮被点击了！&amp;#34;))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;layout.addWidget(button)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;layout.addWidget(label)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;window.setLayout(layout)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;window.show()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;app.exec_()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在这个例子中，&lt;code&gt;button&lt;/code&gt; 是发送者，&lt;code&gt;clicked()&lt;/code&gt; 是信号，&lt;code&gt;label&lt;/code&gt; 是接收者，&lt;code&gt;setText()&lt;/code&gt; 是槽。&lt;/p&gt;
&lt;h5 id=&#34;信号与槽的优势&#34;&gt;信号与槽的优势
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;松散耦合（Loose Coupling）&lt;/strong&gt;：发送者和接收者彼此独立，发送者不需要知道接收者的任何信息（除了它将发出的信号）。这种解耦使得组件更容易复用和维护。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型安全（Type Safety）&lt;/strong&gt;：Qt 的 &lt;code&gt;connect&lt;/code&gt; 机制会在连接时检查信号和槽的参数类型是否兼容，从而避免运行时错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重用性（Reusability）&lt;/strong&gt;：由于松散耦合，组件可以更容易地在不同的上下文和应用程序中被重用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;清晰的通信路径&lt;/strong&gt;：代码中信号和槽的连接清晰地表明了对象间的通信路径，使得代码更容易理解。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一对多 / 多对一连接&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;一个信号可以连接到多个槽。&lt;/li&gt;
&lt;li&gt;多个信号可以连接到同一个槽。&lt;/li&gt;
&lt;li&gt;一个信号可以连接到另一个信号（信号转发）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;自定义信号custom-signals&#34;&gt;自定义信号（Custom Signals）
&lt;/h5&gt;&lt;p&gt;除了 Qt 内置的信号，你也可以在自己的类中定义和发出自定义信号。在 PyQt 中，这通过 &lt;code&gt;pyqtSignal&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;导入 &lt;code&gt;pyqtSignal&lt;/code&gt;&lt;/strong&gt;：&lt;code&gt;from PyQt5.QtCore import pyqtSignal&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在类中声明信号&lt;/strong&gt;：作为类属性声明，指定信号将传递的参数类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在方法中发出信号&lt;/strong&gt;：使用 &lt;code&gt;emit()&lt;/code&gt; 方法发出信号。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PyQt5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QtWidgets&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QApplication&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QWidget&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QPushButton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QVBoxLayout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QLabel&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PyQt5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QtCore&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pyqtSignal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QObject&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MyEmitter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 声明一个自定义信号，不带参数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;my_signal_no_args&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pyqtSignal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 声明一个带一个字符串参数的信号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;my_signal_with_str&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pyqtSignal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 声明一个带两个整数参数的信号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;my_signal_with_ints&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pyqtSignal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;do_something&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Doing something...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_signal_no_args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 发出不带参数的信号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_signal_with_str&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;操作 {self.counter} 完成！&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 发出带字符串参数的信号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_signal_with_ints&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;emit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 发出带整数参数的信号&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MyReceiver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;QObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;label&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;label&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;label&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;slot_no_args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;label&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setText&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;信号被接收了！&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;槽：不带参数的信号被触发。&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;slot_with_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;label&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setText&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;接收到消息: {message}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;槽：接收到字符串信号: {message}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;slot_with_ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;槽：接收到两个整数信号: {num1}, {num2}&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QApplication&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QWidget&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;layout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QVBoxLayout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;emitter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MyEmitter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;status_label&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QLabel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;等待操作...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MyReceiver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status_label&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 连接自定义信号到槽&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;emitter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_signal_no_args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slot_no_args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;emitter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_signal_with_str&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slot_with_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;emitter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;my_signal_with_ints&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;receiver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slot_with_ints&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;action_button&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;QPushButton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;执行操作&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;action_button&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clicked&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;emitter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;do_something&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 连接按钮点击到发射器的do_something方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;layout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addWidget&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;action_button&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;layout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;addWidget&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;status_label&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setLayout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;layout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;window&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;exec_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;面向对象编程&#34;&gt;面向对象编程
&lt;/h3&gt;&lt;p&gt;好久没回忆这里的内容了，之前写了很多C，搞忘记了这里。&lt;/p&gt;
&lt;h4 id=&#34;面向对象编程object-oriented-programming-oop简介&#34;&gt;面向对象编程（Object-Oriented Programming, OOP）简介
&lt;/h4&gt;&lt;p&gt;在解释继承和父对象之前，我们先快速回顾一下面向对象编程的基本思想。&lt;/p&gt;
&lt;p&gt;面向对象编程是一种编程范式，它将程序中的数据和操作数据的方法组织成一个个&lt;strong&gt;对象&lt;/strong&gt;。对象是类的实例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心概念：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类（Class）&lt;/strong&gt;: 它是创建对象的蓝图或模板。类定义了对象的属性（数据）和行为（方法）。例如，一个 &lt;code&gt;汽车&lt;/code&gt; 类可能定义了 &lt;code&gt;颜色&lt;/code&gt;、&lt;code&gt;品牌&lt;/code&gt; 等属性，以及 &lt;code&gt;启动&lt;/code&gt;、&lt;code&gt;加速&lt;/code&gt; 等方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象（Object）&lt;/strong&gt;: 它是类的实例。一个 &lt;code&gt;汽车&lt;/code&gt; 类的对象可以是“我的红色宝马”或者“邻居的蓝色丰田”。每个对象都有自己的属性值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封装（Encapsulation）&lt;/strong&gt;: 将数据（属性）和操作数据的方法（行为）捆绑在一起，形成一个独立的单元（对象）。它隐藏了对象的内部实现细节，只暴露必要的接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多态（Polymorphism）&lt;/strong&gt;: 允许不同类的对象对同一个消息做出不同的响应。例如，&lt;code&gt;汽车&lt;/code&gt; 和 &lt;code&gt;摩托车&lt;/code&gt; 都有 &lt;code&gt;启动&lt;/code&gt; 方法，但它们的具体启动方式可能不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;继承inheritance&#34;&gt;继承（Inheritance）
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;继承是面向对象编程中一个非常强大的机制，它允许一个类（子类/派生类）从另一个已存在的类（父类/基类）中获取（继承）属性和方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心思想：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;代码复用&lt;/strong&gt;: 子类可以直接使用父类中已经定义好的属性和方法，而无需重新编写，大大减少了代码冗余。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建立“is-a”关系&lt;/strong&gt;: 继承表达了一种“是（is-a）”的关系。例如，“狗是一种动物”，“轿车是一种汽车”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;: 子类可以在继承父类的基础上，添加自己特有的属性和方法，或者重写（覆盖）父类的方法，以实现更具体或不同的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在，我们想创建 &lt;code&gt;狗 (Dog)&lt;/code&gt; 和 &lt;code&gt;猫 (Cat)&lt;/code&gt; 类。它们都是动物，所以它们应该拥有动物的基本属性（名字）和行为（叫、吃）。这时，我们就可以让 &lt;code&gt;Dog&lt;/code&gt; 和 &lt;code&gt;Cat&lt;/code&gt; &lt;strong&gt;继承&lt;/strong&gt; &lt;code&gt;Animal&lt;/code&gt; 类：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Dog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# Dog 继承 Animal&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;breed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 调用父类 Animal 的构造函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;breed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;breed&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Dog 特有的属性&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;speak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 重写父类的 speak 方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; (一只&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;breed&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;) 汪汪叫！&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fetch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Dog 特有的方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; 正在捡球。&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Cat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Cat 继承 Animal&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 调用父类 Animal 的构造函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;color&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Cat 特有的属性&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;speak&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 重写父类的 speak 方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; (一只&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;猫) 喵喵叫！&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;scratch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Cat 特有的方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; 正在抓挠。&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Animal&lt;/code&gt; 是&lt;strong&gt;父类&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dog&lt;/code&gt; 和 &lt;code&gt;Cat&lt;/code&gt; 是&lt;strong&gt;子类&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dog&lt;/code&gt; 和 &lt;code&gt;Cat&lt;/code&gt; 自动获得了 &lt;code&gt;Animal&lt;/code&gt; 类的 &lt;code&gt;name&lt;/code&gt; 属性以及 &lt;code&gt;eat&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dog&lt;/code&gt; 和 &lt;code&gt;Cat&lt;/code&gt; 分别重写了 &lt;code&gt;speak&lt;/code&gt; 方法，使其更具体地表达了狗和猫的叫声。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dog&lt;/code&gt; 添加了特有的 &lt;code&gt;breed&lt;/code&gt; 属性和 &lt;code&gt;fetch&lt;/code&gt; 方法。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cat&lt;/code&gt; 添加了特有的 &lt;code&gt;color&lt;/code&gt; 属性和 &lt;code&gt;scratch&lt;/code&gt; 方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;父对象--父类parent-class--base-class--superclass&#34;&gt;父对象 / 父类（Parent Class / Base Class / Superclass）
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;“父对象”和“父类”是同一个概念的不同表达方式，但“父类”是更常用和准确的术语。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;父类（Parent Class / Base Class / Superclass）&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;: 被其他类继承的类。它提供通用的属性和方法，供子类共享。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;: 作为子类的基础，定义了子类共有的特性和行为。&lt;/li&gt;
&lt;li&gt;在上面的例子中，&lt;code&gt;Animal&lt;/code&gt; 就是 &lt;code&gt;Dog&lt;/code&gt; 和 &lt;code&gt;Cat&lt;/code&gt; 的父类。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;父对象&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个词组通常&lt;strong&gt;不直接用来指代类本身&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在某些上下文语境中，它可能间接指代&lt;strong&gt;父类的实例&lt;/strong&gt;。例如，如果 &lt;code&gt;dog_instance&lt;/code&gt; 是 &lt;code&gt;Dog&lt;/code&gt; 类的一个对象，那么我们可能会说 &lt;code&gt;dog_instance&lt;/code&gt; 的“父类型”是 &lt;code&gt;Animal&lt;/code&gt;，或者说 &lt;code&gt;dog_instance&lt;/code&gt; 是从 &lt;code&gt;Animal&lt;/code&gt; “派生”出来的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;组合与继承&#34;&gt;组合与继承
&lt;/h4&gt;&lt;h5 id=&#34;1-继承关系inheritance&#34;&gt;1. 继承关系（Inheritance）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义：&lt;/strong&gt; 继承表达的是一种“&lt;strong&gt;is-a&lt;/strong&gt;”（是&amp;hellip;一种）的关系。一个子类“是”一个父类。
&lt;ul&gt;
&lt;li&gt;例如：&lt;code&gt;狗是一种动物&lt;/code&gt; (Dog is an Animal)，&lt;code&gt;汽车是一种交通工具&lt;/code&gt; (Car is a Vehicle)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现方式：&lt;/strong&gt; 子类直接从父类派生，获得父类的属性和方法。子类可以扩展或重写父类的功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt; * &lt;strong&gt;代码复用：&lt;/strong&gt; 子类无需重新实现父类已有的功能。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;多态性：&lt;/strong&gt; 允许使用父类引用来处理子类对象，提高代码的灵活性和可扩展性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;层次结构：&lt;/strong&gt; 能够清晰地表示类之间的分类和泛化关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;紧耦合：&lt;/strong&gt; 子类和父类之间存在强烈的依赖关系。父类的改变可能会影响所有子类。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单一继承的限制：&lt;/strong&gt; 许多语言（如 Java、C#、Python 的普通类）只支持单继承，即一个子类只能有一个直接父类。这可能导致“类爆炸”或难以建模多方面特性的情况。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;违反封装：&lt;/strong&gt; 子类可以访问父类的受保护成员，一定程度上破坏了封装性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“脆弱的基类”问题：&lt;/strong&gt; 父类的一些修改（即使是很小的）也可能导致子类行为异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;2-组合关系composition&#34;&gt;2. 组合关系（Composition）
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义：&lt;/strong&gt; 组合表达的是一种“&lt;strong&gt;has-a&lt;/strong&gt;”（拥有&amp;hellip;）的关系。一个类“拥有”另一个类的对象作为其成员。
&lt;ul&gt;
&lt;li&gt;例如：&lt;code&gt;汽车拥有一个引擎&lt;/code&gt; (Car has an Engine)，&lt;code&gt;电脑拥有一个CPU&lt;/code&gt; (Computer has a CPU)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现方式：&lt;/strong&gt; 一个类（被称为&lt;strong&gt;容器类&lt;/strong&gt;或&lt;strong&gt;复合类&lt;/strong&gt;）在其内部包含另一个类（被称为&lt;strong&gt;被包含类&lt;/strong&gt;或&lt;strong&gt;组件类&lt;/strong&gt;）的实例作为其属性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;松耦合：&lt;/strong&gt; 容器类和被包含类之间的依赖性较弱。容器类只需要知道如何与被包含类的公共接口进行交互，而不需要关心其内部实现细节。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高内聚：&lt;/strong&gt; 每个类只负责自己的功能，职责更单一。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;灵活性：&lt;/strong&gt; 可以更容易地替换或修改组件，而不需要修改容器类的代码（只要接口不变）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;避免“脆弱的基类”问题：&lt;/strong&gt; 组合关系下，组件类的修改对容器类的影响远小于继承关系下父类的修改对子类的影响。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决多重继承的复杂性：&lt;/strong&gt; 当一个类需要多种功能时，可以通过组合多个组件来实现，避免了多重继承可能带来的复杂性和歧义。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能委托：&lt;/strong&gt; 容器类需要显式地将被包含类的功能暴露出来（通过方法调用），不像继承那样自动获得所有公共方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象创建和管理：&lt;/strong&gt; 容器类可能需要负责创建和管理其组件对象的生命周期。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;当一个类是另一个类的组成部分，而不是其具体类型时。&lt;/li&gt;
&lt;li&gt;当需要构建灵活、可配置的系统时。&lt;/li&gt;
&lt;li&gt;当一个类需要多种不同的功能，而这些功能可以通过独立的组件来提供时。&lt;/li&gt;
&lt;li&gt;“优先使用组合而不是继承”（Prefer composition over inheritance）是面向对象设计的一个重要原则，尤其是在需要高灵活性和低耦合度的场景。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Engine started.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Engine stopped.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Wheel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rotate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Wheel rotating.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Car&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;fm&#34;&gt;__init__&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;engine&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Car has an Engine (组合关系)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wheels&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Wheel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Wheel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Wheel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Wheel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# Car has Wheels (组合关系)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;drive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 委托给 engine 对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wheel&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wheels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;wheel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 委托给 wheel 对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Car is driving.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;stop_car&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Car stopped.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 使用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;my_car&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Car&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;my_car&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;drive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;my_car&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stop_car&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>CS61A</title>
        <link>https://oldlay.github.io/p/cs61a/</link>
        <pubDate>Mon, 11 Aug 2025 00:00:00 +0000</pubDate>
        
        <guid>https://oldlay.github.io/p/cs61a/</guid>
        <description>&lt;img src="https://oldlay.github.io/p/cs61a/Lambda.svg" alt="Featured image of post CS61A" /&gt;&lt;h2 id=&#34;第一章&#34;&gt;第一章
&lt;/h2&gt;&lt;h3 id=&#34;1-介绍&#34;&gt;1. 介绍
&lt;/h3&gt;&lt;p&gt;这门课主要针对的是如何编程。
这门课关于什么：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设计程序要做什么&lt;/li&gt;
&lt;li&gt;分析程序的表现&lt;/li&gt;
&lt;li&gt;确认程序的正确性&lt;/li&gt;
&lt;li&gt;控制复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每一个编程语言都会去操控值，其中一种值是函数，表达式是计算值和计算的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语句与表达式&lt;/strong&gt;：Python 代码由表达式和语句组成。从广义上讲，计算机程序由指令组成，这些指令用于执行以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算一些值&lt;/li&gt;
&lt;li&gt;执行动作
语句通常描述操作。当 Python 解释器执行一个语句时，它会执行相应的操作。另一方面，表达式通常描述计算。当 Python 评估一个表达式时，它会计算该表达式的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;：对象可以将数据和处理数据的逻辑无缝地捆绑在一起，从而管理两者的复杂性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解释器&lt;/strong&gt;： 计算复合表达式需要一个精确的程序，以可预测的方式解释代码。实现这种程序、对复合表达式进行求值的程序称为解释器。&lt;/p&gt;
&lt;p&gt;最后，我们会发现所有这些核心概念都密切相关：函数是对象，对象是函数，而解释器则是两者的实例。不过，要掌握编程艺术，关键是要清楚地理解这些概念及其在组织代码中的作用。&lt;/p&gt;
&lt;p&gt;学会解释错误和诊断意外错误的原因被称为&lt;strong&gt;调试&lt;/strong&gt;。调试的一些指导原则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逐步测试： 每一个编写良好的程序都是由可以单独测试的小型模块化组件组成的。尽快测试你编写的所有程序，以便及早发现问题，并对你的组件充满信心。&lt;/li&gt;
&lt;li&gt;隔离错误： 语句输出中的错误通常可以归咎于某个模块组件。在尝试诊断问题时，先将错误追踪到最小的代码片段，然后再尝试纠正。&lt;/li&gt;
&lt;li&gt;检查您的假设： 解释器会严格执行您的指令，不多也不少。当某些代码的行为与程序员认为（或假设）的行为不一致时，解释器的输出就会出乎意料。了解你的假设，然后将调试工作的重点放在验证你的假设是否确实成立上。&lt;/li&gt;
&lt;li&gt;咨询他人： 你并不孤单！如果你不理解错误信息，可以询问朋友、老师或搜索引擎。如果你已经找出了一个错误，但不知道如何纠正，可以请其他人帮忙看看。在集体解决问题的过程中，可以分享很多宝贵的编程知识。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-编程&#34;&gt;2. 编程
&lt;/h3&gt;&lt;p&gt;每一种强大的编程语言都有以下机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原始表达式和语句&lt;/strong&gt;，代表了语言所提供的最简单的构件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合手段&lt;/strong&gt;，通过这种手段可以从较简单的元素构建出复合元素；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象手段&lt;/strong&gt;，通过这种手段可以将复合元素作为单元进行命名和操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在编程中，我们要处理两种元素：函数和数据。从形式上讲，数据是我们想要操作的东西，而函数则描述了操作数据的规则。因此，任何功能强大的编程语言都应该能够描述原始数据和原始函数，并拥有一些组合和抽象函数与数据的方法。&lt;/p&gt;
&lt;p&gt;= 符号在 Python（以及许多其他语言）中被称为赋值运算符。赋值是我们最简单的抽象手段，因为它允许我们使用简单的名称来指代复合运算的结果，例如上面计算的面积。通过这种方式，我们可以逐步构建复杂度不断增加的计算对象，从而构建出复杂的程序。
将名称绑定到值，然后再通过名称检索这些值，这意味着解释器必须维护某种内存，以跟踪名称、值和绑定。这种内存被称为&lt;strong&gt;环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以如果从一个更高的视角(抽象)去看赋值操作(=)就会发现很多设计非常合理了。&lt;/p&gt;
&lt;p&gt;我们可以使用赋值语句为现有函数赋予新名称：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f = max
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;built-in function max&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f(2, 3, 4)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;4
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;将内置名称绑定到新值：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; max = 5
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; max
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;将 max 赋值给 5 后，max 名称不再与函数绑定，因此尝试调用 max(2, 3, 4) 将导致错误。&lt;/p&gt;
&lt;p&gt;要评估一个调用表达式，Python 将执行以下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;评估操作符和操作数子表达式，然后&lt;/li&gt;
&lt;li&gt;将操作符子表达式值的函数应用于操作数子表达式值的参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即使是这个简单的过程也能说明流程的一些重要问题。第一步规定，为了完成一个调用表达式的评估过程，我们必须首先评估其他表达式。因此，评估过程在本质上是递归的；也就是说，它的步骤之一是需要调用规则本身。
注意：赋值是语句，实行一个动作，而不是表达式。&lt;/p&gt;
&lt;h4 id=&#34;纯和非纯函数&#34;&gt;纯和非纯函数
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;纯函数&lt;/strong&gt;：函数有一些输入（参数），并返回一些输出（应用函数的结果）。没有副作用，只计算来返回值。
&lt;strong&gt;非纯函数&lt;/strong&gt;：除了返回值外，应用非纯函数还可能产生副作用，对解释器或计算机的状态造成一些改变。常见的副作用是使用 print 函数生成返回值之外的额外输出。&lt;/p&gt;
&lt;p&gt;纯函数受到限制，不能产生副作用，也不能随时间改变行为。施加这些限制会带来很多好处。首先，纯函数可以更可靠地组成复合调用表达式。其次，纯函数往往更易于测试。参数列表总是会导致相同的返回值，可以将其与预期返回值进行比较。
纯函数对于编写并发程序至关重要，在并发程序中，多个调用表达式可以同时求值。&lt;/p&gt;
&lt;p&gt;函数只能操作其本地环境这一事实对于创建模块化程序至关重要，在模块化程序中，纯函数只能通过它们获取和返回的值进行交互。&lt;/p&gt;
&lt;h3 id=&#34;2函数&#34;&gt;2.函数
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;核心思想：把函数当作值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如何理解这句话?
这句话意味着函数在编程语言中拥有与任何其他数据类型（如数字、字符串、列表等）相同的地位和能力。函数被视为一种特殊的值，这是函数式编程（Functional Programming）的一个核心概念。
在编程中，值（value）是可以被存储、传递、操作和返回的对象。常见的值包括数字、字符串、列表等。在 Python 中，函数同样是一种值。这意味着函数可以像其他值一样被存储、传递、操作和返回。&lt;/p&gt;
&lt;p&gt;在函数式编程中，函数被视为一等公民（first-class citizens），这意味着它们可以像其他值一样被处理。这种思想的核心是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高阶函数&lt;/strong&gt;：接受函数作为参数或返回函数的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可变性&lt;/strong&gt;：尽量避免修改数据，而是通过函数返回新的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;纯函数&lt;/strong&gt;：函数的输出只依赖于输入参数，没有副作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在 Python 中发现了一些任何功能强大的编程语言都必须具备的元素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数字和算术运算是原始的内置数据值和函数。&lt;/li&gt;
&lt;li&gt;嵌套函数应用提供了一种组合操作的方法。&lt;/li&gt;
&lt;li&gt;将名称与值绑定提供了一种有限的抽象方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将函数作为值看待带来了巨大的灵活性和表达力，是现代编程中许多高级概念的基础，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高阶函数（Higher-Order Functions）：&lt;/strong&gt; 能够接收函数作为参数或返回函数的函数。这是 CS 61A 中非常重要的一个主题，例如 &lt;code&gt;map&lt;/code&gt;、&lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;reduce&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象和模块化：&lt;/strong&gt; 允许你编写更通用、更可重用的代码。你可以将特定行为封装在函数中，然后将这些行为传递给其他函数，从而改变它们的行为而无需修改核心逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;闭包（Closures）：&lt;/strong&gt; 当一个内部函数引用了其外部作用域的变量时，即使外部函数已经执行完毕，这些变量仍然会被保留。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装饰器（Decorators）：&lt;/strong&gt; Python 中一种修改或增强函数行为的语法糖，其底层原理就是将函数作为值传递和返回。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数式编程：&lt;/strong&gt; 这种编程范式强调使用函数来构建程序，将函数视为核心构建块。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;现在我们将学习函数定义，这是一种更强大的抽象技术，通过它可以将名称与复合操作绑定，然后将其称为一个单元。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数名在环境图中会重复出现两次。
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;内在名称（intrinsic name）&lt;/strong&gt;：这是函数自身的名字，出现在函数定义中。例如，在func square(x)中，“square”就是函数的内在名称。一个函数自身只有一个内在名称，这个名称是函数定义时确定的，用于标识这个函数本身。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定名称（bound name）&lt;/strong&gt;：这是在环境的某个帧（frame）中与函数值绑定的名字。例如，如果我们在全局框架中用f = square，那么在全局框架中，“f”就是绑定到square函数的绑定名称。不同的名字可以绑定到同一个函数，但函数本身只有一个内在名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;两者的区别在于：绑定名称用于在环境中引用函数，而内在名称是函数本身的标识。在程序运行过程中，我们通过绑定名称来调用函数，但函数的内在名称不会改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;python提供三种将一个值定义到一个名字上的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;赋值&lt;/li&gt;
&lt;li&gt;定义函数&lt;/li&gt;
&lt;li&gt;函数传参&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;函数签名&lt;/strong&gt;：对函数形式参数的描述称为函数签名。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;匿名函数&lt;/strong&gt;：就是lambda函数，一般的函数是和名字绑定的，但匿名函数不是。
&lt;code&gt;lambda a, x, b: a * x + b&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;闭包&#34;&gt;&lt;strong&gt;闭包&lt;/strong&gt;
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;outer_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;inner_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Hello from inner_function!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inner_function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 调用 outer_function 并获取返回值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;my_function&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outer_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 调用返回的 inner_function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;my_function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;输出&#34;&gt;输出
&lt;/h5&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Hello from inner_function!
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;解释&#34;&gt;解释
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;函数作为返回值&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;outer_function&lt;/code&gt; 中，定义了一个内部函数 &lt;code&gt;inner_function&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;outer_function&lt;/code&gt; 的返回值是 &lt;code&gt;inner_function&lt;/code&gt; 的引用（而不是调用 &lt;code&gt;inner_function&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;当你在外部调用 &lt;code&gt;outer_function()&lt;/code&gt; 时，它返回了 &lt;code&gt;inner_function&lt;/code&gt; 的引用，并将这个引用赋值给变量 &lt;code&gt;my_function&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;闭包的特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inner_function&lt;/code&gt; 是一个闭包（closure）。闭包是一种特殊的函数对象，它不仅包含函数的代码，还包含了函数定义时所在的作用域链。&lt;/li&gt;
&lt;li&gt;在这个例子中，&lt;code&gt;inner_function&lt;/code&gt; 被定义在 &lt;code&gt;outer_function&lt;/code&gt; 的局部作用域中，但它被返回到全局作用域中。&lt;/li&gt;
&lt;li&gt;尽管 &lt;code&gt;outer_function&lt;/code&gt; 的调用已经结束，&lt;code&gt;inner_function&lt;/code&gt; 仍然可以访问 &lt;code&gt;outer_function&lt;/code&gt; 的局部作用域中的变量（如果有的话）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;为什么可以在外部调用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你将 &lt;code&gt;inner_function&lt;/code&gt; 的引用赋值给 &lt;code&gt;my_function&lt;/code&gt; 后，&lt;code&gt;my_function&lt;/code&gt; 实际上是一个指向 &lt;code&gt;inner_function&lt;/code&gt; 的引用。&lt;/li&gt;
&lt;li&gt;虽然 &lt;code&gt;inner_function&lt;/code&gt; 是在局部作用域中定义的，但它的引用被保存在全局作用域中（通过 &lt;code&gt;my_function&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;因此，你可以通过 &lt;code&gt;my_function()&lt;/code&gt; 来调用 &lt;code&gt;inner_function&lt;/code&gt;，就好像它是一个全局函数一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;闭包的用途&#34;&gt;闭包的用途
&lt;/h5&gt;&lt;p&gt;闭包在 Python 中非常有用，尤其是在以下场景中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;封装状态&lt;/strong&gt;：闭包可以捕获和封装局部变量的状态，使得这些变量在函数外部仍然可以被访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回调函数&lt;/strong&gt;：闭包可以作为回调函数传递，同时携带一些上下文信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;装饰器&lt;/strong&gt;：闭包是实现装饰器的基础，装饰器本质上是一个返回函数的函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;总结&#34;&gt;总结
&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;闭包&lt;/strong&gt;：内部函数 &lt;code&gt;inner_function&lt;/code&gt; 是一个闭包，它捕获了定义时所在的作用域。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用传递&lt;/strong&gt;：&lt;code&gt;outer_function&lt;/code&gt; 返回了 &lt;code&gt;inner_function&lt;/code&gt; 的引用，这个引用被保存在全局作用域中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;外部调用&lt;/strong&gt;：通过保存的引用，可以在外部调用 &lt;code&gt;inner_function&lt;/code&gt;，就好像它是一个全局函数一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;函数式抽象&#34;&gt;函数式抽象
&lt;/h4&gt;&lt;p&gt;尽管 sum_squares 非常简单，但它体现了用户定义函数最强大的特性。函数 sum_squares 是根据函数 square 定义的，但它仅依赖于 square 定义的其输入参数和输出值之间的关系。&lt;/p&gt;
&lt;p&gt;我们可以编写 sum_squares, 而不必考虑如何平方一个数。关于如何计算平方的细节可以被抑制，以便以后再考虑。事实上，就 sum_squares 而言，平方并不是一个特定的函数体，而是一个函数的抽象，即所谓的函数抽象。在这个抽象层面上，任何计算平方的函数都是同样好的。&lt;/p&gt;
&lt;p&gt;因此，仅考虑它们返回的值，任意个用于平方数的函数应该是不可区分的。每个函数都接受一个数值参数，并生成该数的平方作为值。&lt;/p&gt;
&lt;p&gt;换句话说，函数定义应该能够抑制细节。函数的用户可能不是自己编写的函数，而是从另一个程序员那里获得的 “黑匣子”。对于另一个程序员不应该需要知道函数是如何实现的才能使用它。Python 库具有这个属性。许多开发人员使用那里定义的函数，但很少有人检查过它们的实现。&lt;/p&gt;
&lt;p&gt;要掌握函数式抽象的使用，通常需要考虑它的三个核心属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;函数的域是它可以接受的参数集。&lt;/li&gt;
&lt;li&gt;函数的范围是它可以返回的值集。&lt;/li&gt;
&lt;li&gt;函数的意图是它计算输入和输出之间的关系 (以及它可能产生的任何副作用)。
通过函数式抽象的域、范围和意图来理解它们，对于在复杂程序中正确使用它们至关重要。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;好的函数设计&#34;&gt;好的函数设计
&lt;/h4&gt;&lt;p&gt;从根本上说，好的函数的特性都强化了函数是抽象的观念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个函数应该只有一个工作。这个工作应该可以用一个简短的名称来标识，并且可以用一行文本来表示。连续执行多个工作的函数应该分为多个函数。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;不要重复自己&lt;/strong&gt;&lt;/em&gt;是软件工程的一个核心原则。所谓的 DRY 原则指出，多个代码片段不应该描述冗余的逻辑。相反，这个逻辑应该被实现一次，给出一个名称，并多次应用。如果你发现自己复制和粘贴了一段代码，你可能已经找到了进行函数式抽象的机会。&lt;/li&gt;
&lt;li&gt;应该对函数进行一般性定义。Python 库中没有平方方法，这是因为它是 pow 函数的一个特殊情况，pow 函数会将数字提升到任意次幂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些准则提高了代码的可读性，减少了错误的数量， 并且经常最小化所写代码的总量。分解一个复杂的任务将功能转化为简洁的功能是一种需要经验才能掌握的技能。幸运的是, Python提供了几个特性来支持您的工作。&lt;/p&gt;
&lt;h5 id=&#34;文档&#34;&gt;文档
&lt;/h5&gt;&lt;p&gt;函数定义通常包括描述函数的文档， 称为文档字符串，它必须与函数体一起缩进。 文档字符串通常用三引号括起来。第一行描述函数所做的行为。下面几行可以描述参数和描述函数的行为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;pressure&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Compute the pressure in pascals of an ideal gas.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;		Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        v -- volume of gas, in cubic meters
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        t -- absolute temperature in degrees kelvin
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        n -- particles of gas
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.38e-23&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# Boltzmann&amp;#39;s constant&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当你以函数名称作为参数调用 help 时，你会看到它的文档字符串 (键入 q 退出 Python help)。&lt;/p&gt;
&lt;h5 id=&#34;默认参数值&#34;&gt;默认参数值
&lt;/h5&gt;&lt;p&gt;定义通用函数的一个后果是引入了额外的参数。具有多个参数的函数可能会导致调用困难和读取困难。&lt;/p&gt;
&lt;p&gt;在 Python 中，我们可以为函数的参数提供默认值。当调用该函数时，具有默认值的参数是可选的。如果参数值没有提供，则默认值将被绑定到形式参数名称。&lt;/p&gt;
&lt;h4 id=&#34;测试&#34;&gt;测试
&lt;/h4&gt;&lt;p&gt;测试驱动开发：先写出注释和测试，然后逐渐让测试可行。&lt;/p&gt;
&lt;p&gt;测试是一种系统地执行验证的机制。测试通常采用另一个函数的形式，该函数包含对被测试函数的一个或多个样本调用。然后根据预期结果验证返回值。与大多数旨在通用的函数不同，测试涉及选择和验证具有特定参数值的调用。测试还可以作为文档：它们演示如何调用函数以及哪些参数值是合适的。&lt;/p&gt;
&lt;p&gt;断言。程序员使用断言语句来验证期望，例如被测试函数的输出。断言语句在布尔上下文中有一个表达式，后面跟着一行引号 (单引号或双引号都可以，但要一致), 如果表达式计算结果为假值，则会显示该引号。
&lt;code&gt;assert fib(8) == 13, &#39;The 8th Fibonacci number should be 13&#39;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fib&lt;/code&gt; 的测试函数应该测试多个参数，包括 n 的极值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def fib_test():
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        assert fib(2) == 1, &amp;#39;The 2nd Fibonacci number should be 1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        assert fib(3) == 1, &amp;#39;The 3rd Fibonacci number should be 1&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        assert fib(50) == 7778742049, &amp;#39;Error at the 50th Fibonacci number&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当在文件中而不是直接在解释器中写入 Python 时，test 通常会写入同一个文件或带有后缀 _test.py 的邻近文件中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档测试&lt;/strong&gt;：Python 提供了一种方便的方法，可以直接在函数的文档字符串中放置简单的测试。文档字符串的第一行应该包含对函数的一行描述，后面紧跟一个空行。随后可能会有关于参数和行为的详细描述。此外，文档字符串可能包含一个调用函数的交互式会话示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sum_naturals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Return the sum of the first n natural numbers.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        &amp;gt;&amp;gt;&amp;gt; sum_naturals(10)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        55
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        &amp;gt;&amp;gt;&amp;gt; sum_naturals(100)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        5050
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;s2&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;total&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;交互可以通过 doctest 模块进行验证。下面，globals 函数返回全局环境的表示，这是解释器评估表达式所需的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from doctest import testmod
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; testmod()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;TestResults(failed=0, attempted=2)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为了验证单个函数的 doctest 交互，我们使用了一个名为 run_docstring_examples 的 doctest 函数。它的第一个参数是要测试的函数。第二个参数应该始终是表达式 globals () 的结果，globals () 是一个返回全局环境的内置函数。第三个参数为 True, 表示我们想要 “详细” 的输出：一个运行的所有测试的目录。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from doctest import run_docstring_examples
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; run_docstring_examples(sum_naturals, globals(), True)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Finding tests in NoName
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Trying:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    sum_naturals(10)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Expecting:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    55
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ok
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Trying:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    sum_naturals(100)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Expecting:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    5050
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ok
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当函数的返回值与预期结果不匹配时，run_docstring_examples 函数会将这个问题报告为测试失败。&lt;/p&gt;
&lt;p&gt;在文件中编写 Python 时，可以通过使用 doctest 命令行选项启动 Python 来运行文件中的所有 doctest:
&lt;code&gt;python3 -m doctest &amp;lt;python_source_file&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有效测试的关键是在实现新函数后立即编写 (并运行) 测试。在实现之前编写一些测试甚至是个好习惯，这样可以在脑海中留下一些示例输入和输出的印象。应用单个函数的测试称为单元测试。详尽的单元测试是良好程序设计的标志。&lt;/p&gt;
&lt;h4 id=&#34;高阶函数&#34;&gt;高阶函数
&lt;/h4&gt;&lt;p&gt;为了以命名概念的形式表达某些一般模式（就是将某种模式用函数抽象出来），我们需要构造一些函数，这些函数可以接受其他函数作为参数，也可以返回函数作为值。&lt;strong&gt;操纵函数的函数称为高阶函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们介绍过用户定义函数，它是一种对数字运算模式进行抽象的机制，从而使运算与所涉及的特定数字无关。有了高阶函数，我们开始看到一种更强大的抽象：一些函数表达了通用的计算方法，与它们调用的特定函数无关。&lt;/p&gt;
&lt;p&gt;下面看一个计算黄金分割率的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;improve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;#所定义的通用评估程序&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;golden_update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;square_close_to_successor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;approx_eq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;approx_eq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tolerance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1e-3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;abs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tolerance&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;phi&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;improve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;golden_update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;square_close_to_successor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个例子说明了计算机科学中两个相关的重要思想。首先，命名和函数可以让我们抽象出大量的复杂性。虽然每个函数定义都很琐碎，但我们的评估程序所启动的计算过程却相当复杂。其次，正是因为我们有了一个极其通用的 Python 语言评估程序，小的组件才能组成复杂的过程。了解了程序的解释程序，我们就能验证和检查我们创建的过程。&lt;/p&gt;
&lt;p&gt;与往常一样，我们改进的新通用方法需要一个测试来检验其正确性。黄金分割率可以提供这样一个检验，因为它也有一个精确的闭式解，我们可以将其与这个迭代结果进行比较。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from math import sqrt
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; phi = 1/2 + sqrt(5)/2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def improve_test():
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        approx_phi = improve(golden_update, square_close_to_successor)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        assert approx_eq(phi, approx_phi), &amp;#39;phi differs from its approximation&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; improve_test()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对这个测试来说，没有消息就是好消息：在成功执行 assert 语句后，improve_test 返回 None。&lt;/p&gt;
&lt;p&gt;上述示例说明了将函数作为参数传递的能力如何极大地增强了编程语言的表现力。每个一般概念或方程都映射到自己的短函数上。这种方法的一个负面影响是，全局框架中的小函数名称变得杂乱无章，而这些函数必须都是唯一的。另一个问题是，我们受到特定函数签名的限制：要改进的更新参数必须只包含一个参数。嵌套函数定义可以解决这两个问题，但需要我们丰富环境模型。&lt;/p&gt;
&lt;h5 id=&#34;嵌套函数定义&#34;&gt;嵌套函数定义
&lt;/h5&gt;&lt;p&gt;上述示例说明了将函数作为参数传递的能力如何极大地增强了编程语言的表现力。每个一般概念或方程都映射到自己的短函数上。这种方法的一个负面影响是，全局框架中的短函数名称变得杂乱无章，而这些函数必须都是唯一的。另一个问题是，我们受到特定函数签名的限制：要改进的更新参数必须只包含一个参数。嵌套函数定义可以解决这两个问题，但需要我们丰富环境模型。&lt;/p&gt;
&lt;p&gt;我们需要对环境模型进行两项扩展，以实现词法范围界定。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个用户定义的函数都有一个父环境：即定义该函数的环境。&lt;/li&gt;
&lt;li&gt;当用户定义的函数被调用时，其本地框架会扩展其父环境。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def average(x, y):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return (x + y)/2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def sqrt_update(x, a):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return average(x, a/x)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;两个参数的update函数与improve函数不兼容（update需要两个参数，而不是一个）。而且它只提供一次更新，而我们真正关心的是通过重复更新来取平方根。解决这两个问题的办法是将函数定义放在其他定义的主体中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def sqrt(a):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        def sqrt_update(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return average(x, a/x)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        def sqrt_close(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return approx_eq(x * x, a)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return improve(sqrt_update, sqrt_close)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;与局部赋值一样，局部 def 语句只影响当前局部框架。这些函数只有在 sqrt 被求值时才处于作用域内。与我们的求值过程一致，在调用 sqrt 之前，这些局部 def 语句甚至不会被求值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;词法范围&lt;/strong&gt;。本地定义的函数也可以访问其定义的作用域中的名称绑定。在本例中，sqrt_update 引用了 a 这个名称，它是其外层函数 sqrt 的形式参数。这种嵌套定义之间共享名称的规则称为词法作用域。重要的是，内部函数可以访问其定义环境（而不是调用环境）中的名称。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;average&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;improve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;guess&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;approx_eq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tolerance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1e-3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;abs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tolerance&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sqrt_update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;average&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sqrt_close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;approx_eq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;improve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sqrt_update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt_close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sqrt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;扩展环境&lt;/strong&gt;。一个环境可以由任意长的帧链组成，最后总是以全局帧结束。通过嵌套 def 语句调用定义在其他函数中的函数，我们可以创建更长的链。这次调用 sqrt_update 的环境由三个框架组成：本地 sqrt_update 框架、定义了 sqrt_update 的 sqrt 框架（标记为 f1）以及全局框架。&lt;/p&gt;
&lt;p&gt;因此，我们实现了 Python 中词法作用域的两个关键优势:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;局部函数的名称不会与定义它的函数的外部名称相冲突，因为局部函数名称将绑定在定义它的当前局部环境中，而不是全局环境中。&lt;/li&gt;
&lt;li&gt;局部函数可以访问外层函数的环境，因为局部函数的主体是在一个扩展了定义它时的评估环境的环境中进行评估的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;函数作为返回值&#34;&gt;函数作为返回值
&lt;/h5&gt;&lt;p&gt;通过创建返回值本身就是函数的函数，我们可以在程序中实现更强的表达能力。词法作用域编程语言的一个重要特点是，本地定义的函数在返回时会保持其父环境。下面的示例说明了这一特性的实用性。&lt;/p&gt;
&lt;p&gt;一旦定义了许多简单函数，函数组合就是我们编程语言中的一种自然组合方法。也就是说，给定两个函数 f(x) 和 g(x)，我们可能想定义 h(x) = f(g(x))。&lt;/p&gt;
&lt;p&gt;牛顿法是一种经典的迭代方法，用于寻找返回值为 0 的数学函数参数。找到函数的零点通常等同于解决其他一些感兴趣的问题，例如计算平方根。牛顿法是一种迭代改进算法：它改进了对任何可微分函数零点的猜测，这意味着它可以在任意点用直线逼近。牛顿法根据这些直线近似值来寻找函数的零点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def newton_update(f, df):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        def update(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return x - f(x) / df(x)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return update
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def find_zero(f, df):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        def near_zero(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return approx_eq(f(x), 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return improve(newton_update(f, df), near_zero)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在实验牛顿法时，请注意该方法并不总是收敛的。改进的初始猜测必须足够接近零点，而且必须满足函数的各种条件。尽管存在这一缺陷，牛顿法仍是一种强大的求解可微分方程的通用计算方法。在现代计算机中，对数和大整数除法的快速算法都采用了该技术的变体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;柯里化&lt;/strong&gt;：我们可以使用高阶函数将接受多个参数的函数转换为一系列接受单个参数的函数。更具体地说，给定函数 f (x，y), 我们可以定义一个函数 g, 使得 g (x)(y) 等价于 f (x，y)。在这里，g 是一个高阶函数，它接受单个参数 x, 并返回另一个接受单个参数 y 的函数。这种转换称为柯里化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def curried_pow(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        def h(y):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return pow(x, y)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; curried_pow(2)(3)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;8
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一些编程语言，如 Haskell, 只允许接受单个参数的函数，因此程序员必须柯里化所有多参数过程。在 Python 等更通用的语言中，当我们需要一个只接受单个参数的函数时，柯里化是有用的。例如，映射模式将一个单参数函数应用于一系列值。在后续章节中，我们将看到更多关于 映射模式的通用示例，但现在，我们可以在一个函数中实现该模式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def map_to_range(start, end, f):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        while start &amp;lt; end:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            print(f(start))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            start = start + 1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在上面的例子中，我们手动对 pow 函数执行柯里化转换以获得 curried_pow。相反，我们可以定义函数来自动执行柯里化以及逆向非柯里化转换：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def curry2(f):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;Return a curried version of the given two-argument function.&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        def g(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            def h(y):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                return f(x, y)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return h
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return g
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def uncurry2(g):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &amp;#34;&amp;#34;&amp;#34;Return a two-argument version of the given curried function.&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        def f(x, y):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return g(x)(y)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return f
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; pow_curried = curry2(pow)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; pow_curried(2)(5)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;32
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; uncurry2(pow_curried)(2, 5)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;32
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h5 id=&#34;lambda表达式&#34;&gt;Lambda表达式
&lt;/h5&gt;&lt;p&gt;注意，lambda表达式是表达式，不是完全意义上的函数。
到目前为止，每次我们想要定义一个新函数时，都需要给它起一个名字。但对于其他类型的表达式，我们不需要将中间值与名字关联起来。也就是说，我们可以计算 a&lt;em&gt;b + c&lt;/em&gt;d, 而无需为子表达式 a&lt;em&gt;b 或 c&lt;/em&gt;d 或整个表达式命名。在 Python 中，我们可以使用 Lambda 表达式即时创建函数值，这些表达式会计算未命名的函数。Lambda 表达式会计算一个函数，该函数的函数体只有一个返回表达式。不允许使用赋值语句和控制语句。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def compose1(f, g):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return lambda x: f(g(x))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们可以通过构建相应的英语句子来理解 Lambda 表达式的结构：&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre&gt;&lt;code&gt;lambda            x            :          f(g(x))
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&amp;ldquo;A function that    takes x    and returns     f(g(x))&amp;rdquo;&lt;/p&gt;
&lt;h5 id=&#34;第一类函数&#34;&gt;第一类函数
&lt;/h5&gt;&lt;p&gt;作为程序员，我们应该对识别程序中潜在抽象的机会保持警惕，基于它们进行构建，并将其泛化，以创建更强大的抽象。这并不是说一个人总是应该以尽可能抽象的方式编写程序；专业程序员知道如何选择适合他们任务的抽象级别。但重要的是能够从这些抽象的角度思考，这样我们就可以准备好在新的上下文中应用它们。高阶函数的重要性在于，它们使我们能够在编程语言中明确地将这些抽象表示为元素，这样它们就可以像其他计算元素一样被处理。&lt;/p&gt;
&lt;p&gt;总的来说，编程语言对计算元素的操作方式施加了限制。限制最少的元素被认为具有一等地位。一等元素的一些 “权利和特权” 包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它们可能与名称相关联。&lt;/li&gt;
&lt;li&gt;它们可以作为参数传递给函数。&lt;/li&gt;
&lt;li&gt;它们可以作为函数的结果返回。&lt;/li&gt;
&lt;li&gt;它们可以包含在数据结构中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python 授予函数完全一等地位，由此带来的表达能力提升是巨大的。&lt;/p&gt;
&lt;h5 id=&#34;函数装饰器&#34;&gt;函数装饰器
&lt;/h5&gt;&lt;p&gt;Python 提供了特殊的语法，用于在执行 def 语句 (称为装饰器) 时应用高阶函数。最常见的例子可能是 trace。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def trace(fn):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        def wrapped(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            print(&amp;#39;-&amp;gt; &amp;#39;, fn, &amp;#39;(&amp;#39;, x, &amp;#39;)&amp;#39;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return fn(x)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return wrapped
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; @trace
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    def triple(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return 3 * x
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; triple(12)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-&amp;gt;  &amp;lt;function triple at 0x102a39848&amp;gt; ( 12 )
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;36
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在这个例子中，定义了一个高阶函数 trace, 该函数返回一个函数，该函数在调用其参数之前使用打印语句输出参数。三重函数的 def 语句包含一个 @trace 注释，这影响了 def 的执行规则。像往常一样，创建了函数 triple。然而，名称 triple 并没有绑定到这个函数。相反，名称 triple 绑定到了新定义的 triple 函数上调用 trace 的返回函数值。在代码中，这个装饰器等价于：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def triple(x):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return 3 * x
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; 	triple = trace(triple) #注意这里，最初的triple定义被装饰器更新掉了
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;注意：函数内的赋值永远只看当前环境帧，也就是第一帧&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#不会改变f中的x，只会在g的环境中改变&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;递归&#34;&gt;递归
&lt;/h4&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/em&gt;：&lt;em&gt;只有在需要将递归变成尾递归时，才需要写辅助函数进行递归。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数的哲学&lt;/strong&gt;：作为调用者，只需要关注函数的功能，而不用关心内部的实现，这在递归中很重要。将递归调用视为函数抽象被称为递归信念的飞跃。我们根据函数本身定义函数，但只需要相信更简单的情况在验证函数的正确性时会正确工作。
所以，最好先想清楚，什么情况下进行递归，什么情况下进行当前的操作。&lt;/p&gt;
&lt;h5 id=&#34;线性递归&#34;&gt;线性递归
&lt;/h5&gt;&lt;p&gt;下面看一个例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sum_squares&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Return The sum of  K**2 for K from 1 to N&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;c1&#34;&gt;#return sum of K**2 for K from 1 to N-1 + N**2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;c1&#34;&gt;#这里sum_squares(N-1)的功能就是sum of K**2 for K from 1 to N-1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sum_squares&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;N&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;**&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;所有形如&lt;code&gt;sum_squares()&lt;/code&gt;的函数功能必须服从&lt;code&gt;Return The sum of  K**2 for K from 1 to N&lt;/code&gt;这个注释。&lt;/p&gt;
&lt;p&gt;很多时候，我们会将自己代入机器去一行一行分析代码来分析递归，但实际上不要这么做。应该像函数哲学一样，应该依赖于函数文档，而不是每次需要使用一个函数思考函数将如何做它应该做的，并跟踪它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防止无限递归&lt;/strong&gt;：要给一个递归确定一个下界，要让递归的参数（不一定是数值）能够感受到它在”缩短“，并且在到达这个下界时终止。&lt;/p&gt;
&lt;h4 id=&#34;异常&#34;&gt;异常
&lt;/h4&gt;&lt;p&gt;可以使用异常来进行防御性编程，来确保函数能做正确的事情。在python中，可以创造一个异常值和用&lt;code&gt;raise&lt;/code&gt;引发它。&lt;/p&gt;
&lt;p&gt;assert断言是对raise的外包装，&lt;code&gt;assert False&lt;/code&gt;和&lt;code&gt;raise AssertionError()&lt;/code&gt;会产生同样的效果。断言错误一般表示发生了非常糟糕的事情。&lt;/p&gt;
&lt;p&gt;当你预期了一个错误可能发生，可以使用&lt;code&gt;try&lt;/code&gt;语句来捕获异常。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;input&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;except&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;FileNotFoundError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Warning: could not open&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myfile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nb&#34;&gt;input&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;hr&gt;
&lt;h4 id=&#34;尾递归是什么&#34;&gt;尾递归是什么？
&lt;/h4&gt;&lt;p&gt;首先，我们来回顾一下尾递归。&lt;strong&gt;尾递归&lt;/strong&gt;是指在一个函数的最后一步操作中，返回的表达式就是对自身的递归调用。&lt;/p&gt;
&lt;p&gt;一个非尾递归的例子（Python）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;factorial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 最后一步是乘法操作，不是递归调用本身&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;factorial&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在这个例子中，&lt;code&gt;factorial(n-1)&lt;/code&gt; 返回后，还要进行一次乘法运算。这导致函数在递归调用返回前，必须&lt;strong&gt;保留当前调用的状态&lt;/strong&gt;（&lt;code&gt;n&lt;/code&gt; 的值），并将这些状态保存在调用栈中。当 &lt;code&gt;n&lt;/code&gt; 很大时，这会导致栈溢出。&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&#34;尾递归的实现和辅助函数&#34;&gt;尾递归的实现和辅助函数
&lt;/h5&gt;&lt;p&gt;为了将非尾递归转变为尾递归，我们需要将所有状态和中间结果作为参数，在递归调用中传递下去。这就需要引入一个&lt;strong&gt;辅助函数 (Helper Function)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这个辅助函数通常包含一个额外的参数，用于保存&lt;strong&gt;累积的结果 (accumulator)&lt;/strong&gt;。这样，每次递归调用时，它都会将当前的结果更新并传递给下一次调用，从而使得递归调用成为&lt;strong&gt;函数的最后一步&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个尾递归的例子（Python 伪代码）&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def factorial_tail(n):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    # 主函数，调用辅助函数并提供初始状态
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return factorial_helper(n, 1)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;def factorial_helper(n, accumulator):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    # 辅助函数，包含了递归逻辑和状态
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    if n == 1:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        # 递归的最后一步，直接返回累积的结果
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return accumulator
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    else:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        # 最后一步操作就是对自身的递归调用，没有其他操作
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        # 将中间结果 n * accumulator 作为参数传递给下一次调用
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return factorial_helper(n - 1, n * accumulator)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在上面的例子中，&lt;code&gt;factorial_helper&lt;/code&gt; 就是那个辅助函数。它包含了递归的核心逻辑，并用 &lt;code&gt;accumulator&lt;/code&gt; 参数来保存中间结果。&lt;code&gt;factorial_tail&lt;/code&gt; 主函数则只负责初始化这个过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h5 id=&#34;为什么只有在尾递归时才需要辅助函数&#34;&gt;为什么只有在尾递归时才需要辅助函数？
&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;管理状态：&lt;/strong&gt; 尾递归的核心在于&lt;strong&gt;将状态作为参数传递&lt;/strong&gt;。当一个函数需要进行复杂的、带状态的递归时，将累积的状态封装在辅助函数的参数中，比在主函数中处理要清晰得多。主函数（&lt;code&gt;factorial_tail&lt;/code&gt;）只定义了“是什么”（求阶乘），而辅助函数（&lt;code&gt;factorial_helper&lt;/code&gt;）定义了“如何做”（带状态的递归过程）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;清晰的职责分离：&lt;/strong&gt; 主函数提供一个简洁、易于使用的外部接口。它对外部调用者隐藏了递归实现的复杂性。调用者只需传入 &lt;code&gt;n&lt;/code&gt;，而无需关心 &lt;code&gt;accumulator&lt;/code&gt; 的初始值。这种设计模式符合&lt;strong&gt;抽象&lt;/strong&gt;的思想。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;语言特性：&lt;/strong&gt; 在支持尾递归优化的语言（如 Scheme、某些 Haskell 编译器）中，编译器会识别出这种模式，并将其优化为简单的循环，从而避免栈溢出。显式地使用一个辅助函数来构造尾递归，是向编译器或解释器“声明”：“嘿，这是一个可以被优化的尾递归！”&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结-1&#34;&gt;总结
&lt;/h3&gt;&lt;p&gt;总结以下，写函数的以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先写函数文档，确定函数的定义域和值域，并描述出来。就是输入的范围是什么，我要得到什么样的输出。&lt;/li&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;描述一个过程，该过程使用简单的步骤从输入计算输出。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;写测试文档，进行测试。&lt;/li&gt;
&lt;li&gt;进行防御性编程，确定函数正确的输入，对非法输入进行防御。&lt;/li&gt;
&lt;li&gt;设计你的函数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不要将所有功能写到一个函数里，也不要重复代码，如果写函数时想到这里需要某个功能，使用函数。&lt;/p&gt;
&lt;h2 id=&#34;面向对象&#34;&gt;面向对象
&lt;/h2&gt;&lt;p&gt;本章聚焦于数据，在计算机中，编程所经常做的一件事是将一个现实世界中的概念使用数据表示出来，对于现实世界的一辆汽车，我们需要思考如何用能够使用的数据来表示。&lt;/p&gt;
&lt;p&gt;使用复合抽象化使我们能够提高程序的模块化程度。将程序中处理数据表示方式的部分与处理数据操作方式的部分分离开来的一般技术是一种强大的设计方法，称为数据抽象化。数据抽象化使程序的设计、维护和修改变得更加容易。&lt;/p&gt;
&lt;p&gt;数据抽象化在性质上类似于函数式抽象。当我们创建函数式抽象时，可以抑制函数实现的细节，并且特定函数本身可以被任何具有相同整体行为的其他函数替换。换句话说，我们可以创建一个抽象，将函数的使用方式与函数实现的细节分离。类似地，数据抽象将复合数据值的使用方式与其构造的细节分离。&lt;/p&gt;
&lt;p&gt;数据抽象化的基本思想是将程序结构化，使其能够处理抽象数据。也就是说，我们的程序应该以这样的方式使用数据，即尽可能少地对数据做出假设。同时，将具体的数据表示定义为程序的独立部分。&lt;/p&gt;
&lt;p&gt;程序的这两个部分，即操作抽象数据的部分和定义具体表示的部分，通过一小组函数连接起来，这些函数根据具体表示实现抽象数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;em&gt;不要违反抽象&lt;/em&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在 CS 61A 中，&lt;strong&gt;违反抽象&lt;/strong&gt;（Violating Abstraction）是指你在编写程序时，&lt;strong&gt;依赖了抽象层内部的实现细节，而不是仅仅依赖其定义的接口或行为契约&lt;/strong&gt;。这通常会导致代码变得脆弱、难以维护和扩展。&lt;/p&gt;
&lt;p&gt;在 CS 61A 中，这个概念主要体现在 &lt;strong&gt;数据抽象&lt;/strong&gt; (Data Abstraction) 和 &lt;strong&gt;过程抽象&lt;/strong&gt; (Procedural Abstraction) 中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;违反数据抽象 (Violating Data Abstraction)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据抽象的目标是&lt;strong&gt;将数据的表示与其使用分离开来&lt;/strong&gt;。当你定义了一个抽象数据类型 (Abstract Data Type, ADT) 时，你提供了一组操作（构造函数和选择函数），用户只能通过这些操作来创建和访问数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;违反数据抽象的行为，就是直接去访问或修改底层数据的具体结构，而不是通过选择函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;举个 CS 61A 常见的例子：&lt;strong&gt;有理数 (Rational Numbers)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设你定义了一个有理数抽象，它由一个分子和一个分母组成。你可能会像这样实现它（CS 61A 中常用的列表表示）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 数据抽象的构造函数 (Constructor)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;make_rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;构造一个有理数 (numer/denom)&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 假设这里做了约分等处理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 数据抽象的选择函数 (Selectors)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;获取有理数的分子&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;获取有理数的分母&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 数据抽象的操作 (Operations)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add_rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;添加两个有理数&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# 这是一个使用选择函数的好例子&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;new_numer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;new_denom&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make_rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new_numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;违反数据抽象的例子：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个典型的违反数据抽象的行为是，当你需要获取一个有理数的分子时，直接写成 &lt;code&gt;my_rational[0]&lt;/code&gt;，而不是使用 &lt;code&gt;get_numer(my_rational)&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make_rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 这是好的行为：通过选择函数访问&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;numerator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numerator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 这是违反抽象的行为：直接访问底层实现细节&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 你在假设有理数就是用一个列表表示的，并且分子是列表的第一个元素&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;bad_numerator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bad_numerator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;为什么这是违反抽象？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设想一下，如果未来你决定改变有理数的内部实现方式，比如从列表改为元组，或者用自定义的对象：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 新的有理数实现方式 (使用元组)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;make_rational_v2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;denom&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_numer_v2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 仍然是索引0，但类型变了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_denom_v2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rational&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 仍然是索引1，但类型变了&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果你在代码中处处都使用了 &lt;code&gt;r[0]&lt;/code&gt; 来获取分子，那么当你切换到 &lt;code&gt;make_rational_v2&lt;/code&gt; 时，所有使用 &lt;code&gt;r[0]&lt;/code&gt; 的地方都必须手动修改，这会导致大量的工作和错误。&lt;/p&gt;
&lt;p&gt;但如果你始终使用 &lt;code&gt;get_numer(r)&lt;/code&gt;，那么你只需要修改 &lt;code&gt;get_numer&lt;/code&gt; 函数内部的实现即可，所有调用 &lt;code&gt;get_numer&lt;/code&gt; 的代码都无需改动。这就是抽象的强大之处：&lt;strong&gt;它允许你在不影响使用者的前提下改变底层实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;违反过程抽象 (Violating Procedural Abstraction)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;过程抽象是指将一系列操作封装成一个独立的函数，并给它一个清晰的、描述性的名称。用户只需要知道这个函数的作用和如何调用它，而不需要了解它内部的具体实现步骤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;违反过程抽象的行为，就是不依赖函数的契约（它做什么），而是依赖它内部是如何做的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，如果你有一个 &lt;code&gt;sort_list(my_list)&lt;/code&gt; 函数。违反抽象的行为可能是你假设这个函数会使用特定的排序算法（比如快速排序），然后基于这个假设去推断它的时间复杂度或内存使用，而不是仅仅依赖它“将列表排序”这个承诺。&lt;/p&gt;
&lt;p&gt;在 CS 61A 中，更常见的形式可能是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;复制粘贴代码而不是提取为函数：&lt;/strong&gt; 如果你发现一段相同的逻辑在多个地方出现，但没有将其封装成一个函数，那么你就是在重复实现，而不是利用过程抽象来重用和简化代码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不使用已有的抽象：&lt;/strong&gt; 当一个问题可以用已有的高阶函数（如 &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt;）或你之前定义的抽象数据类型来解决时，却选择重新从头实现细节。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 CS 61A 中，理解和避免违反抽象是学习如何编写&lt;strong&gt;健壮、可维护和可扩展&lt;/strong&gt;的程序的关键一步。这要求你：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;始终通过定义的接口（构造函数和选择函数）来操作抽象数据，而不是直接访问其内部表示。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;信任函数所提供的契约，只关注它做什么，而不去依赖它具体是怎么做的。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样做，你的代码会变得更加模块化，并且能够更好地应对未来可能发生的改变。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;序列&#34;&gt;序列
&lt;/h3&gt;&lt;p&gt;序列由一堆变量组成，序列有以下几种性质：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无限或有限&lt;/li&gt;
&lt;li&gt;可变或不可变&lt;/li&gt;
&lt;li&gt;可索引或不可索引&lt;/li&gt;
&lt;li&gt;可迭代
可索引指的是可以使用下标来访问，比如说&lt;code&gt;A[1]&lt;/code&gt;这种。而不是所有序列都是可索引的，也可以是可迭代的，可以依次取序列中的每个元素后再来处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;python的序列：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元组tuple&lt;/li&gt;
&lt;li&gt;列表list&lt;/li&gt;
&lt;li&gt;字符串string&lt;/li&gt;
&lt;li&gt;range()&lt;/li&gt;
&lt;li&gt;iterator迭代器&lt;/li&gt;
&lt;li&gt;generator生成器&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;选择&lt;/strong&gt;：通过索引提取序列中的某个元素，python的所有序列都是可索引的。
&lt;strong&gt;切片&lt;/strong&gt;：从一个序列中去除一部分创建一个新的序列。&lt;/p&gt;
&lt;p&gt;有时候，我们会发现一个函数返回了一个元组，为什么？这样可以进行连续赋值。&lt;code&gt;x,y = (1, 9)&lt;/code&gt;，等号右边一定是一个序列，并序列中的元素数量必须和左边列出来的一样。获得这样的元组列表的一个方法是&lt;code&gt;zip()&lt;/code&gt;。&lt;code&gt;zip()&lt;/code&gt;像一个拉链一样把两个列表的元组对应位置组合起来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; list(zip([1,2,5,6],[6,3,7,1]))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[(1,6), (2,3), (5,7), (6,1)]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注意：&lt;code&gt;zip()&lt;/code&gt;返回的是序列，一个生成器。&lt;/p&gt;
&lt;h4 id=&#34;列表&#34;&gt;列表
&lt;/h4&gt;&lt;p&gt;列表是可变序列，有很多奇特的操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[1, 9, 8, 4, 5]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[2:4] = []     #delete
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[1, 9, 5]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[1:1] = [2,3,4,5]     #in idx 1 but contain 1,insert a list
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[1, 2, 3, 4, 5, 9, 5]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[len(L) : ] = [10, 11]    #append a list
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[1, 2, 3, 4, 5, 9, 5, 10, 11]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[0:0] = range(-3,0)   #prepending
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[-3, -2, -1, 1, 2, 3, 4, 5, 9, 5, 10, 11]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;注意到一个python特性，正交性，也就是最后的那个例子，任何序列可以在赋值右边使用，能把两个合理的特性放在一起使用。&lt;/p&gt;
&lt;p&gt;**列表解析式：&lt;code&gt;[&amp;lt;expression&amp;gt; for &amp;lt;var&amp;gt; in &amp;lt;sequence expression&amp;gt; if &amp;lt;boolean expression&amp;gt; ]&lt;/code&gt;。一个在列表中的表达式语法，用来生成一个列表。&lt;/p&gt;
&lt;h3 id=&#34;非序列抽象数据类型&#34;&gt;非序列抽象数据类型
&lt;/h3&gt;&lt;h4 id=&#34;字典&#34;&gt;字典
&lt;/h4&gt;&lt;p&gt;字典是键值对的可变映射。&lt;/p&gt;
&lt;p&gt;字典的规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;键不能是可变类型，键必须是不可变类型。&lt;/li&gt;
&lt;li&gt;所有键必须不一样。每个键只能有一个值。&lt;/li&gt;
&lt;li&gt;值可以是任意类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;迭代字典：有很多种迭代字典的方法。&lt;/p&gt;
&lt;p&gt;将字典看作列表进行迭代。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;insects&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiders&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;centipedes&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;bees&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;insects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;#按照被加入字典的顺序进行迭代&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;#与下面等价&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;#按照被加入字典的顺序进行迭代&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;insects&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;spiders&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;centipedes&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;bees&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;insects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;spiders&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;centipedes&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;bees&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;突变&#34;&gt;突变
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;非破坏性操作和破坏性操作&lt;/strong&gt;：一个操作作用到一个对象上，如果没有改变这个对象那就是非破坏性的，如果改变了，这个对象在某个程度上发生了变化，那就是破坏性的。&lt;/p&gt;
&lt;p&gt;可变性和不可变性：不可变值是一旦创建就不会改变的，可变值相反，注意可变值是能够原地改变，如果要改变不可变值，一般是重新创建一个改变后的对象，而原来的仍不变。&lt;/p&gt;
&lt;p&gt;区分：&lt;code&gt;list.append()&lt;/code&gt;和&lt;code&gt;list.extend()&lt;/code&gt;方法并不相同。append只添加一个元素，而且将这个元素作为整体添加进去，但extend参数是一个可迭代的对象，将多个这种对象迭代添加。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#error&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;对象的同一性和内容的相等&#34;&gt;对象的同一性和内容的相等
&lt;/h3&gt;&lt;p&gt;同一性：就是同一个对象，&lt;code&gt;exp0 is exp1&lt;/code&gt;得到真值，说明这两个是同一个对象。
相等性：&lt;code&gt;exp0 == exp1&lt;/code&gt;，得到真值说明这两个表达式或者说对象有相同的值。&lt;/p&gt;
&lt;p&gt;在没有特定的理由的情况下，使用&lt;code&gt;is&lt;/code&gt;来替换&lt;code&gt;==&lt;/code&gt;是有风险的。在数字和字符串这种不可变的对象中使用&lt;code&gt;is&lt;/code&gt;可能会造成意想不到的结果，python有时候会优化内存，所以不要在数字和字符串中使用&lt;code&gt;is&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;作用域&#34;&gt;作用域
&lt;/h4&gt;&lt;p&gt;python中不能允许函数重新赋值全局作用域中的名字。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;#global current&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Count:&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里代码错误的原因是，在局部作用域中使用了一个未赋值的变量。python在看到创建局部的新current变量，那么就不会向上层作用域查找变量，而current未赋值又被引用了，所以出现错误。&lt;/p&gt;
&lt;p&gt;我们可以使用&lt;code&gt;global&lt;/code&gt;关键字明确让python重新赋值全局变量。但是&lt;strong&gt;在函数中使用全局变量并不好，我们要尽量避免，会产生副作用&lt;/strong&gt;。应该做的是将全局变量作为参数传递给函数。尽量避免使用&lt;code&gt;global&lt;/code&gt;和&lt;code&gt;nonglobal&lt;/code&gt;关键字。&lt;/p&gt;
&lt;h3 id=&#34;迭代器&#34;&gt;迭代器
&lt;/h3&gt;&lt;p&gt;迭代器是能够逐个访问值的对象。我们可以使用迭代器来遍历可迭代对象的结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;toppings&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;topperator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;iter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;toppings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;toppings是一个可迭代对象，对它使用&lt;code&gt;iter()&lt;/code&gt;就可以获得一个迭代器。&lt;code&gt;next()&lt;/code&gt;是一个全局内建函数，对迭代器使用会得到序列中的下一个元素。一旦没有元素剩下的情况，对迭代器使用&lt;code&gt;next()&lt;/code&gt;会得到&lt;code&gt;StopIteration&lt;/code&gt;的异常。&lt;/p&gt;
&lt;p&gt;如何知道一个对象是否是可迭代的？
可以查看这个对象是否有&lt;code&gt;__iter__&lt;/code&gt;方法和&lt;code&gt;__next__&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;对于一个通用的迭代器，使用while循环并捕获迭代结束的异常。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ranked_chocolates&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Dark&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;milk&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;White&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;chocolaterator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;iter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ranked_chocolates&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;#iter()实际上调用ranked_chocolates.__iter__()方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;choce&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chocolaterator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;choce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;except&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;StopIteration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;No more left!&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但实际上，下面我们通常使用的for循环来进行迭代是一个语法糖，实际上就是上面的while循环。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;ranked_chocolates&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Dark&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;milk&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;White&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chocolate&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ranked_chocolates&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;chocolate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一些返回迭代器的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;reversed(sequence)&lt;/code&gt;以相反的顺序迭代。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zip(*iterables)&lt;/code&gt;像拉链一样将每个列表对应位置的相关元素组合在一起。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map(func, iterable, ···)&lt;/code&gt;为迭代器中的每个对象调用func。和列表解析式的功能基本相同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter(func, iterable)&lt;/code&gt;过滤迭代器，看是否满足func的要求。和&lt;code&gt;[x for x in iterable if func(x)]&lt;/code&gt;功能一样。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;在迭代器下面改变可迭代对象是危险的&lt;/em&gt;。&lt;/p&gt;
&lt;h3 id=&#34;生成器&#34;&gt;生成器
&lt;/h3&gt;&lt;p&gt;生成器是能够从生成器函数中产生的迭代器。在生成器函数中惰性生成值。通过&lt;code&gt;yield&lt;/code&gt;来生成一个值，在给出&lt;code&gt;yield&lt;/code&gt;之后暂停函数，然后再重新启动函数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;evens&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为什么要生成器？
因为生成器很懒，在碰到处理大量输入的时候，这是非常有用的，只有在需要时才会生成下一项。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yield from&lt;/code&gt;是一个语法糖。等价于&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;a_then_b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;yield&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;a_then_b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;yield from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;yield from&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;yield from&lt;/code&gt; 的作用就是简化这种“在生成器内部迭代另一个生成器并逐个产生值”的模式。
它本质上是做了三件事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;自动迭代子生成器：&lt;/strong&gt; 它会迭代 &lt;code&gt;yield from&lt;/code&gt; 后面跟着的表达式（称为&lt;strong&gt;子迭代器&lt;/strong&gt;或 &lt;strong&gt;subiterator&lt;/strong&gt;），并把子迭代器产生的所有值直接传递给 &lt;code&gt;yield from&lt;/code&gt; 所在的生成器的调用者（称为&lt;strong&gt;调用者&lt;/strong&gt;或 &lt;strong&gt;caller&lt;/strong&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;传递 &lt;code&gt;send()&lt;/code&gt; 方法的值：&lt;/strong&gt; 如果调用者通过 &lt;code&gt;send()&lt;/code&gt; 方法向委托生成器发送了值，这些值会直接传递给子迭代器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理异常和 &lt;code&gt;return&lt;/code&gt; 值：&lt;/strong&gt; 如果子迭代器抛出了异常，这个异常会传递给委托生成器。如果子迭代器通过 &lt;code&gt;return&lt;/code&gt; 返回了一个值（在生成器中 &lt;code&gt;return&lt;/code&gt; 语句会引发 &lt;code&gt;StopIteration&lt;/code&gt; 异常，并将返回值作为 &lt;code&gt;StopIteration&lt;/code&gt; 的 &lt;code&gt;value&lt;/code&gt; 属性），这个值会被 &lt;code&gt;yield from&lt;/code&gt; 表达式捕获。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;面向对象编程&#34;&gt;面向对象编程
&lt;/h3&gt;&lt;p&gt;类是定义新数据类型的模板，类的实例称为对象。面向对象编程将数据和动作结合在一起形成对象。每个对象拥有的函数属性就是方法。&lt;/p&gt;
&lt;p&gt;注意一下，python的创建类属性和C++的不一样，python直接在&lt;code&gt;__init__()&lt;/code&gt;方法中创建并且初始化属性。类方法第一个参数都是self，也就是对象本身。一个绑定方法绑定了函数和调用这个函数的对象。
&lt;code&gt;class_name(args)&lt;/code&gt;为构造函数，调用会构造一个新对象，会调用类的&lt;code&gt;__init__()&lt;/code&gt;方法，新对象是init方法的第一个参数。
在不是__init__()函数的类方法中声明类属性也可以。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类变量&lt;/strong&gt;：这是在类中而不是在方法中的赋值，那么对于某个对象来说，这个变量不在实例中，而在类中，访问某个实例的类变量会向上查找，看是否是实例中的成员变量，如果不是，就去类变量中查找。主要用于让一些对象共享某一点。当一个子类继承自一个父类时，它会自动获得父类的所有属性和方法，这包括类变量。
这意味着子类和其实例可以通过点运算符 (&lt;code&gt;.&lt;/code&gt;) 直接访问父类中定义的类变量，就好像这些变量是它们自己定义的一样。如果直接通过&lt;strong&gt;子类名&lt;/strong&gt;来修改继承的类变量，Python 不会修改父类中的原始类变量。相反，它会在子类中&lt;strong&gt;创建（或覆盖）一个同名的新类变量&lt;/strong&gt;，从而&lt;strong&gt;遮蔽 (shadow) 或隐藏&lt;/strong&gt;了父类的同名变量。其他兄弟子类或父类自身不受影响。
如果通过&lt;strong&gt;实例&lt;/strong&gt;尝试修改类变量，Python 会在&lt;strong&gt;该实例上&lt;/strong&gt;创建一个同名的&lt;strong&gt;实例变量&lt;/strong&gt;。这个实例变量会遮蔽类变量，意味着后续通过该实例访问同名属性时，会优先找到实例变量。这不会影响类变量本身，也不会影响其他实例。&lt;/p&gt;
&lt;p&gt;python对于属性的访问非常随意，可以任意访问属性，甚至使用一个不存在的属性会自动创建它，所以使用&lt;code&gt;_&lt;/code&gt;声明希望这个变量是私有的，但是python依旧允许使用，只不过把自觉性交给程序员自己。&lt;/p&gt;
&lt;p&gt;格式化字符串：&lt;code&gt;f&amp;quot;We have {self._inventory} bars&lt;/code&gt;。可以直接在括号中引用变量。&lt;/p&gt;
&lt;h4 id=&#34;继承&#34;&gt;继承
&lt;/h4&gt;&lt;p&gt;继承的主要概念不多说了，主要记录一下python中的特性。
有时候在子类中重构方法时，仍需要调用父类的方法，可以使用&lt;code&gt;super()&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nb&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;food&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;c1&#34;&gt;#这两个等价&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;food&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;#Animal是当前的父类&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;调用超类的函数通常在&lt;code&gt;__init__()&lt;/code&gt;中常使用。&lt;/p&gt;
&lt;p&gt;python中可以进行多重继承，也就是一个类继承多个父类，但是不推荐这样做，这样的话，继承关系会变得非常复杂，重写方法要非常小心。&lt;/p&gt;
&lt;h4 id=&#34;组合&#34;&gt;组合
&lt;/h4&gt;&lt;p&gt;指的是对象由其他对象组成，说白了就是一个对象实例中有很多其他对象实例，一个对象的属性是别的对象。拥有多个相同方法的对象的好处是，可以用相同的方法处理这些对象，实际上，可以对一大堆子类调用同一个函数，即使他们不是同一个类。&lt;/p&gt;
&lt;p&gt;继承是is-a的关系，组合式has-a的关系。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dir()&lt;/code&gt;函数返回一个对象所拥有的所有属性列表。
&lt;code&gt;__repr__()&lt;/code&gt; 的主要目标是为&lt;strong&gt;开发者&lt;/strong&gt;提供一个清晰、无歧义的对象表示。它的返回值通常是一个字符串，该字符串描述了创建对象的代码，该字符串如果作为 Python 代码被执行，&lt;strong&gt;能够重新创建出该对象（或至少是一个等价的对象）&lt;/strong&gt;。使用&lt;code&gt;eval()&lt;/code&gt;对&lt;code&gt;__repr__()&lt;/code&gt;函数的返回值求值，会执行创建出此对象。&lt;/p&gt;
&lt;p&gt;在python中时常出现不确定是否一个对象有没有某个方法的情况，可以使用&lt;code&gt;getattr(bunny, &amp;quot;ears_hang_low&amp;quot;, False)&lt;/code&gt;函数来确定，如果没有，会返回第三个参数的默认值。&lt;code&gt;hasattr()&lt;/code&gt;可以检查是否一个对象有某个属性。
&lt;code&gt;getattr&lt;/code&gt;和&lt;code&gt;.&lt;/code&gt;运算符实际上都在背后调用了&lt;code&gt;__getattr__&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;在类内部的方法中，给属性赋值通常不会触发__setattr__方法，而会触发__getattribute__方法。这是因为在方法中，属性赋值操作实际上是对属性进行访问，然后调用属性的__set__方法来完成赋值过程。&lt;/p&gt;
&lt;p&gt;python的列表实现是动态数组，内存连续的存储方式，但为什么python允许使用混合元素类型的列表？
因为事实上python没有存储值，存储的是对象的引用，理解为箭头。
递归处理链表的一般模式是：基本情况是空链表，递归情况是通过处理rest来分解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://oldlay.github.io/p/cs61a/Pasted-image-20250726203125.png&#34;
	width=&#34;1181&#34;
	height=&#34;878&#34;
	srcset=&#34;https://oldlay.github.io/p/cs61a/Pasted-image-20250726203125_hu_9a7de08e34a818db.png 480w, https://oldlay.github.io/p/cs61a/Pasted-image-20250726203125_hu_ff6404959af03702.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;1&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;134&#34;
		data-flex-basis=&#34;322px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上面的记忆化需要确定他们发生的顺序，可以提前做好，不需要提前测试以确保一切都是可用的，以固定的顺序提前计算之后查表。
&lt;img src=&#34;https://oldlay.github.io/p/cs61a/Pasted-image-20250726203746.png&#34;
	width=&#34;1240&#34;
	height=&#34;855&#34;
	srcset=&#34;https://oldlay.github.io/p/cs61a/Pasted-image-20250726203746_hu_afb9c0d1a3dcf989.png 480w, https://oldlay.github.io/p/cs61a/Pasted-image-20250726203746_hu_60dbd63dcc4f90ae.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;2&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;145&#34;
		data-flex-basis=&#34;348px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;泛型&#34;&gt;泛型
&lt;/h4&gt;&lt;p&gt;如果能传递不同类型的参数，并从中得到相同功能的结果，那就是泛型函数。python提供了非常多的方法让我们可以在python中用泛型语法自定义类，它鼓励你把所有的对象变成像鸭子一样的东西。
鸭子类型，如果一个东西行为像鸭子，叫起来也像鸭子，那么就可以把它当作鸭子运行。
鸭子测试：去测试一个对象的行为而不是类型，被称为鸭子测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://oldlay.github.io/p/cs61a/Pasted-image-20250727094943.png&#34;
	width=&#34;1587&#34;
	height=&#34;1169&#34;
	srcset=&#34;https://oldlay.github.io/p/cs61a/Pasted-image-20250727094943_hu_12843c526c29ed61.png 480w, https://oldlay.github.io/p/cs61a/Pasted-image-20250727094943_hu_d2dd5ff7b290b3a7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;3&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;325px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;总结-2&#34;&gt;总结
&lt;/h3&gt;&lt;p&gt;多态性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个函数可以运行在不同类的对象上。&lt;/li&gt;
&lt;li&gt;鸭子类型，一个通用性的函数能够运行在任何具有特定行为方式的对象上。&lt;/li&gt;
&lt;li&gt;类型强制转换，一个函数可以转换参数来达到自己想要的类型。&lt;/li&gt;
&lt;li&gt;类型分派，函数检查参数类型来选择正确的行为。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;scheme&#34;&gt;Scheme
&lt;/h2&gt;&lt;p&gt;函数式编程只用“表达式”，不用“语句”。&lt;/p&gt;
&lt;p&gt;“表达式”（expression）是一个单纯的运算过程，总是有返回值；“语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。&lt;/p&gt;
&lt;p&gt;原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。&lt;br&gt;
当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。&lt;/p&gt;
&lt;p&gt;Scheme是一门早期的编程语言Lisp的一个方言，对于一个语言，必须了解这种编程语言操纵的值是什么，将Scheme数据分为两种，一种原子数据和一种是对数据。
Lisp早期是用来处理符号数据的，
这门语言有一个非常有意思的特性：Scheme程序就是Scheme数据，这意味着在执行Scheme程序是特别容易。
这些程序的基本情况是所有的原子值，大部分的list代表了Scheme程序中的函数调用。&lt;/p&gt;
&lt;h3 id=&#34;scheme-语言基础&#34;&gt;Scheme 语言基础
&lt;/h3&gt;&lt;p&gt;这一部分介绍了 Scheme 这种函数式编程语言的基本语法和特性，与 Python 形成了对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Lisp 方言：&lt;/strong&gt; Scheme 是 Lisp 家族的一员，其核心特点是&lt;strong&gt;极简的语法&lt;/strong&gt;和&lt;strong&gt;同像性（homoiconicity）&lt;/strong&gt;，即代码和数据结构（列表）有着相同的表示形式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;前缀表示法：&lt;/strong&gt; 所有操作符都放在操作数前面，并用括号括起来。例如，&lt;code&gt;( + 2 3 )&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;S-表达式：&lt;/strong&gt; Scheme 程序由 S-表达式（S-expressions）构成，它们可以是原子（数字、符号）或列表（嵌套的 S-表达式）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特殊形式 (Special Forms)：&lt;/strong&gt; 区别于普通函数调用，特殊形式在求值时有独特的规则，例如 &lt;code&gt;if&lt;/code&gt;、&lt;code&gt;define&lt;/code&gt;、&lt;code&gt;lambda&lt;/code&gt; 等。它们不先求值所有参数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;求值规则 (Evaluation Rules)：&lt;/strong&gt; 强调 Scheme 的求值模型，包括如何求值基本表达式、组合式（函数调用）、特殊形式等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高阶函数 (Higher-Order Functions)：&lt;/strong&gt; Scheme 强调函数是“头等公民”，可以作为参数传递、作为返回值返回，从而实现更抽象和灵活的代码。&lt;code&gt;lambda&lt;/code&gt; 表达式用于创建匿名函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;1-序列操作与-adt&#34;&gt;1. 序列操作与 ADT
&lt;/h4&gt;&lt;p&gt;这部分关注如何用 Scheme 处理序列数据，并引入了抽象数据类型（Abstract Data Types, ADTs）的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;列表作为基本序列结构：&lt;/strong&gt; Scheme 中列表是核心的序列数据结构，通过 &lt;code&gt;cons&lt;/code&gt;（构造）、&lt;code&gt;car&lt;/code&gt;（取头）、&lt;code&gt;cdr&lt;/code&gt;（取尾）等基本操作来构建和操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归处理序列：&lt;/strong&gt; 强调递归是 Scheme 中处理列表和序列的常用且自然的方式。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;抽象数据类型 (ADT)：&lt;/strong&gt; 讲解如何通过选择函数（selectors）和构造函数（constructors）来定义 ADT，从而将数据表示与其使用分离开来。这使得数据结构在底层实现变化时，使用它的代码无需修改。例如，用 &lt;code&gt;cons&lt;/code&gt;、&lt;code&gt;car&lt;/code&gt;、&lt;code&gt;cdr&lt;/code&gt; 来实现一对数据，而用户只通过 &lt;code&gt;make-pair&lt;/code&gt;、&lt;code&gt;first&lt;/code&gt;、&lt;code&gt;second&lt;/code&gt; 来使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-环境模型与求值过程&#34;&gt;2. 环境模型与求值过程
&lt;/h4&gt;&lt;p&gt;这是第三章最核心的部分，深入解释了 Scheme 代码是如何被解释器求值的，特别是关于变量绑定和作用域的规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;帧 (Frames) 和环境 (Environments)：&lt;/strong&gt; 解释器使用环境模型来管理变量绑定。一个&lt;strong&gt;环境&lt;/strong&gt;由一系列&lt;strong&gt;帧&lt;/strong&gt;组成，每个帧是一个从变量名到值的映射。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查找规则：&lt;/strong&gt; 当查找一个变量的值时，解释器会从当前帧开始，沿着环境链向上查找，直到找到第一个匹配的绑定。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定义 (Definitions) 与赋值 (Assignments)：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;define&lt;/code&gt; 用于创建新的变量绑定或修改当前帧中的现有绑定（如果存在）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set!&lt;/code&gt; 用于修改&lt;strong&gt;环境链中已存在的&lt;/strong&gt;变量绑定。如果没有找到绑定，则报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过程应用 (Procedure Application)：&lt;/strong&gt; 解释函数调用时，会创建一个新的环境帧，其中包含形式参数到实际参数值的绑定，并将这个新帧链接到定义函数时的环境（&lt;strong&gt;闭包&lt;/strong&gt;的概念）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;闭包 (Closures)：&lt;/strong&gt; 函数在被定义时（而不是被调用时）“记住”它所处的环境。当函数被调用时，它会基于这个记住的环境（而非调用时的环境）来查找非局部变量。这是 Scheme（以及 Python）中词法作用域（Lexical Scoping）的核心。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;3-解释器与元语言抽象&#34;&gt;3. 解释器与元语言抽象
&lt;/h4&gt;&lt;p&gt;这部分是将前面所有概念串联起来，构建一个简单 Scheme 解释器的概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解释器的结构：&lt;/strong&gt; 解释器通常包含两个核心部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;求值器 (Evaluator)：&lt;/strong&gt; 负责根据语言的求值规则来计算表达式的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用器 (Applier)：&lt;/strong&gt; 负责将过程（函数）应用于它们的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;元语言抽象 (Metalinguistic Abstraction)：&lt;/strong&gt; 指的是使用一种语言（如 Scheme）来描述或实现另一种语言（或同一语言的一个子集）。通过编写一个 Scheme 解释器，我们不仅理解了 Scheme 语言本身，更理解了&lt;strong&gt;语言的本质&lt;/strong&gt;和&lt;strong&gt;解释器的工作原理&lt;/strong&gt;。这是一种强大的抽象工具。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;计算器&#34;&gt;计算器
&lt;/h3&gt;&lt;h4 id=&#34;1-从表达式到结果解析与求值&#34;&gt;1. 从表达式到结果：解析与求值
&lt;/h4&gt;&lt;p&gt;计算器部分的核心任务是：给定一个字符串形式的数学表达式（例如 &lt;code&gt;&amp;quot;2 + 3 * 4&amp;quot;&lt;/code&gt;），如何让程序理解它并计算出结果？这涉及到两个主要阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;解析 (Parsing)：&lt;/strong&gt; 将输入的字符串表达式，从人类可读的形式转换成计算机更容易处理的&lt;strong&gt;结构化表示&lt;/strong&gt;，通常是&lt;strong&gt;表达式树 (Expression Tree)&lt;/strong&gt; 或 &lt;strong&gt;抽象语法树 (Abstract Syntax Tree, AST)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;词法分析 (Lexical Analysis / Tokenization)：&lt;/strong&gt; 原始字符串首先被分解成一系列有意义的“词法单元”或“标记”（Tokens）。例如，&lt;code&gt;&amp;quot;2 + 3 * 4&amp;quot;&lt;/code&gt; 会被分解为 &lt;code&gt;2&lt;/code&gt; (数字), &lt;code&gt;+&lt;/code&gt; (运算符), &lt;code&gt;3&lt;/code&gt; (数字), &lt;code&gt;*&lt;/code&gt; (运算符), &lt;code&gt;4&lt;/code&gt; (数字)。&lt;strong&gt;在 Scheme 中：&lt;/strong&gt; 想象一个 Scheme 解释器接收一个字符串，比如 &lt;code&gt;(+ 2 (* 3 4))&lt;/code&gt;。词法分析器会把它分解成 &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt; 这些独立的符号和数字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;语法分析 (Syntactic Analysis)：&lt;/strong&gt; 词法单元流根据预定义的语法规则（例如，运算符优先级、结合性）被组织成一个树形结构，通常是&lt;strong&gt;抽象语法树 (Abstract Syntax Tree, AST)&lt;/strong&gt;。它验证代码是否符合语言的语法规则。对于 &lt;code&gt;&amp;quot;2 + 3 * 4&amp;quot;&lt;/code&gt;，其表达式树的根节点会是 &lt;code&gt;+&lt;/code&gt;，因为 &lt;code&gt;*&lt;/code&gt; 的优先级更高，它会先被计算。&lt;strong&gt;在 Scheme 中：&lt;/strong&gt; Scheme 的 S-表达式天生就是一种抽象语法树的形式。&lt;code&gt;( + 2 ( * 3 4 ) )&lt;/code&gt; 这个 S-表达式本身就已经是一个树形结构。编译器会根据语言的语法规则，将标记流构建成 AST。AST 是程序的一种标准化、结构化的表示，后续的语义分析、优化和代码生成都基于 AST 进行。CS 61A 中的求值器直接操作这种 S-表达式形式的程序结构。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      +
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     / \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    2   *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       / \
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      3   4
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;语义分析 (Semantic Analysis)：&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt; 在 AST 的基础上，检查程序的语义正确性（例如，变量是否已定义、类型是否匹配等），并收集类型信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在 Scheme 中：&lt;/strong&gt; 在 Scheme 解释器中，这部分检查通常与求值过程交织在一起。例如，在查找变量时（环境模型），如果找不到绑定，就会抛出未定义变量的错误。函数调用时，也会检查参数数量是否正确。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与编译的关系：&lt;/strong&gt; 编译器在这个阶段会进行各种检查，确保程序的含义是明确和合法的。例如，如果 &lt;code&gt;+&lt;/code&gt; 运算符被应用于一个数字和一个列表，编译器会在此时报错（或生成运行时检查）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;求值 (Evaluation)：&lt;/strong&gt; 遍历这个表达式树，根据树的结构和节点的含义（数字、运算符），递归地计算出最终的结果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于叶子节点（数字），直接返回其值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于操作符节点，首先递归地求值其子表达式，然后将求得的值应用相应的操作符。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;2-表达式树-expression-tree&#34;&gt;2. 表达式树 (Expression Tree)
&lt;/h4&gt;&lt;p&gt;计算器部分会重点讲解如何构建和操作表达式树。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表示：&lt;/strong&gt; 在 Python 中，表达式树通常可以用嵌套的列表或自定义类来表示。例如，&lt;code&gt;(‘+’, 2, (‘*’, 3, 4))&lt;/code&gt; 就可以表示上述表达式树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt; 表达式树清晰地表达了运算符的优先级和表达式的结构，使得求值过程变得直接和递归。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;3-操作符的优先级和结合性&#34;&gt;3. 操作符的优先级和结合性
&lt;/h4&gt;&lt;p&gt;这是解析阶段的关键挑战，决定了表达式树的正确结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优先级 (Precedence)：&lt;/strong&gt; 不同的操作符有不同的优先级（例如，乘法和除法通常高于加法和减法）。解析器必须知道这一点，才能正确地分组操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合性 (Associativity)：&lt;/strong&gt; 当多个相同优先级的操作符连续出现时（例如 &lt;code&gt;2 - 3 - 4&lt;/code&gt; 或 &lt;code&gt;2 / 3 / 4&lt;/code&gt;），结合性决定了它们的计算顺序（左结合或右结合）。例如，大多数算术运算符都是左结合的，&lt;code&gt;2 - 3 - 4&lt;/code&gt; 等同于 &lt;code&gt;(2 - 3) - 4&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;4-抽象数据类型-adt-与接口&#34;&gt;4. 抽象数据类型 (ADT) 与接口
&lt;/h4&gt;&lt;p&gt;尽管可能没有直接提到“ADT”这个词，但计算器部分无疑在实践中运用了 ADT 的思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分离表示与行为：&lt;/strong&gt; 你会学习如何定义操作符、数字等抽象概念的接口，而不是直接操作底层的列表索引或字符串。例如，你可能会有 &lt;code&gt;make_operand(value)&lt;/code&gt;、&lt;code&gt;is_operator(exp)&lt;/code&gt;、&lt;code&gt;operator_name(exp)&lt;/code&gt;、&lt;code&gt;operands(exp)&lt;/code&gt; 等辅助函数来操作表达式树，而不需要知道它底层是用列表还是其他结构实现的。这使得代码更模块化，更易于理解和维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&#34;5-错误处理&#34;&gt;5. 错误处理
&lt;/h4&gt;&lt;p&gt;一个健壮的计算器还需要考虑如何处理无效的输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;语法错误：&lt;/strong&gt; 例如，括号不匹配、非法字符、运算符使用不当。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行时错误：&lt;/strong&gt; 例如，除数为零。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通常会通过抛出自定义的异常来指示这些错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;好的，我们继续深入 CS 61A 第三章关于 Scheme 语言和解释计算机程序的内容。虽然 CS 61A 的重点是&lt;strong&gt;解释器 (Interpreter)&lt;/strong&gt; 而非完整的编译器，但它确实触及了一些与编译相关的概念，尤其是在&lt;strong&gt;语言处理&lt;/strong&gt;和&lt;strong&gt;程序表示&lt;/strong&gt;的层面。&lt;/p&gt;
&lt;h4 id=&#34;5-语言处理的阶段广义上的编译&#34;&gt;5. 语言处理的阶段（广义上的“编译”）
&lt;/h4&gt;&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中间代码生成 (Intermediate Code Generation)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt; 将 AST 转换成一种更接近机器语言但仍独立于具体机器的中间表示（例如，三地址码、字节码）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在 Scheme 中：&lt;/strong&gt; CS 61A 的解释器通常不会显式地生成一个独立的中间代码层。它直接操作 S-表达式（作为 AST 的一种形式）并在求值时即时解释执行。然而，&lt;strong&gt;Scheme 代码本身就可以看作是一种非常高层的“中间代码”&lt;/strong&gt;，因为它结构化且接近程序的逻辑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与编译的关系：&lt;/strong&gt; 这是编译器中一个重要的优化点。中间代码可以进行平台无关的优化，提高代码效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;代码优化 (Code Optimization)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt; 对中间代码进行各种转换，以提高程序的执行效率（更快、更小）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在 Scheme 中：&lt;/strong&gt; CS 61A 的解释器通常不涉及复杂的代码优化。它更侧重于语言的语义和求值过程的理解。但在现实世界的 Scheme 或 Lisp 实现中，优化是非常重要的，例如&lt;strong&gt;尾递归优化 (Tail-Call Optimization, TCO)&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;尾递归优化：&lt;/strong&gt; 这是函数式语言（特别是 Scheme）编译器或高级解释器的一个关键优化点。如果一个函数的所有递归调用都是&lt;strong&gt;尾调用&lt;/strong&gt;（即递归调用是函数的最后一步操作，其返回值直接作为函数的返回值），那么编译器可以将递归调用转换为迭代，避免栈溢出。CS 61A 会详细解释尾递归的概念，以及它如何让递归成为一种强大的、等同于循环的控制结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与编译的关系：&lt;/strong&gt; 编译器在此阶段尝试使生成的机器代码更高效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;目标代码生成 (Target Code Generation)：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt; 将中间代码翻译成特定目标机器（CPU）的机器码或汇编代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;在 Scheme 中：&lt;/strong&gt; CS 61A 中的解释器直接在运行时求值 S-表达式，不生成机器码。它本身就是用 Python 或 Scheme 实现的“软件 CPU”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;与编译的关系：&lt;/strong&gt; 这是编译过程的最终阶段，生成可直接执行的二进制文件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总结编译相关内容&#34;&gt;总结编译相关内容
&lt;/h3&gt;&lt;p&gt;尽管 CS 61A 的第三章主要教授的是&lt;strong&gt;解释器的工作原理&lt;/strong&gt;，但它通过 Scheme 的 S-表达式形式、环境模型和求值过程，隐式地触及了编译理论中的几个关键概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;程序表示：&lt;/strong&gt; Scheme 的 S-表达式是程序的一种&lt;strong&gt;结构化表示&lt;/strong&gt;，类似于编译器内部的 AST。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;语义检查：&lt;/strong&gt; 变量查找、类型匹配等在求值时进行，这与编译器的语义分析阶段类似。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;求值策略：&lt;/strong&gt; 对于普通组合式和特殊形式的不同求值规则，是所有语言处理的关键。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;尾递归优化：&lt;/strong&gt; 虽然解释器可能不一定实现所有优化，但尾递归的概念是函数式语言的重要特性，它模糊了编译优化和语言语义之间的界限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;macros&#34;&gt;Macros
&lt;/h3&gt;&lt;p&gt;实际上，函数和类的定义通过添加命令和数据类型来拓展语言，但语言没办法定义新的控制结构。
许多语言提供了宏。宏可以允许你来去定义一个能够生成程序文本的函数。实际上，调用一个宏函数就是将一段程序文本中的变量进行替换了。
C的宏不作为程序语言的一部分，而是由预处理器来提供的。而Scheme中的宏是语言的一部分，Scheme中，宏不进行参数计算，自动的将返回值作为Scheme表达式并且执行它。Scheme中有一个语法是Quasiquote，能够使列表表达像python中的f字符串。
宏可以帮助实现：如果想要定义一个新的Scheme表达式，以unless开头，能和if来做同样的事情。
宏做的事情，不像函数那样替换值，而是替换变量名。但是宏实际上是一个非常危险的东西，很多情况会出现你无法预料到的结果，小心使用。&lt;/p&gt;
&lt;h3 id=&#34;声明式编程&#34;&gt;声明式编程
&lt;/h3&gt;&lt;p&gt;过去接触到的大部分是命令式编程，命令计算机去做什么，而声明式编程是描述结果的特点，把它交给系统去搞清楚怎么去得到结果。核心思想是：&lt;strong&gt;你告诉计算机“要实现什么” (what to do)，而不是“如何实现” (how to do it)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;使用许多基本语句，这些语句是一些基本的逻辑性断言，这些断言指定想要的目标。这些逻辑断言组成了一个断言数据库，说白了就是一个知识库，我们问程序，基于程序现有的知识能否证明一个新的断言是否为真。&lt;/p&gt;
&lt;h4 id=&#34;正则表达式&#34;&gt;正则表达式
&lt;/h4&gt;&lt;p&gt;正则表达式是一种声明式编程，处理文本时，可能存在一些特定的模式，根据这些模式来做些什么，比如说找到所有的整数，这时就要进行模式匹配，声明一个模式，让系统去进行匹配。正则表达式说的是，所有匹配正则表达式的字符串的集合。
python有一个库来处理正则表达式，&lt;code&gt;import re&lt;/code&gt;，这个库中提供了非常多的方法来处理正则表达式，可以有创造性的来组合。详细参考文档：
&lt;a class=&#34;link&#34; href=&#34;https://docs.python.org/zh-cn/3/howto/regex.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;正则表达式指南 — Python 3.13.6 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里记录一下贪婪匹配和惰性匹配，python默认选择贪婪匹配，尽量匹配多的，有时候，我们不希望匹配尽可能多的，希望匹配的越少越好，可以使用惰性模式操作符，&lt;code&gt;*?&lt;/code&gt;,&lt;code&gt;*+&lt;/code&gt;,&lt;code&gt;??&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;backus-naur-formbnf&#34;&gt;Backus-Naur-Form(BNF)
&lt;/h4&gt;&lt;p&gt;BNF（Backus-Naur Form），中文常译作巴科斯-诺尔范式，是一种元语言符号，主要用于描述计算机语言的语法结构，特别是上下文无关文法（Context-Free Grammar）。它提供了一种精确、形式化且无歧义的方式来定义语言的语法规则。&lt;/p&gt;
&lt;p&gt;BNF的核心概念包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;终结符（Terminals）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些是语言中最基本的、不可再分割的符号或词汇，它们是语言的“原子”。&lt;/li&gt;
&lt;li&gt;例如，在编程语言中，关键字（如&lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;）、运算符（如&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;）、标点符号（如&lt;code&gt;;&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;)&lt;/code&gt;）以及具体的标识符（如变量名&lt;code&gt;x&lt;/code&gt;、数字&lt;code&gt;123&lt;/code&gt;）都属于终结符。&lt;/li&gt;
&lt;li&gt;在BNF表示中，终结符通常用双引号&lt;code&gt;&amp;quot;&lt;/code&gt;括起来，或者直接写出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;非终结符（Non-terminals）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些是表示语法范畴或语法结构的抽象符号。它们本身不是语言中的实际组成部分，但代表了可以由其他符号（终结符或非终结符）序列替换的“占位符”。&lt;/li&gt;
&lt;li&gt;非终结符通常用尖括号&lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt;括起来，例如&lt;code&gt;&amp;lt;expression&amp;gt;&lt;/code&gt;（表达式）、&lt;code&gt;&amp;lt;statement&amp;gt;&lt;/code&gt;（语句）、&lt;code&gt;&amp;lt;digit&amp;gt;&lt;/code&gt;（数字）等。&lt;/li&gt;
&lt;li&gt;每个非终结符都会有一个或多个生产规则来定义它可能由什么构成。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生产规则（Production Rules）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这是BNF的核心。一个生产规则定义了一个非终结符可以被替换或“展开”成什么样的符号序列。&lt;/li&gt;
&lt;li&gt;规则的一般形式是：&lt;code&gt;&amp;lt;非终结符&amp;gt; ::= 定义&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;::=&lt;/code&gt; 符号表示“被定义为”或“可以由……替换”。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;选择（Alternatives）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;管道符 &lt;code&gt;|&lt;/code&gt; 用于分隔一个非终结符的多种可能定义。这意味着该非终结符可以被定义为管道符左边的一种形式，也可以是右边的一种形式。&lt;/li&gt;
&lt;li&gt;例如：&lt;code&gt;&amp;lt;digit&amp;gt; ::= &amp;quot;0&amp;quot; | &amp;quot;1&amp;quot; | &amp;quot;2&amp;quot; | &amp;quot;3&amp;quot; | &amp;quot;4&amp;quot; | &amp;quot;5&amp;quot; | &amp;quot;6&amp;quot; | &amp;quot;7&amp;quot; | &amp;quot;8&amp;quot; | &amp;quot;9&amp;quot;&lt;/code&gt; 表示一个&lt;code&gt;&amp;lt;digit&amp;gt;&lt;/code&gt;可以是&lt;code&gt;&amp;quot;0&amp;quot;&lt;/code&gt;，也可以是&lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt;，以此类推。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;连接（Concatenation）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在定义中，将符号（终结符或非终结符）并列写在一起表示它们按顺序连接。&lt;/li&gt;
&lt;li&gt;例如：&lt;code&gt;&amp;lt;number&amp;gt; ::= &amp;lt;digit&amp;gt;&amp;lt;number&amp;gt; | &amp;lt;digit&amp;gt;&lt;/code&gt;，这里的&lt;code&gt;&amp;lt;digit&amp;gt;&amp;lt;number&amp;gt;&lt;/code&gt;表示一个数字后面跟着另一个数字序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;BNF的简单例子：一个整数的定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们想用BNF定义一个简单的整数，它由一个或多个数字组成。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bnf&#34; data-lang=&#34;bnf&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;digit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; | &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;digit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;digit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;::=&lt;/span&gt; &amp;#34;0&amp;#34; | &amp;#34;1&amp;#34; | &amp;#34;2&amp;#34; | &amp;#34;3&amp;#34; | &amp;#34;4&amp;#34; | &amp;#34;5&amp;#34; | &amp;#34;6&amp;#34; | &amp;#34;7&amp;#34; | &amp;#34;8&amp;#34; | &amp;#34;9&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;解释：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;digit&amp;gt;&lt;/code&gt;是一个非终结符，定义它是一个具体的0到9的数字字符（这些是终结符）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;是一个非终结符，它有两种可能的定义：
&lt;ul&gt;
&lt;li&gt;它可以仅仅是一个&lt;code&gt;&amp;lt;digit&amp;gt;&lt;/code&gt;（例如&lt;code&gt;&amp;quot;5&amp;quot;&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;它可以是一个&lt;code&gt;&amp;lt;digit&amp;gt;&lt;/code&gt;后面跟着另一个&lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;（例如&lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt;后面跟着&lt;code&gt;&amp;quot;23&amp;quot;&lt;/code&gt;，构成&lt;code&gt;&amp;quot;123&amp;quot;&lt;/code&gt;）。这种递归的定义方式使得我们可以表示任意长度的整数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BNF的应用：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;编程语言设计和规范：&lt;/strong&gt; BNF是描述编程语言（如Java、C++、Python等）语法的标准方法。它的形式化描述有助于消除歧义，并作为语言实现的蓝图。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编译器和解释器：&lt;/strong&gt; 编译器和解释器的语法分析器（Parser）就是基于语言的BNF（或EBNF）规则来构建的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;协议和数据格式：&lt;/strong&gt; 常用于描述网络协议、文件格式或数据交换格式的结构。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;文档：&lt;/strong&gt; 作为语言或系统精确的语法参考文档。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BNF与EBNF（Extended Backus-Naur Form）的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EBNF 是 BNF 的扩展，引入了一些更简洁的符号来表示常见的语法模式，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[]&lt;/code&gt;：表示可选元素（出现0次或1次）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{}&lt;/code&gt;：表示重复元素（出现0次或多次）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;()&lt;/code&gt;：用于分组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EBNF 使得语法定义更加紧凑和易读，但在表达能力上与 BNF 是等价的。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
