[{"content":" 在我看来比较好的理解方式是，先通过阅读代码理解整体和细节，再看算法和论文会更好。\n注意：有什么代码设计逻辑上解决不了的问题，尝试抽象出一个中间层或者控制器类型的东西看看能不能解决\n记录一下毕设\n环境配置 在工程目录下创建conda虚拟环境： 使用 --prefix，环境会被创建在你指定的精确路径（这里是项目文件夹下的 env 子目录）\n1 2 3 4 5 6 7 8 9 10 # 推荐：直接在工程文件夹内创建环境，当前已经处于工程目录下 conda create --prefix ./env python=3.9 conda activate ./env # 导出环境配置（方便共享）： conda env export \u0026gt; environment.yml # 从 YAML 文件创建环境： conda env create -f environment.yml 随着项目增多，每个项目都创建独立的 Conda 环境确实会占用大量磁盘空间，小型数据分析项目可共用一个环境，核心项目使用单独环境。\n通过克隆基础环境减少重复安装：\n1 2 3 4 5 6 7 # 创建基础环境 conda create --name base_py39 python=3.9 # 克隆出项目专用环境（共享基础包） conda create --name projectA --clone base_py39 conda activate projectA conda install packageA # 仅安装项目特有包 注意：--name是创建全局环境的，而--prefix是项目内环境的，不需要名字。\nPyTorch库结构 由于每次用PyTorch导入，不知道应该导入哪一个是什么功能，记录以下PyTorch库的结构。\n1. 核心模块 torch: 这是 PyTorch 的核心包，提供了所有基本的数据结构（如张量）和张量操作。 torch.Tensor: PyTorch 中最基本的数据结构，类似于 NumPy 的 ndarray，但支持 GPU 加速和自动微分。 torch.autograd: 实现了自动微分系统。当你对张量执行操作时，PyTorch 会构建一个计算图。autograd 利用这个图来自动计算梯度。 torch.autograd.Function: 用户可以自定义操作并提供其前向和反向传播的实现。 torch.nn: 这是构建神经网络的核心模块。它提供了各种预定义的层（如 Linear, Conv2d, ReLU 等）、损失函数（如 MSELoss, CrossEntropyLoss 等）和模型容器（如 Module, Sequential）。 torch.nn.Module: 所有神经网络模块的基类。你的自定义模型都应该继承自它。 torch.nn.functional: 包含了函数式的神经网络操作，这些操作没有自己的可学习参数（例如 F.relu, F.softmax）。 torch.optim: 包含了各种优化算法（如 SGD, Adam, RMSprop 等），用于更新模型的参数。 torch.optim.Optimizer: 所有优化器的基类。 torch.cuda: 提供了 CUDA 支持，允许你在 NVIDIA GPU 上进行张量操作和模型训练。 torch.cuda.is_available(): 检查 CUDA 是否可用。 torch.cuda.empty_cache(): 清空 CUDA 缓存。 torch.linalg: 提供了线性代数操作，例如矩阵乘法、分解、特征值计算等。 torch.jit: 提供了 JIT (Just-In-Time) 编译器，可以将 PyTorch 模型转换为可序列化的、优化的表示，用于推理部署。 torch.jit.script: 将 Python 代码转换为 TorchScript。 torch.jit.trace: 通过执行示例输入来记录模型的计算图。 2. 实用工具和领域特定库 torch.utils: 提供了各种实用工具。 torch.utils.data: 数据加载和处理工具。 torch.utils.data.Dataset: 用于封装数据样本及其标签的抽象类。 torch.utils.data.DataLoader: 迭代数据集并提供批量数据加载、并行加载和数据混洗等功能。 torch.utils.tensorboard: 集成了 TensorBoard，用于可视化训练过程。 torch.utils.bottleneck: 用于性能分析和调试。 torchvision: PyTorch 官方提供的计算机视觉库。 torchvision.datasets: 包含常用视觉数据集（如 ImageNet, CIFAR10, MNIST）。 torchvision.models: 包含预训练的计算机视觉模型（如 ResNet, VGG, AlexNet）。 torchvision.transforms: 图像预处理和数据增强变换。 torchvision.utils: 图像保存、网格显示等实用工具。 torchaudio: PyTorch 官方提供的音频处理库。 包含音频数据集、模型和转换工具。 torchtext: PyTorch 官方提供的自然语言处理 (NLP) 库。 包含文本数据集、词汇表、词嵌入和常用的 NLP 模型。 torch_geometric: (第三方库，但非常流行) 用于图神经网络 (GNN)。 torch_scatter: (第三方库，但非常流行) 提供散列操作，常与 torch_geometric 配合使用。 torchmetrics: (第三方库，但非常流行) 提供各种机器学习指标的实现。 3. 分布式训练 torch.distributed: 用于多 GPU 或多节点分布式训练。 torch.distributed.init_process_group: 初始化分布式环境。 torch.distributed.all_reduce, torch.distributed.broadcast: 实现张量在不同进程间的通信。 torch.nn.parallel: 提供一些简单的并行化策略。 torch.nn.DataParallel: 单机多 GPU 数据并行。 torch.nn.parallel.DistributedDataParallel (DDP): 推荐的多 GPU/多节点并行化方法，更高效、更灵活。 4. 混合精度训练 torch.amp: (Automatic Mixed Precision) 用于自动混合精度训练，利用 FP16 和 FP32 混合计算，以加速训练和减少内存消耗。 torch.amp.autocast: 自动进行类型转换的上下文管理器。 torch.cuda.amp.GradScaler: 用于解决混合精度训练中梯度过小的问题。 5. 高级特性和生态系统 torch.compile (PyTorch 2.0+): 引入的编译功能，可以显著提升模型训练和推理的速度，通过将 PyTorch 代码编译成优化的图表示。 TorchScript: PyTorch 的中间表示 (IR)，允许你将模型从 Python 转换为一个可独立运行的图表示，方便部署到 C++ 或移动设备。 ONNX (Open Neural Network Exchange): PyTorch 可以方便地导出模型到 ONNX 格式，这是一种开放标准，允许在不同深度学习框架之间进行模型互操作。 PyTorch Lightning: 一个轻量级的 PyTorch 封装，提供了一个高级接口，用于管理训练循环、分布式训练、日志记录等，从而减少样板代码。 Hugging Face Transformers: 虽然不是 PyTorch 核心库的一部分，但它是 PyTorch 生态系统的重要组成部分，提供了大量预训练的 NLP 模型和工具。 整体架构 主要说来，程序主要由两个部分组成：\n神经网络和MCTS组成的算法 根据象棋规则来生成动作 主要算法 主要算法就是AlphaGo Zero提出的算法。AlphaZero 的自我对弈（Self-Play）更新机制是其核心创新之一，它使得 AlphaZero 能够从零开始，在没有人类专家数据的情况下，学习并超越人类顶尖棋手的水平。这个机制是强化学习的一个典范。\n主要流程为以下几个步骤：\n神经网络初始化 训练开始时，神经网络的参数是随机初始化的 神经网络双分支输出，一个策略(policy)输出$p$，一个价值(value)输出$v$ 策略（Policy）输出 p： 预测在当前状态下，每个合法走法的概率分布。 价值（Value）输出 v： 预测当前状态下，当前玩家最终获胜的概率（或预期回报）。 自我对弈生成训练数据： 在每轮自我对弈中，程序会利用当前的神经网络来指导蒙特卡洛树搜索（MCTS）进行决策，并生成一盘完整的对局。 蒙特卡洛树搜索（MCTS）的迭代过程： 选择（Selection）： 从根节点（当前局面）开始，根据 MCTS 的 UCB（Upper Confidence Bound）或 PUCB（Polynomial Upper Confidence Bound）公式（结合了神经网络的先验概率 p 和访问次数 N）选择一条路径，直到达到一个未完全扩展的节点。 扩展（Expansion）： 如果到达的节点不是一个终止局面，就使用神经网络对该节点进行一次评估，得到该局面的策略 p 和价值 v。同时，将这个新节点及其子节点添加到搜索树中。 模拟（Simulation，在AlphaZero中通常省略或简化）： 但在AlphaZero中，神经网络的价值输出 v 直接取代了随机模拟，提供了更准确的估计。 反向传播（Backpropagation）： 将神经网络评估得到的价值 v 以及对局的最终结果（胜利或失败，通常为 +1 或 -1）沿着选择路径向上回传，更新路径上所有节点的访问次数 N、总价值 Q 和平均价值 W。 生成走法策略 π： 在 MCTS 进行了一定数量的模拟（例如800次）后，不再直接使用神经网络的策略输出 p 来选择走法。而是根据 MCTS 树中每个走法的访问次数 N(s,a) 来生成一个更强大的走法策略 π，通常是按访问次数的幂次方（如 N(s,a)1/t，其中 t 是一个温度参数，用于控制探索与利用的平衡）进行归一化。访问次数越多的走法，表明 MCTS 认为该走法越有潜力。 收集训练样本： 每一步棋的 (状态 $s_t$​, MCTS 策略 $π_t$​, 最终胜负 z) 作为一个训练样本被收集起来。其中 $s_t$​ 是当前局面，$π_t$​ 是由 MCTS 产生的走法概率分布， z 是最终游戏结果（胜利为 +1，失败为 -1，和棋为 0）。 神经网络训练： 收集到足够的数据就能展开训练了，就是深度学习中最小化损失函数的过程。 模型更新与迭代： 每次训练我们希望得到的是新的强化过程，也就是比之前更强的模型。训练好的新神经网络会与旧的神经网络进行评估。如果新网络表现更好（通常通过在竞技场中进行对局来判断，胜率高过一个阈值就更新），它就会取代旧网络，成为下一轮自我对弈生成数据的基准模型。 这个过程持续迭代：自我对弈生成数据 -\u0026gt; 训练更新神经网络 -\u0026gt; 评估新旧模型 -\u0026gt; 替换模型。 杂项 清零梯度 我们对一个批次训练时每次都要清零梯度。原因是PyTorch 的设计理念是，默认情况下，梯度是累积的（accumulated）。这意味着当你调用 loss.backward() 时，新计算出的梯度会加到张量（torch.Tensor）的 .grad 属性中（如果该张量是模型的可学习参数）。 举个例子：\n第一次 loss.backward()：计算并生成梯度 G1​，将其存储在参数的 .grad 属性中。此时，param.grad 等于 G1​。 第二次 loss.backward()：计算并生成梯度 G2​。如果此时不清零，PyTorch 会将 G2​ 加到现有的 param.grad 上。所以，param.grad 会变成 G1​+G2​。 唯一例外：梯度累积（Gradient Accumulation） 梯度积累技术是唯一一个有意不清零梯度的场景。在这种情况下，我们确实需要将多个小批次的梯度累加起来，以模拟更大的有效批量大小。但即使在这种情况下，当累积到一定步数并执行 optimizer.step() 后，我们仍然会调用 optimizer.zero_grad() 来清零，为下一轮的梯度积累做准备。\nPyTorch训练一个批次的流程 每个批次的训练步骤：\n设置模型为训练模式: model.train() (非常重要，影响 Dropout 和 BatchNorm 的行为)。 获取输入和目标: 从数据加载器中获取一个批次的输入数据和对应的真实标签。 设备转移: 将数据移动到与模型相同的设备上 (CPU 或 GPU)：inputs, labels = inputs.to(device), labels.to(device) 清零梯度: optimizer.zero_grad()。在每次迭代前，清除上次计算的梯度，因为 PyTorch 默认会累积梯度。 前向传播 (Forward Pass): 将输入数据输入模型，获得模型的预测输出。 outputs = model(inputs) 计算损失 (Calculate Loss): 将模型的输出与真实标签输入损失函数，计算当前的损失值。 loss = criterion(outputs, labels) 反向传播 (Backward Pass): loss.backward()。根据损失值，自动计算所有可学习参数的梯度。 参数更新 (Optimizer Step): optimizer.step()。使用计算出的梯度来更新模型的参数。 （可选）学习率调度: scheduler.step() (如果使用了学习率调度器)。 detach分离计算图 detach() 是 PyTorch 中 torch.Tensor 对象的一个方法，它的核心作用是将一个张量从当前的计算图中分离出来，使其不再跟踪梯度。\n停止跟踪梯度（Stop Tracking Gradients）：\n被 detach() 后的张量，其 requires_grad 属性会变为 False。 即使原始张量 x 的 requires_grad 是 True，x.detach() 得到的张量 y 的 requires_grad 也会是 False。 当对 y 进行后续操作时，这些操作将不再被记录到计算图中，也不会为 y 或其后续操作的张量计算梯度。 共享底层存储（Share Underlying Storage）：\ndetach() 返回的张量与原始张量共享相同的底层数据存储。 这意味着，如果你修改了其中一个张量的数据（例如，通过 y.add_(1) 进行原地操作），那么另一个张量的数据也会相应改变。 但是，这种数据共享是单向的：对分离出的张量 y 的任何会导致其值改变的操作（如 y.add_(1)），虽然会修改原始张量 x 的值，但不会在 x 的计算图中记录这个操作。PyTorch 会在反向传播时检测到这种“原地修改”并报错，因为它无法正确地计算梯度。 防止不必要的梯度计算和内存开销：\n在某些情况下，你可能需要使用某个张量的值进行计算，但你并不希望这个计算过程被记录到计算图中，也不希望为这个张量计算梯度。 例如，在训练循环中，如果你想记录损失值但不希望损失值的计算过程影响到模型参数的梯度计算，你可以 loss.detach().item()。 另一个例子是，当某个中间结果在后续计算中不需要通过反向传播来更新其上游参数时。 多进程 由于自我对弈是CPU上计算的，显然可以采用多线程或者多进程。但由于Python存在GIL锁的机制，无法真正实现多线程。全局解释器锁（GIL, Global Interpreter Lock）是 Python（尤其是 CPython 解释器）中的一个机制。它的作用是同一时刻只允许一个线程执行 Python 字节码，即使你在多核 CPU 上开启了多个线程，实际上同一时刻只有一个线程在执行 Python 代码。\n任何线程在执行 Python 代码前，必须先获得 GIL。 这意味着即使你创建了多个线程，这些线程也不能真正并行地执行 Python 代码（C 扩展库释放 GIL 时除外）。 所以Python的多线程适用于I/O密集型任务：\nI/O 密集型任务（如网络请求、文件读写、数据库操作等）大部分时间都在等待外部资源响应，而不是消耗 CPU。 当线程遇到 I/O 操作时，GIL 会被释放，其他线程可以获得 GIL 并继续执行。 这样，多线程可以在等待 I/O 的间隙切换执行，提高程序整体的资源利用率和吞吐量。 典型场景：爬虫、网络服务器、日志处理等。 而对于本任务是计算密集型的，不适合使用多线程，采用多进程：\nmultiprocessing 模块通过创建多个独立的 Python 进程，每个进程都有自己的 Python 解释器和内存空间，各自拥有独立的 GIL。 这样可以实现真正的多核并行运算，充分利用多核 CPU 的计算能力。 适合 CPU 密集型任务，如自我对弈、神经网络推理、数据处理等。 如果是多线程，线程与线程之间属于同一个进程的话，是同属一个内存空间的，共享全局变量和内存。而如果是多进程，进程间内存独立，数据不能直接共享，需要用队列、管道、共享内存等方式通信，开销较大。\n日志模块 logging 模块采用模块化设计，主要包含以下四类组件：\nLogger (记录器): 这是应用程序代码直接使用的接口。你可以通过 logging.getLogger(name) 来获取一个 Logger 实例。name 参数是可选的，如果提供，则会创建一个具名的 Logger；如果不提供，则会返回根 Logger (root logger)。Logger 有不同的日志级别，只有级别高于或等于 Logger 设定阈值的日志消息才会被处理。\nHandler (处理器): 处理器负责将 Logger 创建的日志记录（LogRecord）发送到适当的目标。常见的 Handler 有：\nStreamHandler: 将日志输出到控制台（标准输出或标准错误）。 FileHandler: 将日志输出到文件。 RotatingFileHandler: 类似于 FileHandler，但会在文件达到一定大小时自动轮转（创建新的日志文件）。 TimedRotatingFileHandler: 类似于 RotatingFileHandler，但会根据时间（例如每天、每周）进行日志轮转。 SMTPHandler: 将日志通过电子邮件发送。 HTTPHandler: 将日志通过 HTTP GET 或 POST 请求发送到 Web 服务器。 Formatter (格式化器): 格式化器指定最终输出中日志记录的样式。你可以定义日志消息的格式，包括时间、文件名、行号、日志级别、消息内容等。\nFilter (过滤器): 过滤器提供了更细粒度的控制，用于决定哪些日志记录应该被输出。你可以在 Logger 或 Handler 上添加过滤器，以进一步筛选日志。\n日志级别 (Logging Levels) logging 模块定义了以下标准日志级别（从低到高）：\nDEBUG (10): 详细的调试信息，通常只在开发阶段使用。 INFO (20): 确认程序按预期工作。 WARNING (30): 表示发生了一些意外事件，或将来可能会出现问题（但程序仍在正常运行）。这是默认的级别。 ERROR (40): 表示由于严重问题，程序无法执行某些功能。 CRITICAL (50): 表示发生了非常严重的错误，程序可能无法继续运行。 层级结构 Logger 的层级结构 (Hierarchical Loggers): 当你使用 logging.getLogger(__name__) 时，__name__ 会是模块的完全限定名。例如，main.py 中的 Logger 名称是 'main'，module_a.py 中的 Logger 名称是 'module_a'，my_package.sub_module 中的 Logger 名称是 'my_package.sub_module'。 logging 模块有一个层级结构，Logger 会将其日志消息传递（“传播”）给它们的父 Logger，直到根 Logger。根 Logger 是所有 Logger 的祖先。 在 main.py 中，我们配置了根 Logger。因此，module_a 和 module_b 中 Logger 发出的日志消息会向上冒泡到根 Logger，然后被根 Logger 的 Handler 处理，最终输出到控制台和文件。\nlogging 模块的 Logger 形成一个树状的层级结构。这种层级结构是通过 Logger 名称中的点号（.）来表示的。\n根 Logger (Root Logger):\nlogging.getLogger()（不带任何参数）返回的是根 Logger。它是所有其他 Logger 的祖先。 它的名称是一个空字符串 ''。 具名 Logger (Named Loggers):\n当你调用 logging.getLogger('some_name') 时，你获取的是一个具名 Logger。 如果 Logger 的名称包含点号，那么点号前面的部分就是它的父 Logger 的名称。 父子关系的确定规则：\n名称是前缀： 如果一个 Logger 的名称是另一个 Logger 名称的点分隔前缀，那么前者就是后者的父 Logger。\n例如：Logger 'a.b' 的父 Logger 是 'a'。Logger 'a' 的父 Logger 是根 Logger ''。 根 Logger 是所有 Logger 的祖先： 所有的具名 Logger 最终都追溯到根 Logger。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import logging # 1. 根 Logger root_logger = logging.getLogger() # 名称是 \u0026#39;\u0026#39; # 2. 具名 Logger \u0026#39;app\u0026#39; app_logger = logging.getLogger(\u0026#39;app\u0026#39;) # 3. 具名 Logger \u0026#39;app.module_a\u0026#39; module_a_logger = logging.getLogger(\u0026#39;app.module_a\u0026#39;) # 4. 具名 Logger \u0026#39;app.module_b\u0026#39; module_b_logger = logging.getLogger(\u0026#39;app.module_b\u0026#39;) # 5. 具名 Logger \u0026#39;app.module_a.sub_module\u0026#39; sub_module_logger = logging.getLogger(\u0026#39;app.module_a.sub_module\u0026#39;) 它们之间的父子关系如下：\nroot_logger (名称 '') 是所有 Logger 的父 Logger。 app_logger (名称 'app') 的父 Logger 是 root_logger。 module_a_logger (名称 'app.module_a') 的父 Logger 是 app_logger。 module_b_logger (名称 'app.module_b') 的父 Logger 是 app_logger。 sub_module_logger (名称 'app.module_a.sub_module') 的父 Logger 是 module_a_logger。 要点：\n日志传播 (Propagation): 默认情况下，子 Logger 会将它收到的日志消息传递给它的父 Logger，这个过程会一直持续到根 Logger。根 Logger 会将这些日志消息传递给它所关联的所有 Handler 进行实际的输出。 __name__ 的作用： 在模块文件中使用 logging.getLogger(__name__) 是一个最佳实践。__name__ 会自动设置为当前模块的完全限定名（例如，如果文件是 my_package/my_module.py，那么 __name__ 就是 'my_package.my_module'）。这使得日志的层级结构自然地与你的代码模块结构对应起来，便于管理和追踪日志来源。 记录一个BUG 报错信息是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 Traceback (most recent call last): File \u0026#34;D:\\PycharmProjects\\AlphaZero\\main.py\u0026#34;, line 66, in \u0026lt;module\u0026gt; train_p.start() File \u0026#34;D:\\app\\anaconda3\\Lib\\multiprocessing\\process.py\u0026#34;, line 121, in start self._popen = self._Popen(self) ^^^^^^^^^^^^^^^^^ File \u0026#34;D:\\app\\anaconda3\\Lib\\multiprocessing\\context.py\u0026#34;, line 224, in _Popen return _default_context.get_context().Process._Popen(process_obj) ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ File \u0026#34;D:\\app\\anaconda3\\Lib\\multiprocessing\\context.py\u0026#34;, line 337, in _Popen return Popen(process_obj) ^^^^^^^^^^^^^^^^^^ File \u0026#34;D:\\app\\anaconda3\\Lib\\multiprocessing\\popen_spawn_win32.py\u0026#34;, line 95, in __init__ reduction.dump(process_obj, to_child) File \u0026#34;D:\\app\\anaconda3\\Lib\\multiprocessing\\reduction.py\u0026#34;, line 60, in dump ForkingPickler(file, protocol).dump(obj) TypeError: cannot pickle \u0026#39;_thread.RLock\u0026#39; object Exception in thread Thread-1 (_monitor): Traceback (most recent call last): File \u0026#34;D:\\app\\anaconda3\\Lib\\multiprocessing\\connection.py\u0026#34;, line 328, in _recv_bytes 关键在于TypeError: cannot pickle '_thread.RLock' object Exception in thread Thread-1 (_monitor):。这个错误发生在 multiprocessing 模块尝试序列化 (pickle) 对象以在进程间传递时。\n错误的根本原因： multiprocessing 模块在 Windows 系统上默认使用 \u0026ldquo;spawn\u0026rdquo; 启动方式。当它启动一个新进程时，它需要将父进程中的一些对象序列化（使用 pickle 模块）并传递给子进程。\n_thread.RLock 是一个递归锁 (Reentrant Lock) 对象，它通常用于线程同步。RLock 对象是不能被 pickle 化的。 这意味着你不能直接将一个包含 RLock 对象的 Logger 或 Handler 实例传递给子进程。\n在 Windows 系统上，multiprocessing 模块默认使用 \u0026ldquo;spawn\u0026rdquo; 或 \u0026ldquo;forkserver\u0026rdquo; 启动方法（而不是 Unix 上的 \u0026ldquo;fork\u0026rdquo;）。\nspawn (Windows 默认，macOS 也建议使用): 子进程是通过导入父进程模块来启动的。这意味着当一个子进程启动时，它会重新执行父进程模块中的所有代码。 fork (Unix/Linux 默认): 子进程是父进程的副本，它会继承父进程的所有内存空间和打开的文件描述符。 如果在 if __name__ == \u0026quot;__main__\u0026quot;: 块之外定义了像 FileHandler 或 StreamHandler 这样的对象，那么当子进程重新导入模块时，它们也会被重新创建。这些 Handler 内部可能包含 RLock 或其他不可 pickle 的对象，导致 TypeError: cannot pickle '_thread.RLock' object。\n我在 TrainPipeline 类的 __init__ 方法中直接实例化了 logging.handlers.QueueHandler 并将其添加到了 self.root Logger。当主进程启动一个子进程时，它需要将子进程要执行的 target 函数以及 args 中传递的所有对象进行序列化 (pickle)，然后传递给新进程。\n1 2 training_pipeline = train.TrainPipeline(init_model=\u0026#39;current_policy.pkl\u0026#39;, log_queue=log_queue) train_p = Process(target=training_pipeline.run, args=(lock,)) # \u0026lt;--- 问题在这！ 原因分析：\ntraining_pipeline = train.TrainPipeline(...)： 这一行代码在 主进程 的 if __name__ == '__main__': 块内执行。这意味着 TrainPipeline 的一个实例 training_pipeline 在主进程中被创建了。\nTrainPipeline 的 __init__ 方法： 在 TrainPipeline 的 __init__ 方法中，有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 self.root = logging.getLogger() self.root.setLevel(logging.DEBUG) self.qh = logging.handlers.QueueHandler(log_queue) self.root.addHandler(self.qh) self.worker_logger = logging.getLogger(__name__) ``` 当 `training_pipeline` 在主进程中被实例化时，`self.root` 获取的是主进程的根 Logger。虽然 `QueueHandler` 本身可以被 pickle，但 `logging.getLogger()` 获取的 `Logger` 对象（尤其是根 Logger）及其内部状态（包括可能关联的 `Manager` 对象），在某些情况下可能包含**不可 pickle 的内部锁对象**（例如 `_thread.RLock`）。 3. **`target=training_pipeline.run`：** 当将一个**实例方法**（`training_pipeline.run`）作为 `Process` 的 `target` 时，`multiprocessing` 模块会隐式地尝试序列化 `training_pipeline` 这个**实例本身**，以便在子进程中重新构建它并调用其 `run` 方法。如果 `TrainPipeline` 实例本身被当作参数传递给 `Process`，或者 `run` 方法被当作 `target` 且 `self` 隐式传递，那么 `TrainPipeline` 实例及其所有属性（包括 `self.root` 和 `self.qh`）都将被尝试 pickle。 - 由于 `training_pipeline` 实例在主进程中创建时，其属性（如 `self.root` 和 `self.qh`）已经关联了主进程的日志系统内部对象（可能包含 `RLock`），因此在尝试序列化 `training_pipeline` 实例时，就会遇到 `TypeError: cannot pickle \u0026#39;_thread.RLock\u0026#39; object` #### 解决方案 核心思想是：**所有涉及到进程间通信（如 `QueueHandler` 和 `QueueListener`）的日志配置，以及那些会在子进程中运行的类实例的创建，都应该在**子进程的上下文**中完成。** 1. **创建包装函数作为 `Process` 的 `target`：** 而不是直接将 `training_pipeline.run` 作为 `target`，而是创建一个新的函数，这个函数将作为 `Process` 的 `target`。在这个新函数内部，再实例化 `TrainPipeline` 和 `CollectPipeline`，并调用它们的 `run` 方法。 2. **将 `log_queue` 作为参数传递：** 确保 `log_queue` 被正确地作为参数传递给子进程的 `target` 函数，以便子进程能够使用它来配置自己的 `QueueHandler`。 ```python # 为训练进程定义一个包装函数 # main.py # 为训练进程定义一个包装函数 def run_train_pipeline_in_process(log_queue, init_model_path, shared_lock): \u0026#34;\u0026#34;\u0026#34; 此函数将在一个单独的进程中运行。 TrainPipeline 的实例化及其日志配置在此进程内部完成。 \u0026#34;\u0026#34;\u0026#34; # 在子进程中实例化 TrainPipeline train_pipeline = train.TrainPipeline(log_queue=log_queue, init_model=init_model_path) # 调用 TrainPipeline 的 run 方法，并传入共享锁 train_pipeline.run(shared_lock) # 为数据收集进程定义一个包装函数 def run_collect_pipeline_in_process(process_id, init_model_path, shared_lock, log_queue): \u0026#34;\u0026#34;\u0026#34; 此函数将在一个单独的进程中运行。 CollectPipeline 的实例化及其日志配置在此进程内部完成。 \u0026#34;\u0026#34;\u0026#34; # collect.CollectPipeline 的 __init__ 方法可能也需要 log_queue # 如果 collect.py 也有自己的日志配置，它也应该像 train.py 一样接收 log_queue # 这里假设 collect.py 也会使用 QueueHandler，所以需要传入 log_queue # 注意：你需要修改 collect.py 的 CollectPipeline.__init__ 以接受 log_queue collecting_pipeline = collect.CollectPipeline(process_id, init_model=init_model_path, log_queue=log_queue) collecting_pipeline.run(shared_lock) PyQt5 PyQt5 基本概念 QApplication: 每个 PyQt5 应用程序都需要一个 QApplication 对象。它负责处理事件循环、命令行参数解析等。 QWidget: 所有用户界面对象的基类。它可以是窗口、按钮、标签等。 QtCore : 主要和时间、文件与文件夹、各种数据、流、URLs、mime 类文件、进程与线程一起使用。 QtGui : 图形用户界面组件,包含了窗口系统、事件处理、2D 图像、基本绘画、字体和文字类。 布局管理器 (Layout Managers): 用于组织和排列窗口中的小部件。常见的有 QVBoxLayout (垂直布局)、QHBoxLayout (水平布局)、QGridLayout (网格布局) 等。 信号与槽 (Signals and Slots): 这是 PyQt5 的核心机制。当一个事件发生时（例如按钮被点击），会发出一个“信号”，你可以将这个信号连接到某个“槽”函数上，槽函数会在信号发出时被执行。 事件处理 (Event Handling): PyQt5 通过事件循环来处理用户的输入和其他系统事件。 绘图 (Painting): 你可以使用 QPainter 在 QWidget 上绘制图形、文本和图像。 在 Qt 框架中，对象的继承关系是其核心设计模式之一，它构建了 Qt 强大的功能和灵活的架构。理解 Qt 的继承体系对于有效使用 Qt 进行开发至关重要。\nQt 对象模型的基石：QObject Qt 中所有可交互的、支持信号与槽机制的对象都继承自一个共同的基类：QObject。\nQObject 的关键特性：\n信号与槽（Signals \u0026amp; Slots）： 这是 Qt 独有的机制，用于对象之间的通信。QObject 提供了实现这一机制所需的基础设施。任何继承自 QObject 的类都可以定义信号和槽，实现解耦的事件处理。 对象树（Object Tree）： QObject 对象可以组织成一个父子层次结构，形成一个“对象树”。当父对象被删除时，它的所有子对象也会自动被删除（即子对象会被 deleteLater() 标记为删除），这有助于管理内存，避免内存泄漏。 例如，你在窗口上放置一个按钮，按钮就是窗口的子对象。当你关闭窗口时，按钮也会随之销毁。 属性系统（Property System）： QObject 提供了一个元对象系统（Meta-Object System），允许在运行时查询对象的属性、调用槽、发出信号等。属性系统允许你定义自定义属性，并进行持久化、动画等操作。 动态类型信息： 运行时类型信息（RTTI）在 Qt 中通过 qobject_cast\u0026lt;T\u0026gt;() 和 inherits() 等方法实现，允许你在运行时安全地进行类型转换和检查。 Qt 主要的继承层次 从 QObject 派生出了 Qt 应用程序中常见的各种类：\nQObject (基类)\n所有需要信号与槽、对象树等功能的类都继承自它。 QObject → QPaintDevice\nQPaintDevice 是所有可以被 QPainter 绘制的对象的基类。它定义了绘图操作所需的基本接口。 例子：QPixmap, QImage, QWidget, QPrinter 等。 QObject → QWidget\nQWidget 是所有用户界面（UI）对象的基类。它代表了一个可见的、可以接收鼠标和键盘事件的矩形区域。 QWidget 继承自 QObject (因此支持信号与槽、对象树) 和 QPaintDevice (因此可以被绘制)。 它提供基本的几何管理（大小、位置）、事件处理（鼠标、键盘）、绘画事件等。 重要子类（构成大部分 GUI 界面）： QMainWindow: 提供一个带有菜单栏、工具栏、状态栏和中心部件的主应用程序窗口。 QDialog: 用于弹出对话框，例如文件选择对话框、设置对话框等。 QPushButton: 按钮。 QLabel: 显示文本或图片。 QLineEdit: 单行文本输入框。 QTextEdit: 多行文本编辑器。 QCheckBox: 复选框。 QRadioButton: 单选按钮。 QComboBox: 下拉列表。 QListWidget, QTableWidget, QTreeWidget: 用于显示列表、表格和树形结构数据。 布局管理器（虽然它们不是 QWidget 的子类，但与 QWidget 紧密协作）：QVBoxLayout, QHBoxLayout, QGridLayout, QFormLayout 等。它们是 QLayout 的子类，而 QLayout 又是 QObject 的子类。 QObject → QAbstractItemModel / QAbstractItemView (模型/视图框架)\nQt 的模型/视图编程提供了一种将数据（模型）和显示数据的方式（视图）分离的强大机制。 QAbstractItemModel 是所有数据模型的抽象基类。 QAbstractItemView 是所有视图的抽象基类。 例子： 模型： QStringListModel, QStandardItemModel (自定义数据模型通常会继承 QAbstractItemModel 或其子类)。 视图： QListView, QTableView, QTreeView (这些视图类也继承自 QWidget)。 QObject → QNetworkAccessManager (网络)\n用于执行网络请求，如 HTTP、FTP 等。 QObject → QTimer (定时器)\n用于在指定时间间隔后发出信号。 \u0026hellip;还有许多其他领域特定的类，如数据库（QSqlDatabase）、多媒体（QMediaPlayer）、图形视图框架（QGraphicsView, QGraphicsScene）等，它们也大多直接或间接继承自 QObject。\n继承关系图示（简化版） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 QObject | +----------------------------------------+ | | | QPaintDevice QLayout QNetworkAccessManager | | | | | | +-- QWidget -----+ | | | +------------+------------+ | | | | | QMainWindow QDialog QPushButton, QLabel, | QLineEdit, ... | | QAbstractItemModel QTimer QAbstractItemView 为什么 Qt 采用这种继承结构？ 统一的事件处理： 所有的 QObject 实例都可以参与到 Qt 的事件循环中，通过信号与槽进行通信。 内存管理： 对象树简化了内存管理，减少了程序员手动管理对象生命周期的负担。 可扩展性： 通过继承，开发者可以在现有控件的基础上轻松创建自定义控件，复用大量现有功能。 元对象系统： 这是 Qt 强大的动态特性（如属性系统、翻译、信号与槽的反射）的基础，而 QObject 及其继承体系是启用这些特性的关键。 一致的 API： 开发者在 Qt 应用程序中与不同类型的对象交互时，会发现其 API 风格和行为非常一致，降低了学习曲线。 理解 Qt 的继承关系有助于你更好地选择合适的基类来开发自己的组件，利用 Qt 提供的丰富功能，并遵循其推荐的设计模式。\n在 Qt 的对象模型中，父子关系（Parent-Child Relationship） 是通过 QObject 类及其派生类来确立的，它是 Qt 内存管理和对象生命周期管理的核心机制之一。这种关系主要通过两种方式确立：\n在构造函数中指定父对象（最常见且推荐的方式） 通过 setParent() 方法设置父对象 父对象 在构造函数中指定父对象 (Constructor Parameter) 这是在 Qt 中确立父子关系最常见、最直接也是最推荐的方式。几乎所有继承自 QObject 的类，包括所有的 QWidget 控件，它们的构造函数都带有一个可选的 parent 参数。\n语法：\nPython\n1 child_object = ChildClass(parent_object) 示例：\nPython\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import sys from PyQt5.QtWidgets import QApplication, QMainWindow, QPushButton, QVBoxLayout, QWidget class MyWindow(QMainWindow): def __init__(self): super().__init__() self.setWindowTitle(\u0026#34;父子关系示例\u0026#34;) self.setGeometry(100, 100, 400, 300) central_widget = QWidget() self.setCentralWidget(central_widget) layout = QVBoxLayout(central_widget) # 布局管理器通常将其父部件作为参数 # 创建一个按钮，并将其父对象设置为 central_widget self.button1 = QPushButton(\u0026#34;按钮 1\u0026#34;, central_widget) layout.addWidget(self.button1) # 创建另一个按钮，也将其父对象设置为 central_widget self.button2 = QPushButton(\u0026#34;按钮 2\u0026#34;) self.button2.setParent(central_widget) # 也可以这样设置，但不如构造函数直接 layout.addWidget(self.button2) if __name__ == \u0026#39;__main__\u0026#39;: app = QApplication(sys.argv) window = MyWindow() window.show() sys.exit(app.exec_()) 解释：\n在上面的例子中，QPushButton(\u0026quot;按钮 1\u0026quot;, central_widget) 这一行代码，将 central_widget 指定为 button1 的父对象。 QVBoxLayout(central_widget) 也是类似，布局管理器会自动将其管理的控件添加到其父部件上。 当一个 QObject 实例的构造函数接收一个 QObject 类型的 parent 参数时，它会将自身（子对象）添加到 parent 对象的子对象列表中。 通过 setParent() 方法设置父对象 你也可以在对象创建之后，通过调用其 setParent() 方法来确立或修改父子关系。\n语法：\nPython\n1 child_object.setParent(parent_object) 示例（接上文）：\nPython\n1 2 3 4 5 # 创建另一个按钮，先不指定父对象 self.button2 = QPushButton(\u0026#34;按钮 2\u0026#34;) # 之后再将其父对象设置为 central_widget self.button2.setParent(central_widget) layout.addWidget(self.button2) # 注意：布局管理器会把其添加的部件自动设为布局的父部件的子部件 需要注意的几点：\n一个子对象只能有一个父对象。 如果你多次调用 setParent()，最新的调用会覆盖之前的父子关系。 内存管理： 当父对象被销毁时，所有作为其子对象的 QObject 实例也会被自动销毁。这是 Qt 强大的内存管理机制。你通常不需要手动 del 子对象，除非它们没有父对象。 重要提示： 如果一个 QObject 没有父对象，那么它的生命周期需要你手动管理。这在创建独立的窗口（如 QMainWindow 或 QDialog）时很常见，因为它们是应用程序的顶级窗口，通常没有父对象。 可见性： 如果一个 QWidget 有父对象，通常它的显示会受到父对象的限制。子部件不会显示在父部件之外。 布局管理器： 当你使用布局管理器 (QHBoxLayout, QVBoxLayout, QGridLayout 等) 将控件添加到布局中时，布局管理器会自动处理控件的父子关系，通常会将布局的父部件设置为被添加控件的父部件。这也是为什么在上面的例子中，即使 button2 最初没有指定父对象，但通过 layout.addWidget(self.button2) 后，它最终也会成为 central_widget 的子部件。 父子关系的好处： 自动内存管理： 最重要的好处是避免了内存泄漏。你不需要担心何时释放子对象，Qt 会在父对象销毁时自动清理。 层次结构组织： 方便管理和组织复杂的 UI 界面，形成清晰的对象树。 事件传播： 事件（如键盘事件、鼠标事件）可以沿着对象树从父对象传播到子对象，或反之，方便事件处理。 属性继承： 某些属性（如字体、调色板）可能会从父部件传递给子部件，简化了样式设置。 总而言之，在 Qt 中确立父子关系最常见的做法是在构造函数中指定父对象，这不仅简洁，也确保了内存管理的正确性。\nQt 的事件传播机制 当一个鼠标事件（比如 mousePressEvent）发生时，Qt 的事件系统会遵循一套规则来决定哪个部件应该处理这个事件：\n事件发生并首先发送给最顶层的部件： 当用户点击屏幕上的某个点时，Qt 首先会确定哪个 最顶层（top-level） 的 QWidget 包含这个点击点（例如，你的主窗口）。 事件向下传播到最深层的子部件： 然后，Qt 会从这个顶级部件开始，沿着对象树向下遍历，找到位于点击点下方的 最深层（innermost） 的子部件。 事件分发给最深层部件： Qt 会将 mousePressEvent 首先分发给这个最深层的子部件（也就是你实际点击的那个控件）。 事件冒泡（Bubble Up）/ 默认处理： 如果最深层的子部件重写了 mousePressEvent 并且没有调用 super().mousePressEvent(event)： 那么这个事件就被这个子部件“消费”了，它不会继续向上冒泡到它的父部件。这意味着父部件的 mousePressEvent 不会被触发。 如果最深层的子部件没有重写 mousePressEvent： 那么 Qt 会调用其父类的默认 mousePressEvent 实现，事件会继续向上冒泡到其父部件。 如果最深层的子部件重写了 mousePressEvent 但调用了 super().mousePressEvent(event)： 那么子部件的逻辑会先执行，然后事件会继续向上冒泡，触发父部件的 mousePressEvent（如果父部件也重写了）。 信号与槽 Qt 的信号与槽（Signals \u0026amp; Slots）机制是 Qt 框架的核心特性之一，它用于对象之间进行通信。这种机制替代了传统的 C++ 回调函数（callbacks）或函数指针，提供了一种类型安全、松散耦合的方式来处理事件和实现模块之间的通信。\n什么是信号（Signals）？ 定义：当一个特定事件发生时，一个对象会发出（emit）一个信号。例如，QPushButton 在被点击时会发出 clicked() 信号。 触发：信号由对象自动生成，以响应某些内部状态变化或用户操作。例如，当用户点击按钮时，按钮对象就会自动发出 clicked() 信号。 特性： 自动生成：信号是自动生成的，你不需要手动编写代码来发出它们，只需声明并连接。 参数：信号可以带有参数，这些参数可以传递事件的相关信息。例如，QSlider 的 valueChanged() 信号可以传递当前滑块的值。 无返回类型：信号没有返回类型，它们不能返回任何值。 独立于接收者：发出信号的对象（发送者）不需要知道是哪个对象（或哪些对象）在接收它的信号。这种松散耦合是信号与槽机制的关键优势。 什么是槽（Slots）？ 定义：槽是普通的 C++ 函数（或 Python 方法），当与之连接的信号被发出时，槽就会被调用。 作用：槽用于响应信号。例如，当 QPushButton 发出 clicked() 信号时，你可以将这个信号连接到一个槽，该槽负责执行某个操作，如更新文本标签或打开新窗口。 特性： 普通函数：槽可以是任何普通的 Python 方法或 C++ 函数（包括静态函数、全局函数、或类的成员函数）。 参数匹配：槽的参数必须与连接到它的信号的参数兼容。这意味着槽可以接受信号传递的所有参数，或者更少的参数（从右侧开始省略）。 可以是虚函数：槽可以是虚函数，这使得它们可以在子类中被重写，从而实现多态行为。 可以是私有、保护或公共：槽的访问权限没有限制，但通常为了与其他类通信，它们会被声明为公共的。 如何连接（Connecting）信号和槽？ 使用 connect() 方法来建立信号与槽之间的连接。\n基本语法：\nPython\n1 sender.signal.connect(receiver.slot) sender：发出信号的对象。 signal：发送者对象的某个信号。 receiver：接收信号的对象。 slot：接收者对象的某个槽（方法）。 示例：\nPython\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from PyQt5.QtWidgets import QApplication, QPushButton, QLabel, QVBoxLayout, QWidget from PyQt5.QtCore import Qt app = QApplication([]) window = QWidget() layout = QVBoxLayout() button = QPushButton(\u0026#34;点击我\u0026#34;) label = QLabel(\u0026#34;你好，世界！\u0026#34;) label.setAlignment(Qt.AlignCenter) # 连接信号和槽 # 当 button 发出 clicked() 信号时，调用 label 的 setText() 槽 button.clicked.connect(lambda: label.setText(\u0026#34;按钮被点击了！\u0026#34;)) layout.addWidget(button) layout.addWidget(label) window.setLayout(layout) window.show() app.exec_() 在这个例子中，button 是发送者，clicked() 是信号，label 是接收者，setText() 是槽。\n信号与槽的优势 松散耦合（Loose Coupling）：发送者和接收者彼此独立，发送者不需要知道接收者的任何信息（除了它将发出的信号）。这种解耦使得组件更容易复用和维护。 类型安全（Type Safety）：Qt 的 connect 机制会在连接时检查信号和槽的参数类型是否兼容，从而避免运行时错误。 可重用性（Reusability）：由于松散耦合，组件可以更容易地在不同的上下文和应用程序中被重用。 清晰的通信路径：代码中信号和槽的连接清晰地表明了对象间的通信路径，使得代码更容易理解。 一对多 / 多对一连接： 一个信号可以连接到多个槽。 多个信号可以连接到同一个槽。 一个信号可以连接到另一个信号（信号转发）。 自定义信号（Custom Signals） 除了 Qt 内置的信号，你也可以在自己的类中定义和发出自定义信号。在 PyQt 中，这通过 pyqtSignal 来实现。\n步骤：\n导入 pyqtSignal：from PyQt5.QtCore import pyqtSignal。 在类中声明信号：作为类属性声明，指定信号将传递的参数类型。 在方法中发出信号：使用 emit() 方法发出信号。 示例：\nPython\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QVBoxLayout, QLabel from PyQt5.QtCore import pyqtSignal, QObject class MyEmitter(QObject): # 声明一个自定义信号，不带参数 my_signal_no_args = pyqtSignal() # 声明一个带一个字符串参数的信号 my_signal_with_str = pyqtSignal(str) # 声明一个带两个整数参数的信号 my_signal_with_ints = pyqtSignal(int, int) def __init__(self, parent=None): super().__init__(parent) self.counter = 0 def do_something(self): self.counter += 1 print(\u0026#34;Doing something...\u0026#34;) self.my_signal_no_args.emit() # 发出不带参数的信号 self.my_signal_with_str.emit(f\u0026#34;操作 {self.counter} 完成！\u0026#34;) # 发出带字符串参数的信号 self.my_signal_with_ints.emit(self.counter, self.counter * 10) # 发出带整数参数的信号 class MyReceiver(QObject): def __init__(self, label, parent=None): super().__init__(parent) self.label = label def slot_no_args(self): self.label.setText(\u0026#34;信号被接收了！\u0026#34;) print(\u0026#34;槽：不带参数的信号被触发。\u0026#34;) def slot_with_str(self, message): self.label.setText(f\u0026#34;接收到消息: {message}\u0026#34;) print(f\u0026#34;槽：接收到字符串信号: {message}\u0026#34;) def slot_with_ints(self, num1, num2): print(f\u0026#34;槽：接收到两个整数信号: {num1}, {num2}\u0026#34;) app = QApplication(sys.argv) window = QWidget() layout = QVBoxLayout() emitter = MyEmitter() status_label = QLabel(\u0026#34;等待操作...\u0026#34;) receiver = MyReceiver(status_label) # 连接自定义信号到槽 emitter.my_signal_no_args.connect(receiver.slot_no_args) emitter.my_signal_with_str.connect(receiver.slot_with_str) emitter.my_signal_with_ints.connect(receiver.slot_with_ints) action_button = QPushButton(\u0026#34;执行操作\u0026#34;) action_button.clicked.connect(emitter.do_something) # 连接按钮点击到发射器的do_something方法 layout.addWidget(action_button) layout.addWidget(status_label) window.setLayout(layout) window.show() sys.exit(app.exec_()) 面向对象编程 好久没回忆这里的内容了，之前写了很多C，搞忘记了这里。\n面向对象编程（Object-Oriented Programming, OOP）简介 在解释继承和父对象之前，我们先快速回顾一下面向对象编程的基本思想。\n面向对象编程是一种编程范式，它将程序中的数据和操作数据的方法组织成一个个对象。对象是类的实例。\n核心概念：\n类（Class）: 它是创建对象的蓝图或模板。类定义了对象的属性（数据）和行为（方法）。例如，一个 汽车 类可能定义了 颜色、品牌 等属性，以及 启动、加速 等方法。 对象（Object）: 它是类的实例。一个 汽车 类的对象可以是“我的红色宝马”或者“邻居的蓝色丰田”。每个对象都有自己的属性值。 封装（Encapsulation）: 将数据（属性）和操作数据的方法（行为）捆绑在一起，形成一个独立的单元（对象）。它隐藏了对象的内部实现细节，只暴露必要的接口。 多态（Polymorphism）: 允许不同类的对象对同一个消息做出不同的响应。例如，汽车 和 摩托车 都有 启动 方法，但它们的具体启动方式可能不同。 继承（Inheritance） 继承是面向对象编程中一个非常强大的机制，它允许一个类（子类/派生类）从另一个已存在的类（父类/基类）中获取（继承）属性和方法。\n核心思想：\n代码复用: 子类可以直接使用父类中已经定义好的属性和方法，而无需重新编写，大大减少了代码冗余。 建立“is-a”关系: 继承表达了一种“是（is-a）”的关系。例如，“狗是一种动物”，“轿车是一种汽车”。 扩展性: 子类可以在继承父类的基础上，添加自己特有的属性和方法，或者重写（覆盖）父类的方法，以实现更具体或不同的行为。 现在，我们想创建 狗 (Dog) 和 猫 (Cat) 类。它们都是动物，所以它们应该拥有动物的基本属性（名字）和行为（叫、吃）。这时，我们就可以让 Dog 和 Cat 继承 Animal 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Dog(Animal): # Dog 继承 Animal def __init__(self, name, breed): super().__init__(name) # 调用父类 Animal 的构造函数 self.breed = breed # Dog 特有的属性 def speak(self): # 重写父类的 speak 方法 print(f\u0026#34;{self.name} (一只{self.breed}) 汪汪叫！\u0026#34;) def fetch(self): # Dog 特有的方法 print(f\u0026#34;{self.name} 正在捡球。\u0026#34;) class Cat(Animal): # Cat 继承 Animal def __init__(self, name, color): super().__init__(name) # 调用父类 Animal 的构造函数 self.color = color # Cat 特有的属性 def speak(self): # 重写父类的 speak 方法 print(f\u0026#34;{self.name} (一只{self.color}猫) 喵喵叫！\u0026#34;) def scratch(self): # Cat 特有的方法 print(f\u0026#34;{self.name} 正在抓挠。\u0026#34;) Animal 是父类。 Dog 和 Cat 是子类。 Dog 和 Cat 自动获得了 Animal 类的 name 属性以及 eat 方法。 Dog 和 Cat 分别重写了 speak 方法，使其更具体地表达了狗和猫的叫声。 Dog 添加了特有的 breed 属性和 fetch 方法。 Cat 添加了特有的 color 属性和 scratch 方法。 父对象 / 父类（Parent Class / Base Class / Superclass） “父对象”和“父类”是同一个概念的不同表达方式，但“父类”是更常用和准确的术语。\n父类（Parent Class / Base Class / Superclass）:\n定义: 被其他类继承的类。它提供通用的属性和方法，供子类共享。 作用: 作为子类的基础，定义了子类共有的特性和行为。 在上面的例子中，Animal 就是 Dog 和 Cat 的父类。 父对象:\n这个词组通常不直接用来指代类本身。 在某些上下文语境中，它可能间接指代父类的实例。例如，如果 dog_instance 是 Dog 类的一个对象，那么我们可能会说 dog_instance 的“父类型”是 Animal，或者说 dog_instance 是从 Animal “派生”出来的。 组合与继承 1. 继承关系（Inheritance） 含义： 继承表达的是一种“is-a”（是\u0026hellip;一种）的关系。一个子类“是”一个父类。 例如：狗是一种动物 (Dog is an Animal)，汽车是一种交通工具 (Car is a Vehicle)。 实现方式： 子类直接从父类派生，获得父类的属性和方法。子类可以扩展或重写父类的功能。 优点： * 代码复用： 子类无需重新实现父类已有的功能。 多态性： 允许使用父类引用来处理子类对象，提高代码的灵活性和可扩展性。 层次结构： 能够清晰地表示类之间的分类和泛化关系。 缺点： 紧耦合： 子类和父类之间存在强烈的依赖关系。父类的改变可能会影响所有子类。 单一继承的限制： 许多语言（如 Java、C#、Python 的普通类）只支持单继承，即一个子类只能有一个直接父类。这可能导致“类爆炸”或难以建模多方面特性的情况。 违反封装： 子类可以访问父类的受保护成员，一定程度上破坏了封装性。 “脆弱的基类”问题： 父类的一些修改（即使是很小的）也可能导致子类行为异常。 2. 组合关系（Composition） 含义： 组合表达的是一种“has-a”（拥有\u0026hellip;）的关系。一个类“拥有”另一个类的对象作为其成员。 例如：汽车拥有一个引擎 (Car has an Engine)，电脑拥有一个CPU (Computer has a CPU)。 实现方式： 一个类（被称为容器类或复合类）在其内部包含另一个类（被称为被包含类或组件类）的实例作为其属性。 优点： 松耦合： 容器类和被包含类之间的依赖性较弱。容器类只需要知道如何与被包含类的公共接口进行交互，而不需要关心其内部实现细节。 高内聚： 每个类只负责自己的功能，职责更单一。 灵活性： 可以更容易地替换或修改组件，而不需要修改容器类的代码（只要接口不变）。 避免“脆弱的基类”问题： 组合关系下，组件类的修改对容器类的影响远小于继承关系下父类的修改对子类的影响。 解决多重继承的复杂性： 当一个类需要多种功能时，可以通过组合多个组件来实现，避免了多重继承可能带来的复杂性和歧义。 缺点： 功能委托： 容器类需要显式地将被包含类的功能暴露出来（通过方法调用），不像继承那样自动获得所有公共方法。 对象创建和管理： 容器类可能需要负责创建和管理其组件对象的生命周期。 适用场景： 当一个类是另一个类的组成部分，而不是其具体类型时。 当需要构建灵活、可配置的系统时。 当一个类需要多种不同的功能，而这些功能可以通过独立的组件来提供时。 “优先使用组合而不是继承”（Prefer composition over inheritance）是面向对象设计的一个重要原则，尤其是在需要高灵活性和低耦合度的场景。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Engine: def start(self): print(\u0026#34;Engine started.\u0026#34;) def stop(self): print(\u0026#34;Engine stopped.\u0026#34;) class Wheel: def rotate(self): print(\u0026#34;Wheel rotating.\u0026#34;) class Car: def __init__(self): self.engine = Engine() # Car has an Engine (组合关系) self.wheels = [Wheel(), Wheel(), Wheel(), Wheel()] # Car has Wheels (组合关系) def drive(self): self.engine.start() # 委托给 engine 对象 for wheel in self.wheels: wheel.rotate() # 委托给 wheel 对象 print(\u0026#34;Car is driving.\u0026#34;) def stop_car(self): self.engine.stop() print(\u0026#34;Car stopped.\u0026#34;) # 使用 my_car = Car() my_car.drive() my_car.stop_car() ","date":"2025-08-11T00:00:00Z","image":"https://oldlay.github.io/p/ai-chess/chess_hu_29d26ee59ea1566b.jpg","permalink":"https://oldlay.github.io/p/ai-chess/","title":"AI-Chess"},{"content":"第一章 1. 介绍 这门课主要针对的是如何编程。 这门课关于什么：\n设计程序要做什么 分析程序的表现 确认程序的正确性 控制复杂度 每一个编程语言都会去操控值，其中一种值是函数，表达式是计算值和计算的方式。\n语句与表达式：Python 代码由表达式和语句组成。从广义上讲，计算机程序由指令组成，这些指令用于执行以下操作：\n计算一些值 执行动作 语句通常描述操作。当 Python 解释器执行一个语句时，它会执行相应的操作。另一方面，表达式通常描述计算。当 Python 评估一个表达式时，它会计算该表达式的值。 对象：对象可以将数据和处理数据的逻辑无缝地捆绑在一起，从而管理两者的复杂性。\n解释器： 计算复合表达式需要一个精确的程序，以可预测的方式解释代码。实现这种程序、对复合表达式进行求值的程序称为解释器。\n最后，我们会发现所有这些核心概念都密切相关：函数是对象，对象是函数，而解释器则是两者的实例。不过，要掌握编程艺术，关键是要清楚地理解这些概念及其在组织代码中的作用。\n学会解释错误和诊断意外错误的原因被称为调试。调试的一些指导原则是：\n逐步测试： 每一个编写良好的程序都是由可以单独测试的小型模块化组件组成的。尽快测试你编写的所有程序，以便及早发现问题，并对你的组件充满信心。 隔离错误： 语句输出中的错误通常可以归咎于某个模块组件。在尝试诊断问题时，先将错误追踪到最小的代码片段，然后再尝试纠正。 检查您的假设： 解释器会严格执行您的指令，不多也不少。当某些代码的行为与程序员认为（或假设）的行为不一致时，解释器的输出就会出乎意料。了解你的假设，然后将调试工作的重点放在验证你的假设是否确实成立上。 咨询他人： 你并不孤单！如果你不理解错误信息，可以询问朋友、老师或搜索引擎。如果你已经找出了一个错误，但不知道如何纠正，可以请其他人帮忙看看。在集体解决问题的过程中，可以分享很多宝贵的编程知识。 2. 编程 每一种强大的编程语言都有以下机制：\n原始表达式和语句，代表了语言所提供的最简单的构件； 组合手段，通过这种手段可以从较简单的元素构建出复合元素； 抽象手段，通过这种手段可以将复合元素作为单元进行命名和操作。 在编程中，我们要处理两种元素：函数和数据。从形式上讲，数据是我们想要操作的东西，而函数则描述了操作数据的规则。因此，任何功能强大的编程语言都应该能够描述原始数据和原始函数，并拥有一些组合和抽象函数与数据的方法。\n= 符号在 Python（以及许多其他语言）中被称为赋值运算符。赋值是我们最简单的抽象手段，因为它允许我们使用简单的名称来指代复合运算的结果，例如上面计算的面积。通过这种方式，我们可以逐步构建复杂度不断增加的计算对象，从而构建出复杂的程序。 将名称绑定到值，然后再通过名称检索这些值，这意味着解释器必须维护某种内存，以跟踪名称、值和绑定。这种内存被称为环境。\n所以如果从一个更高的视角(抽象)去看赋值操作(=)就会发现很多设计非常合理了。\n我们可以使用赋值语句为现有函数赋予新名称：\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; f = max \u0026gt;\u0026gt;\u0026gt; f \u0026lt;built-in function max\u0026gt; \u0026gt;\u0026gt;\u0026gt; f(2, 3, 4) 4 将内置名称绑定到新值：\n1 2 3 \u0026gt;\u0026gt;\u0026gt; max = 5 \u0026gt;\u0026gt;\u0026gt; max 5 将 max 赋值给 5 后，max 名称不再与函数绑定，因此尝试调用 max(2, 3, 4) 将导致错误。\n要评估一个调用表达式，Python 将执行以下操作：\n评估操作符和操作数子表达式，然后 将操作符子表达式值的函数应用于操作数子表达式值的参数。 即使是这个简单的过程也能说明流程的一些重要问题。第一步规定，为了完成一个调用表达式的评估过程，我们必须首先评估其他表达式。因此，评估过程在本质上是递归的；也就是说，它的步骤之一是需要调用规则本身。 注意：赋值是语句，实行一个动作，而不是表达式。\n纯和非纯函数 纯函数：函数有一些输入（参数），并返回一些输出（应用函数的结果）。没有副作用，只计算来返回值。 非纯函数：除了返回值外，应用非纯函数还可能产生副作用，对解释器或计算机的状态造成一些改变。常见的副作用是使用 print 函数生成返回值之外的额外输出。\n纯函数受到限制，不能产生副作用，也不能随时间改变行为。施加这些限制会带来很多好处。首先，纯函数可以更可靠地组成复合调用表达式。其次，纯函数往往更易于测试。参数列表总是会导致相同的返回值，可以将其与预期返回值进行比较。 纯函数对于编写并发程序至关重要，在并发程序中，多个调用表达式可以同时求值。\n函数只能操作其本地环境这一事实对于创建模块化程序至关重要，在模块化程序中，纯函数只能通过它们获取和返回的值进行交互。\n2.函数 核心思想：把函数当作值。\n如何理解这句话? 这句话意味着函数在编程语言中拥有与任何其他数据类型（如数字、字符串、列表等）相同的地位和能力。函数被视为一种特殊的值，这是函数式编程（Functional Programming）的一个核心概念。 在编程中，值（value）是可以被存储、传递、操作和返回的对象。常见的值包括数字、字符串、列表等。在 Python 中，函数同样是一种值。这意味着函数可以像其他值一样被存储、传递、操作和返回。\n在函数式编程中，函数被视为一等公民（first-class citizens），这意味着它们可以像其他值一样被处理。这种思想的核心是：\n高阶函数：接受函数作为参数或返回函数的函数。 不可变性：尽量避免修改数据，而是通过函数返回新的值。 纯函数：函数的输出只依赖于输入参数，没有副作用。 我们在 Python 中发现了一些任何功能强大的编程语言都必须具备的元素：\n数字和算术运算是原始的内置数据值和函数。 嵌套函数应用提供了一种组合操作的方法。 将名称与值绑定提供了一种有限的抽象方法。 将函数作为值看待带来了巨大的灵活性和表达力，是现代编程中许多高级概念的基础，包括：\n高阶函数（Higher-Order Functions）： 能够接收函数作为参数或返回函数的函数。这是 CS 61A 中非常重要的一个主题，例如 map、filter、reduce。 抽象和模块化： 允许你编写更通用、更可重用的代码。你可以将特定行为封装在函数中，然后将这些行为传递给其他函数，从而改变它们的行为而无需修改核心逻辑。 闭包（Closures）： 当一个内部函数引用了其外部作用域的变量时，即使外部函数已经执行完毕，这些变量仍然会被保留。 装饰器（Decorators）： Python 中一种修改或增强函数行为的语法糖，其底层原理就是将函数作为值传递和返回。 函数式编程： 这种编程范式强调使用函数来构建程序，将函数视为核心构建块。 现在我们将学习函数定义，这是一种更强大的抽象技术，通过它可以将名称与复合操作绑定，然后将其称为一个单元。\n函数名在环境图中会重复出现两次。 内在名称（intrinsic name）：这是函数自身的名字，出现在函数定义中。例如，在func square(x)中，“square”就是函数的内在名称。一个函数自身只有一个内在名称，这个名称是函数定义时确定的，用于标识这个函数本身。 绑定名称（bound name）：这是在环境的某个帧（frame）中与函数值绑定的名字。例如，如果我们在全局框架中用f = square，那么在全局框架中，“f”就是绑定到square函数的绑定名称。不同的名字可以绑定到同一个函数，但函数本身只有一个内在名称。 两者的区别在于：绑定名称用于在环境中引用函数，而内在名称是函数本身的标识。在程序运行过程中，我们通过绑定名称来调用函数，但函数的内在名称不会改变。 python提供三种将一个值定义到一个名字上的方法：\n赋值 定义函数 函数传参 函数签名：对函数形式参数的描述称为函数签名。\n匿名函数：就是lambda函数，一般的函数是和名字绑定的，但匿名函数不是。 lambda a, x, b: a * x + b\n闭包 1 2 3 4 5 6 7 8 9 10 def outer_function(): def inner_function(): print(\u0026#34;Hello from inner_function!\u0026#34;) return inner_function # 调用 outer_function 并获取返回值 my_function = outer_function() # 调用返回的 inner_function my_function() 输出 1 Hello from inner_function! 解释 函数作为返回值\n在 outer_function 中，定义了一个内部函数 inner_function。 outer_function 的返回值是 inner_function 的引用（而不是调用 inner_function）。 当你在外部调用 outer_function() 时，它返回了 inner_function 的引用，并将这个引用赋值给变量 my_function。 闭包的特性\ninner_function 是一个闭包（closure）。闭包是一种特殊的函数对象，它不仅包含函数的代码，还包含了函数定义时所在的作用域链。 在这个例子中，inner_function 被定义在 outer_function 的局部作用域中，但它被返回到全局作用域中。 尽管 outer_function 的调用已经结束，inner_function 仍然可以访问 outer_function 的局部作用域中的变量（如果有的话）。 为什么可以在外部调用\n当你将 inner_function 的引用赋值给 my_function 后，my_function 实际上是一个指向 inner_function 的引用。 虽然 inner_function 是在局部作用域中定义的，但它的引用被保存在全局作用域中（通过 my_function）。 因此，你可以通过 my_function() 来调用 inner_function，就好像它是一个全局函数一样。 闭包的用途 闭包在 Python 中非常有用，尤其是在以下场景中：\n封装状态：闭包可以捕获和封装局部变量的状态，使得这些变量在函数外部仍然可以被访问。 回调函数：闭包可以作为回调函数传递，同时携带一些上下文信息。 装饰器：闭包是实现装饰器的基础，装饰器本质上是一个返回函数的函数。 总结 闭包：内部函数 inner_function 是一个闭包，它捕获了定义时所在的作用域。 引用传递：outer_function 返回了 inner_function 的引用，这个引用被保存在全局作用域中。 外部调用：通过保存的引用，可以在外部调用 inner_function，就好像它是一个全局函数一样。 函数式抽象 尽管 sum_squares 非常简单，但它体现了用户定义函数最强大的特性。函数 sum_squares 是根据函数 square 定义的，但它仅依赖于 square 定义的其输入参数和输出值之间的关系。\n我们可以编写 sum_squares, 而不必考虑如何平方一个数。关于如何计算平方的细节可以被抑制，以便以后再考虑。事实上，就 sum_squares 而言，平方并不是一个特定的函数体，而是一个函数的抽象，即所谓的函数抽象。在这个抽象层面上，任何计算平方的函数都是同样好的。\n因此，仅考虑它们返回的值，任意个用于平方数的函数应该是不可区分的。每个函数都接受一个数值参数，并生成该数的平方作为值。\n换句话说，函数定义应该能够抑制细节。函数的用户可能不是自己编写的函数，而是从另一个程序员那里获得的 “黑匣子”。对于另一个程序员不应该需要知道函数是如何实现的才能使用它。Python 库具有这个属性。许多开发人员使用那里定义的函数，但很少有人检查过它们的实现。\n要掌握函数式抽象的使用，通常需要考虑它的三个核心属性。\n函数的域是它可以接受的参数集。 函数的范围是它可以返回的值集。 函数的意图是它计算输入和输出之间的关系 (以及它可能产生的任何副作用)。 通过函数式抽象的域、范围和意图来理解它们，对于在复杂程序中正确使用它们至关重要。 好的函数设计 从根本上说，好的函数的特性都强化了函数是抽象的观念。\n每个函数应该只有一个工作。这个工作应该可以用一个简短的名称来标识，并且可以用一行文本来表示。连续执行多个工作的函数应该分为多个函数。 不要重复自己是软件工程的一个核心原则。所谓的 DRY 原则指出，多个代码片段不应该描述冗余的逻辑。相反，这个逻辑应该被实现一次，给出一个名称，并多次应用。如果你发现自己复制和粘贴了一段代码，你可能已经找到了进行函数式抽象的机会。 应该对函数进行一般性定义。Python 库中没有平方方法，这是因为它是 pow 函数的一个特殊情况，pow 函数会将数字提升到任意次幂。 这些准则提高了代码的可读性，减少了错误的数量， 并且经常最小化所写代码的总量。分解一个复杂的任务将功能转化为简洁的功能是一种需要经验才能掌握的技能。幸运的是, Python提供了几个特性来支持您的工作。\n文档 函数定义通常包括描述函数的文档， 称为文档字符串，它必须与函数体一起缩进。 文档字符串通常用三引号括起来。第一行描述函数所做的行为。下面几行可以描述参数和描述函数的行为：\n1 2 3 4 5 6 7 8 9 10 11 \u0026gt;\u0026gt;\u0026gt; def pressure(v, t, n): \u0026#34;\u0026#34;\u0026#34;Compute the pressure in pascals of an ideal gas. Applies the ideal gas law: http://en.wikipedia.org/wiki/Ideal_gas_law v -- volume of gas, in cubic meters t -- absolute temperature in degrees kelvin n -- particles of gas \u0026#34;\u0026#34;\u0026#34; k = 1.38e-23 # Boltzmann\u0026#39;s constant return n * k * t / v 当你以函数名称作为参数调用 help 时，你会看到它的文档字符串 (键入 q 退出 Python help)。\n默认参数值 定义通用函数的一个后果是引入了额外的参数。具有多个参数的函数可能会导致调用困难和读取困难。\n在 Python 中，我们可以为函数的参数提供默认值。当调用该函数时，具有默认值的参数是可选的。如果参数值没有提供，则默认值将被绑定到形式参数名称。\n测试 测试驱动开发：先写出注释和测试，然后逐渐让测试可行。\n测试是一种系统地执行验证的机制。测试通常采用另一个函数的形式，该函数包含对被测试函数的一个或多个样本调用。然后根据预期结果验证返回值。与大多数旨在通用的函数不同，测试涉及选择和验证具有特定参数值的调用。测试还可以作为文档：它们演示如何调用函数以及哪些参数值是合适的。\n断言。程序员使用断言语句来验证期望，例如被测试函数的输出。断言语句在布尔上下文中有一个表达式，后面跟着一行引号 (单引号或双引号都可以，但要一致), 如果表达式计算结果为假值，则会显示该引号。 assert fib(8) == 13, 'The 8th Fibonacci number should be 13'\nfib 的测试函数应该测试多个参数，包括 n 的极值。\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; def fib_test(): assert fib(2) == 1, \u0026#39;The 2nd Fibonacci number should be 1\u0026#39; assert fib(3) == 1, \u0026#39;The 3rd Fibonacci number should be 1\u0026#39; assert fib(50) == 7778742049, \u0026#39;Error at the 50th Fibonacci number\u0026#39; 当在文件中而不是直接在解释器中写入 Python 时，test 通常会写入同一个文件或带有后缀 _test.py 的邻近文件中。\n文档测试：Python 提供了一种方便的方法，可以直接在函数的文档字符串中放置简单的测试。文档字符串的第一行应该包含对函数的一行描述，后面紧跟一个空行。随后可能会有关于参数和行为的详细描述。此外，文档字符串可能包含一个调用函数的交互式会话示例：\n1 2 3 4 5 6 7 8 9 10 11 12 def sum_naturals(n): \u0026#34;\u0026#34;\u0026#34;Return the sum of the first n natural numbers. \u0026gt;\u0026gt;\u0026gt; sum_naturals(10) 55 \u0026gt;\u0026gt;\u0026gt; sum_naturals(100) 5050 \u0026#34;\u0026#34;\u0026#34; total, k = 0, 1 while k \u0026lt;= n: total, k = total + k, k + 1 return total 交互可以通过 doctest 模块进行验证。下面，globals 函数返回全局环境的表示，这是解释器评估表达式所需的。\n1 2 3 \u0026gt;\u0026gt;\u0026gt; from doctest import testmod \u0026gt;\u0026gt;\u0026gt; testmod() TestResults(failed=0, attempted=2) 为了验证单个函数的 doctest 交互，我们使用了一个名为 run_docstring_examples 的 doctest 函数。它的第一个参数是要测试的函数。第二个参数应该始终是表达式 globals () 的结果，globals () 是一个返回全局环境的内置函数。第三个参数为 True, 表示我们想要 “详细” 的输出：一个运行的所有测试的目录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026gt;\u0026gt;\u0026gt; from doctest import run_docstring_examples \u0026gt;\u0026gt;\u0026gt; run_docstring_examples(sum_naturals, globals(), True) Finding tests in NoName Trying: sum_naturals(10) Expecting: 55 ok Trying: sum_naturals(100) Expecting: 5050 ok 当函数的返回值与预期结果不匹配时，run_docstring_examples 函数会将这个问题报告为测试失败。\n在文件中编写 Python 时，可以通过使用 doctest 命令行选项启动 Python 来运行文件中的所有 doctest: python3 -m doctest \u0026lt;python_source_file\u0026gt;\n有效测试的关键是在实现新函数后立即编写 (并运行) 测试。在实现之前编写一些测试甚至是个好习惯，这样可以在脑海中留下一些示例输入和输出的印象。应用单个函数的测试称为单元测试。详尽的单元测试是良好程序设计的标志。\n高阶函数 为了以命名概念的形式表达某些一般模式（就是将某种模式用函数抽象出来），我们需要构造一些函数，这些函数可以接受其他函数作为参数，也可以返回函数作为值。操纵函数的函数称为高阶函数。\n我们介绍过用户定义函数，它是一种对数字运算模式进行抽象的机制，从而使运算与所涉及的特定数字无关。有了高阶函数，我们开始看到一种更强大的抽象：一些函数表达了通用的计算方法，与它们调用的特定函数无关。\n下面看一个计算黄金分割率的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def improve(update, close, guess=1): #所定义的通用评估程序 while not close(guess): guess = update(guess) return guess def golden_update(guess): return 1/guess + 1 def square_close_to_successor(guess): return approx_eq(guess * guess,guess + 1) def approx_eq(x, y, tolerance=1e-3): return abs(x - y) \u0026lt; tolerance phi = improve(golden_update,square_close_to_successor) 这个例子说明了计算机科学中两个相关的重要思想。首先，命名和函数可以让我们抽象出大量的复杂性。虽然每个函数定义都很琐碎，但我们的评估程序所启动的计算过程却相当复杂。其次，正是因为我们有了一个极其通用的 Python 语言评估程序，小的组件才能组成复杂的过程。了解了程序的解释程序，我们就能验证和检查我们创建的过程。\n与往常一样，我们改进的新通用方法需要一个测试来检验其正确性。黄金分割率可以提供这样一个检验，因为它也有一个精确的闭式解，我们可以将其与这个迭代结果进行比较。\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; from math import sqrt \u0026gt;\u0026gt;\u0026gt; phi = 1/2 + sqrt(5)/2 \u0026gt;\u0026gt;\u0026gt; def improve_test(): approx_phi = improve(golden_update, square_close_to_successor) assert approx_eq(phi, approx_phi), \u0026#39;phi differs from its approximation\u0026#39; \u0026gt;\u0026gt;\u0026gt; improve_test() 对这个测试来说，没有消息就是好消息：在成功执行 assert 语句后，improve_test 返回 None。\n上述示例说明了将函数作为参数传递的能力如何极大地增强了编程语言的表现力。每个一般概念或方程都映射到自己的短函数上。这种方法的一个负面影响是，全局框架中的小函数名称变得杂乱无章，而这些函数必须都是唯一的。另一个问题是，我们受到特定函数签名的限制：要改进的更新参数必须只包含一个参数。嵌套函数定义可以解决这两个问题，但需要我们丰富环境模型。\n嵌套函数定义 上述示例说明了将函数作为参数传递的能力如何极大地增强了编程语言的表现力。每个一般概念或方程都映射到自己的短函数上。这种方法的一个负面影响是，全局框架中的短函数名称变得杂乱无章，而这些函数必须都是唯一的。另一个问题是，我们受到特定函数签名的限制：要改进的更新参数必须只包含一个参数。嵌套函数定义可以解决这两个问题，但需要我们丰富环境模型。\n我们需要对环境模型进行两项扩展，以实现词法范围界定。\n每个用户定义的函数都有一个父环境：即定义该函数的环境。 当用户定义的函数被调用时，其本地框架会扩展其父环境。 1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; def average(x, y): return (x + y)/2 \u0026gt;\u0026gt;\u0026gt; def sqrt_update(x, a): return average(x, a/x) 两个参数的update函数与improve函数不兼容（update需要两个参数，而不是一个）。而且它只提供一次更新，而我们真正关心的是通过重复更新来取平方根。解决这两个问题的办法是将函数定义放在其他定义的主体中。\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; def sqrt(a): def sqrt_update(x): return average(x, a/x) def sqrt_close(x): return approx_eq(x * x, a) return improve(sqrt_update, sqrt_close) 与局部赋值一样，局部 def 语句只影响当前局部框架。这些函数只有在 sqrt 被求值时才处于作用域内。与我们的求值过程一致，在调用 sqrt 之前，这些局部 def 语句甚至不会被求值。\n词法范围。本地定义的函数也可以访问其定义的作用域中的名称绑定。在本例中，sqrt_update 引用了 a 这个名称，它是其外层函数 sqrt 的形式参数。这种嵌套定义之间共享名称的规则称为词法作用域。重要的是，内部函数可以访问其定义环境（而不是调用环境）中的名称。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def average(x, y): return (x + y)/2 def improve(update, close, guess=1): while not close(guess): guess = update(guess) return guess def approx_eq(x, y, tolerance=1e-3): return abs(x - y) \u0026lt; tolerance def sqrt(a): def sqrt_update(x): return average(x, a/x) def sqrt_close(x): return approx_eq(x * x, a) return improve(sqrt_update, sqrt_close) result = sqrt(256) 扩展环境。一个环境可以由任意长的帧链组成，最后总是以全局帧结束。通过嵌套 def 语句调用定义在其他函数中的函数，我们可以创建更长的链。这次调用 sqrt_update 的环境由三个框架组成：本地 sqrt_update 框架、定义了 sqrt_update 的 sqrt 框架（标记为 f1）以及全局框架。\n因此，我们实现了 Python 中词法作用域的两个关键优势:\n局部函数的名称不会与定义它的函数的外部名称相冲突，因为局部函数名称将绑定在定义它的当前局部环境中，而不是全局环境中。 局部函数可以访问外层函数的环境，因为局部函数的主体是在一个扩展了定义它时的评估环境的环境中进行评估的。 函数作为返回值 通过创建返回值本身就是函数的函数，我们可以在程序中实现更强的表达能力。词法作用域编程语言的一个重要特点是，本地定义的函数在返回时会保持其父环境。下面的示例说明了这一特性的实用性。\n一旦定义了许多简单函数，函数组合就是我们编程语言中的一种自然组合方法。也就是说，给定两个函数 f(x) 和 g(x)，我们可能想定义 h(x) = f(g(x))。\n牛顿法是一种经典的迭代方法，用于寻找返回值为 0 的数学函数参数。找到函数的零点通常等同于解决其他一些感兴趣的问题，例如计算平方根。牛顿法是一种迭代改进算法：它改进了对任何可微分函数零点的猜测，这意味着它可以在任意点用直线逼近。牛顿法根据这些直线近似值来寻找函数的零点。\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; def newton_update(f, df): def update(x): return x - f(x) / df(x) return update \u0026gt;\u0026gt;\u0026gt; def find_zero(f, df): def near_zero(x): return approx_eq(f(x), 0) return improve(newton_update(f, df), near_zero) 在实验牛顿法时，请注意该方法并不总是收敛的。改进的初始猜测必须足够接近零点，而且必须满足函数的各种条件。尽管存在这一缺陷，牛顿法仍是一种强大的求解可微分方程的通用计算方法。在现代计算机中，对数和大整数除法的快速算法都采用了该技术的变体。\n柯里化：我们可以使用高阶函数将接受多个参数的函数转换为一系列接受单个参数的函数。更具体地说，给定函数 f (x，y), 我们可以定义一个函数 g, 使得 g (x)(y) 等价于 f (x，y)。在这里，g 是一个高阶函数，它接受单个参数 x, 并返回另一个接受单个参数 y 的函数。这种转换称为柯里化。\n1 2 3 4 5 6 7 \u0026gt;\u0026gt;\u0026gt; def curried_pow(x): def h(y): return pow(x, y) return h \u0026gt;\u0026gt;\u0026gt; curried_pow(2)(3) 8 一些编程语言，如 Haskell, 只允许接受单个参数的函数，因此程序员必须柯里化所有多参数过程。在 Python 等更通用的语言中，当我们需要一个只接受单个参数的函数时，柯里化是有用的。例如，映射模式将一个单参数函数应用于一系列值。在后续章节中，我们将看到更多关于 映射模式的通用示例，但现在，我们可以在一个函数中实现该模式：\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; def map_to_range(start, end, f): while start \u0026lt; end: print(f(start)) start = start + 1 在上面的例子中，我们手动对 pow 函数执行柯里化转换以获得 curried_pow。相反，我们可以定义函数来自动执行柯里化以及逆向非柯里化转换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026gt;\u0026gt;\u0026gt; def curry2(f): \u0026#34;\u0026#34;\u0026#34;Return a curried version of the given two-argument function.\u0026#34;\u0026#34;\u0026#34; def g(x): def h(y): return f(x, y) return h return g \u0026gt;\u0026gt;\u0026gt; def uncurry2(g): \u0026#34;\u0026#34;\u0026#34;Return a two-argument version of the given curried function.\u0026#34;\u0026#34;\u0026#34; def f(x, y): return g(x)(y) return f \u0026gt;\u0026gt;\u0026gt; pow_curried = curry2(pow) \u0026gt;\u0026gt;\u0026gt; pow_curried(2)(5) 32 \u0026gt;\u0026gt;\u0026gt; uncurry2(pow_curried)(2, 5) 32 Lambda表达式 注意，lambda表达式是表达式，不是完全意义上的函数。 到目前为止，每次我们想要定义一个新函数时，都需要给它起一个名字。但对于其他类型的表达式，我们不需要将中间值与名字关联起来。也就是说，我们可以计算 ab + cd, 而无需为子表达式 ab 或 cd 或整个表达式命名。在 Python 中，我们可以使用 Lambda 表达式即时创建函数值，这些表达式会计算未命名的函数。Lambda 表达式会计算一个函数，该函数的函数体只有一个返回表达式。不允许使用赋值语句和控制语句。\n1 2 \u0026gt;\u0026gt;\u0026gt; def compose1(f, g): return lambda x: f(g(x)) 我们可以通过构建相应的英语句子来理解 Lambda 表达式的结构：\nlambda x : f(g(x)) \u0026ldquo;A function that takes x and returns f(g(x))\u0026rdquo;\n第一类函数 作为程序员，我们应该对识别程序中潜在抽象的机会保持警惕，基于它们进行构建，并将其泛化，以创建更强大的抽象。这并不是说一个人总是应该以尽可能抽象的方式编写程序；专业程序员知道如何选择适合他们任务的抽象级别。但重要的是能够从这些抽象的角度思考，这样我们就可以准备好在新的上下文中应用它们。高阶函数的重要性在于，它们使我们能够在编程语言中明确地将这些抽象表示为元素，这样它们就可以像其他计算元素一样被处理。\n总的来说，编程语言对计算元素的操作方式施加了限制。限制最少的元素被认为具有一等地位。一等元素的一些 “权利和特权” 包括：\n它们可能与名称相关联。 它们可以作为参数传递给函数。 它们可以作为函数的结果返回。 它们可以包含在数据结构中。 Python 授予函数完全一等地位，由此带来的表达能力提升是巨大的。\n函数装饰器 Python 提供了特殊的语法，用于在执行 def 语句 (称为装饰器) 时应用高阶函数。最常见的例子可能是 trace。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026gt;\u0026gt;\u0026gt; def trace(fn): def wrapped(x): print(\u0026#39;-\u0026gt; \u0026#39;, fn, \u0026#39;(\u0026#39;, x, \u0026#39;)\u0026#39;) return fn(x) return wrapped \u0026gt;\u0026gt;\u0026gt; @trace def triple(x): return 3 * x \u0026gt;\u0026gt;\u0026gt; triple(12) -\u0026gt; \u0026lt;function triple at 0x102a39848\u0026gt; ( 12 ) 36 在这个例子中，定义了一个高阶函数 trace, 该函数返回一个函数，该函数在调用其参数之前使用打印语句输出参数。三重函数的 def 语句包含一个 @trace 注释，这影响了 def 的执行规则。像往常一样，创建了函数 triple。然而，名称 triple 并没有绑定到这个函数。相反，名称 triple 绑定到了新定义的 triple 函数上调用 trace 的返回函数值。在代码中，这个装饰器等价于：\n1 2 3 4 \u0026gt;\u0026gt;\u0026gt; def triple(x): return 3 * x \u0026gt;\u0026gt;\u0026gt; triple = trace(triple) #注意这里，最初的triple定义被装饰器更新掉了 注意：函数内的赋值永远只看当前环境帧，也就是第一帧。\n1 2 3 4 5 6 7 def f(x): def g(y): x = y #不会改变f中的x，只会在g的环境中改变 g(4) return x print(f(3)) 递归 注意：只有在需要将递归变成尾递归时，才需要写辅助函数进行递归。\n函数的哲学：作为调用者，只需要关注函数的功能，而不用关心内部的实现，这在递归中很重要。将递归调用视为函数抽象被称为递归信念的飞跃。我们根据函数本身定义函数，但只需要相信更简单的情况在验证函数的正确性时会正确工作。 所以，最好先想清楚，什么情况下进行递归，什么情况下进行当前的操作。\n线性递归 下面看一个例子：\n1 2 3 4 5 6 7 8 def sum_squares(N): \u0026#34;\u0026#34;\u0026#34;Return The sum of K**2 for K from 1 to N\u0026#34;\u0026#34;\u0026#34; if N \u0026lt; 1: return 0 else: #return sum of K**2 for K from 1 to N-1 + N**2 #这里sum_squares(N-1)的功能就是sum of K**2 for K from 1 to N-1 return sum_squares(N-1) + N**2 所有形如sum_squares()的函数功能必须服从Return The sum of K**2 for K from 1 to N这个注释。\n很多时候，我们会将自己代入机器去一行一行分析代码来分析递归，但实际上不要这么做。应该像函数哲学一样，应该依赖于函数文档，而不是每次需要使用一个函数思考函数将如何做它应该做的，并跟踪它。\n防止无限递归：要给一个递归确定一个下界，要让递归的参数（不一定是数值）能够感受到它在”缩短“，并且在到达这个下界时终止。\n异常 可以使用异常来进行防御性编程，来确保函数能做正确的事情。在python中，可以创造一个异常值和用raise引发它。\nassert断言是对raise的外包装，assert False和raise AssertionError()会产生同样的效果。断言错误一般表示发生了非常糟糕的事情。\n当你预期了一个错误可能发生，可以使用try语句来捕获异常。\n1 2 3 4 5 try: input = open(myfile).read() except FileNotFoundError: print(\u0026#34;Warning: could not open\u0026#34;, myfile) input = \u0026#34;\u0026#34; 尾递归是什么？ 首先，我们来回顾一下尾递归。尾递归是指在一个函数的最后一步操作中，返回的表达式就是对自身的递归调用。\n一个非尾递归的例子（Python）：\n1 2 3 4 5 6 def factorial(n): # 最后一步是乘法操作，不是递归调用本身 if n == 1: return 1 else: return n * factorial(n - 1) 在这个例子中，factorial(n-1) 返回后，还要进行一次乘法运算。这导致函数在递归调用返回前，必须保留当前调用的状态（n 的值），并将这些状态保存在调用栈中。当 n 很大时，这会导致栈溢出。\n尾递归的实现和辅助函数 为了将非尾递归转变为尾递归，我们需要将所有状态和中间结果作为参数，在递归调用中传递下去。这就需要引入一个辅助函数 (Helper Function)。\n这个辅助函数通常包含一个额外的参数，用于保存累积的结果 (accumulator)。这样，每次递归调用时，它都会将当前的结果更新并传递给下一次调用，从而使得递归调用成为函数的最后一步。\n一个尾递归的例子（Python 伪代码）：\nPython\n1 2 3 4 5 6 7 8 9 10 11 12 13 def factorial_tail(n): # 主函数，调用辅助函数并提供初始状态 return factorial_helper(n, 1) def factorial_helper(n, accumulator): # 辅助函数，包含了递归逻辑和状态 if n == 1: # 递归的最后一步，直接返回累积的结果 return accumulator else: # 最后一步操作就是对自身的递归调用，没有其他操作 # 将中间结果 n * accumulator 作为参数传递给下一次调用 return factorial_helper(n - 1, n * accumulator) 在上面的例子中，factorial_helper 就是那个辅助函数。它包含了递归的核心逻辑，并用 accumulator 参数来保存中间结果。factorial_tail 主函数则只负责初始化这个过程。\n为什么只有在尾递归时才需要辅助函数？ 管理状态： 尾递归的核心在于将状态作为参数传递。当一个函数需要进行复杂的、带状态的递归时，将累积的状态封装在辅助函数的参数中，比在主函数中处理要清晰得多。主函数（factorial_tail）只定义了“是什么”（求阶乘），而辅助函数（factorial_helper）定义了“如何做”（带状态的递归过程）。 清晰的职责分离： 主函数提供一个简洁、易于使用的外部接口。它对外部调用者隐藏了递归实现的复杂性。调用者只需传入 n，而无需关心 accumulator 的初始值。这种设计模式符合抽象的思想。 语言特性： 在支持尾递归优化的语言（如 Scheme、某些 Haskell 编译器）中，编译器会识别出这种模式，并将其优化为简单的循环，从而避免栈溢出。显式地使用一个辅助函数来构造尾递归，是向编译器或解释器“声明”：“嘿，这是一个可以被优化的尾递归！” 总结 总结以下，写函数的以下步骤：\n先写函数文档，确定函数的定义域和值域，并描述出来。就是输入的范围是什么，我要得到什么样的输出。 描述一个过程，该过程使用简单的步骤从输入计算输出。 写测试文档，进行测试。 进行防御性编程，确定函数正确的输入，对非法输入进行防御。 设计你的函数 不要将所有功能写到一个函数里，也不要重复代码，如果写函数时想到这里需要某个功能，使用函数。\n面向对象 本章聚焦于数据，在计算机中，编程所经常做的一件事是将一个现实世界中的概念使用数据表示出来，对于现实世界的一辆汽车，我们需要思考如何用能够使用的数据来表示。\n使用复合抽象化使我们能够提高程序的模块化程度。将程序中处理数据表示方式的部分与处理数据操作方式的部分分离开来的一般技术是一种强大的设计方法，称为数据抽象化。数据抽象化使程序的设计、维护和修改变得更加容易。\n数据抽象化在性质上类似于函数式抽象。当我们创建函数式抽象时，可以抑制函数实现的细节，并且特定函数本身可以被任何具有相同整体行为的其他函数替换。换句话说，我们可以创建一个抽象，将函数的使用方式与函数实现的细节分离。类似地，数据抽象将复合数据值的使用方式与其构造的细节分离。\n数据抽象化的基本思想是将程序结构化，使其能够处理抽象数据。也就是说，我们的程序应该以这样的方式使用数据，即尽可能少地对数据做出假设。同时，将具体的数据表示定义为程序的独立部分。\n程序的这两个部分，即操作抽象数据的部分和定义具体表示的部分，通过一小组函数连接起来，这些函数根据具体表示实现抽象数据。\n注意：不要违反抽象。\n在 CS 61A 中，违反抽象（Violating Abstraction）是指你在编写程序时，依赖了抽象层内部的实现细节，而不是仅仅依赖其定义的接口或行为契约。这通常会导致代码变得脆弱、难以维护和扩展。\n在 CS 61A 中，这个概念主要体现在 数据抽象 (Data Abstraction) 和 过程抽象 (Procedural Abstraction) 中。\n违反数据抽象 (Violating Data Abstraction)：\n数据抽象的目标是将数据的表示与其使用分离开来。当你定义了一个抽象数据类型 (Abstract Data Type, ADT) 时，你提供了一组操作（构造函数和选择函数），用户只能通过这些操作来创建和访问数据。\n违反数据抽象的行为，就是直接去访问或修改底层数据的具体结构，而不是通过选择函数。\n举个 CS 61A 常见的例子：有理数 (Rational Numbers)。\n假设你定义了一个有理数抽象，它由一个分子和一个分母组成。你可能会像这样实现它（CS 61A 中常用的列表表示）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 数据抽象的构造函数 (Constructor) def make_rational(numer, denom): \u0026#34;\u0026#34;\u0026#34;构造一个有理数 (numer/denom)\u0026#34;\u0026#34;\u0026#34; # 假设这里做了约分等处理 return [numer, denom] # 数据抽象的选择函数 (Selectors) def get_numer(rational): \u0026#34;\u0026#34;\u0026#34;获取有理数的分子\u0026#34;\u0026#34;\u0026#34; return rational[0] def get_denom(rational): \u0026#34;\u0026#34;\u0026#34;获取有理数的分母\u0026#34;\u0026#34;\u0026#34; return rational[1] # 数据抽象的操作 (Operations) def add_rational(r1, r2): \u0026#34;\u0026#34;\u0026#34;添加两个有理数\u0026#34;\u0026#34;\u0026#34; # 这是一个使用选择函数的好例子 new_numer = get_numer(r1) * get_denom(r2) + get_numer(r2) * get_denom(r1) new_denom = get_denom(r1) * get_denom(r2) return make_rational(new_numer, new_denom) 违反数据抽象的例子：\n一个典型的违反数据抽象的行为是，当你需要获取一个有理数的分子时，直接写成 my_rational[0]，而不是使用 get_numer(my_rational)。\n1 2 3 4 5 6 7 8 9 10 r = make_rational(3, 4) # 这是好的行为：通过选择函数访问 numerator = get_numer(r) print(numerator) # 3 # 这是违反抽象的行为：直接访问底层实现细节 # 你在假设有理数就是用一个列表表示的，并且分子是列表的第一个元素 bad_numerator = r[0] print(bad_numerator) # 3 为什么这是违反抽象？\n设想一下，如果未来你决定改变有理数的内部实现方式，比如从列表改为元组，或者用自定义的对象：\n1 2 3 4 5 6 7 8 9 # 新的有理数实现方式 (使用元组) def make_rational_v2(numer, denom): return (numer, denom) def get_numer_v2(rational): return rational[0] # 仍然是索引0，但类型变了 def get_denom_v2(rational): return rational[1] # 仍然是索引1，但类型变了 如果你在代码中处处都使用了 r[0] 来获取分子，那么当你切换到 make_rational_v2 时，所有使用 r[0] 的地方都必须手动修改，这会导致大量的工作和错误。\n但如果你始终使用 get_numer(r)，那么你只需要修改 get_numer 函数内部的实现即可，所有调用 get_numer 的代码都无需改动。这就是抽象的强大之处：它允许你在不影响使用者的前提下改变底层实现。\n违反过程抽象 (Violating Procedural Abstraction)\n过程抽象是指将一系列操作封装成一个独立的函数，并给它一个清晰的、描述性的名称。用户只需要知道这个函数的作用和如何调用它，而不需要了解它内部的具体实现步骤。\n违反过程抽象的行为，就是不依赖函数的契约（它做什么），而是依赖它内部是如何做的。\n例如，如果你有一个 sort_list(my_list) 函数。违反抽象的行为可能是你假设这个函数会使用特定的排序算法（比如快速排序），然后基于这个假设去推断它的时间复杂度或内存使用，而不是仅仅依赖它“将列表排序”这个承诺。\n在 CS 61A 中，更常见的形式可能是：\n复制粘贴代码而不是提取为函数： 如果你发现一段相同的逻辑在多个地方出现，但没有将其封装成一个函数，那么你就是在重复实现，而不是利用过程抽象来重用和简化代码。 不使用已有的抽象： 当一个问题可以用已有的高阶函数（如 map, filter）或你之前定义的抽象数据类型来解决时，却选择重新从头实现细节。 在 CS 61A 中，理解和避免违反抽象是学习如何编写健壮、可维护和可扩展的程序的关键一步。这要求你：\n始终通过定义的接口（构造函数和选择函数）来操作抽象数据，而不是直接访问其内部表示。 信任函数所提供的契约，只关注它做什么，而不去依赖它具体是怎么做的。 这样做，你的代码会变得更加模块化，并且能够更好地应对未来可能发生的改变。\n序列 序列由一堆变量组成，序列有以下几种性质：\n无限或有限 可变或不可变 可索引或不可索引 可迭代 可索引指的是可以使用下标来访问，比如说A[1]这种。而不是所有序列都是可索引的，也可以是可迭代的，可以依次取序列中的每个元素后再来处理。 python的序列：\n元组tuple 列表list 字符串string range() iterator迭代器 generator生成器 选择：通过索引提取序列中的某个元素，python的所有序列都是可索引的。 切片：从一个序列中去除一部分创建一个新的序列。\n有时候，我们会发现一个函数返回了一个元组，为什么？这样可以进行连续赋值。x,y = (1, 9)，等号右边一定是一个序列，并序列中的元素数量必须和左边列出来的一样。获得这样的元组列表的一个方法是zip()。zip()像一个拉链一样把两个列表的元组对应位置组合起来。\n1 2 \u0026gt;\u0026gt;\u0026gt; list(zip([1,2,5,6],[6,3,7,1])) [(1,6), (2,3), (5,7), (6,1)] 注意：zip()返回的是序列，一个生成器。\n列表 列表是可变序列，有很多奇特的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026gt;\u0026gt;\u0026gt; L [1, 9, 8, 4, 5] \u0026gt;\u0026gt;\u0026gt; L[2:4] = [] #delete \u0026gt;\u0026gt;\u0026gt; L [1, 9, 5] \u0026gt;\u0026gt;\u0026gt; L[1:1] = [2,3,4,5] #in idx 1 but contain 1,insert a list \u0026gt;\u0026gt;\u0026gt; L [1, 2, 3, 4, 5, 9, 5] \u0026gt;\u0026gt;\u0026gt; L[len(L) : ] = [10, 11] #append a list \u0026gt;\u0026gt;\u0026gt; L [1, 2, 3, 4, 5, 9, 5, 10, 11] \u0026gt;\u0026gt;\u0026gt; L[0:0] = range(-3,0) #prepending \u0026gt;\u0026gt;\u0026gt; L [-3, -2, -1, 1, 2, 3, 4, 5, 9, 5, 10, 11] 注意到一个python特性，正交性，也就是最后的那个例子，任何序列可以在赋值右边使用，能把两个合理的特性放在一起使用。\n**列表解析式：[\u0026lt;expression\u0026gt; for \u0026lt;var\u0026gt; in \u0026lt;sequence expression\u0026gt; if \u0026lt;boolean expression\u0026gt; ]。一个在列表中的表达式语法，用来生成一个列表。\n非序列抽象数据类型 字典 字典是键值对的可变映射。\n字典的规则：\n键不能是可变类型，键必须是不可变类型。 所有键必须不一样。每个键只能有一个值。 值可以是任意类型。 迭代字典：有很多种迭代字典的方法。\n将字典看作列表进行迭代。\n1 2 3 4 5 6 7 8 insects = {\u0026#34;spiders\u0026#34;: 8, \u0026#34;centipedes\u0026#34;: 100, \u0026#34;bees\u0026#34;: 6} for name in insects: print(insects[name]) #按照被加入字典的顺序进行迭代 #与下面等价 for name in list(insects): print(insects[name]) #按照被加入字典的顺序进行迭代 1 2 3 \u0026gt;\u0026gt;\u0026gt; insects = {\u0026#34;spiders\u0026#34;: 8, \u0026#34;centipedes\u0026#34;: 100, \u0026#34;bees\u0026#34;: 6} \u0026gt;\u0026gt;\u0026gt; list(insects) [\u0026#39;spiders\u0026#39;, \u0026#39;centipedes\u0026#39;, \u0026#39;bees\u0026#39;] 突变 非破坏性操作和破坏性操作：一个操作作用到一个对象上，如果没有改变这个对象那就是非破坏性的，如果改变了，这个对象在某个程度上发生了变化，那就是破坏性的。\n可变性和不可变性：不可变值是一旦创建就不会改变的，可变值相反，注意可变值是能够原地改变，如果要改变不可变值，一般是重新创建一个改变后的对象，而原来的仍不变。\n区分：list.append()和list.extend()方法并不相同。append只添加一个元素，而且将这个元素作为整体添加进去，但extend参数是一个可迭代的对象，将多个这种对象迭代添加。\n1 2 3 4 5 6 7 s = [2,3] t = [5, 6] s.append(4) s.append(t) s.extend(4) #error s.extend(t) 对象的同一性和内容的相等 同一性：就是同一个对象，exp0 is exp1得到真值，说明这两个是同一个对象。 相等性：exp0 == exp1，得到真值说明这两个表达式或者说对象有相同的值。\n在没有特定的理由的情况下，使用is来替换==是有风险的。在数字和字符串这种不可变的对象中使用is可能会造成意想不到的结果，python有时候会优化内存，所以不要在数字和字符串中使用is。\n作用域 python中不能允许函数重新赋值全局作用域中的名字。\n1 2 3 4 5 6 7 8 current = 0 def count(): #global current current = current + 1 print(\u0026#34;Count:\u0026#34;, current) count() count() 这里代码错误的原因是，在局部作用域中使用了一个未赋值的变量。python在看到创建局部的新current变量，那么就不会向上层作用域查找变量，而current未赋值又被引用了，所以出现错误。\n我们可以使用global关键字明确让python重新赋值全局变量。但是在函数中使用全局变量并不好，我们要尽量避免，会产生副作用。应该做的是将全局变量作为参数传递给函数。尽量避免使用global和nonglobal关键字。\n迭代器 迭代器是能够逐个访问值的对象。我们可以使用迭代器来遍历可迭代对象的结果。\n1 2 toppings = [\u0026#34;\u0026#34;,\u0026#34;\u0026#34;,\u0026#34;\u0026#34;] topperator = iter(toppings) toppings是一个可迭代对象，对它使用iter()就可以获得一个迭代器。next()是一个全局内建函数，对迭代器使用会得到序列中的下一个元素。一旦没有元素剩下的情况，对迭代器使用next()会得到StopIteration的异常。\n如何知道一个对象是否是可迭代的？ 可以查看这个对象是否有__iter__方法和__next__方法。\n对于一个通用的迭代器，使用while循环并捕获迭代结束的异常。\n1 2 3 4 5 6 7 8 9 ranked_chocolates = (\u0026#34;Dark\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;White\u0026#34;) chocolaterator = iter(ranked_chocolates) #iter()实际上调用ranked_chocolates.__iter__()方法 try: while True: choce = next(chocolaterator) print(choce) except StopIteration: print(\u0026#34;No more left!\u0026#34;) 但实际上，下面我们通常使用的for循环来进行迭代是一个语法糖，实际上就是上面的while循环。\n1 2 3 ranked_chocolates = (\u0026#34;Dark\u0026#34;, \u0026#34;milk\u0026#34;, \u0026#34;White\u0026#34;) for chocolate in ranked_chocolates: print(chocolate) 一些返回迭代器的函数：\nreversed(sequence)以相反的顺序迭代。 zip(*iterables)像拉链一样将每个列表对应位置的相关元素组合在一起。 map(func, iterable, ···)为迭代器中的每个对象调用func。和列表解析式的功能基本相同。 filter(func, iterable)过滤迭代器，看是否满足func的要求。和[x for x in iterable if func(x)]功能一样。 在迭代器下面改变可迭代对象是危险的。\n生成器 生成器是能够从生成器函数中产生的迭代器。在生成器函数中惰性生成值。通过yield来生成一个值，在给出yield之后暂停函数，然后再重新启动函数。\n1 2 3 4 5 def evens(): num = 0 while num \u0026lt; 10: yield num num += 2 为什么要生成器？ 因为生成器很懒，在碰到处理大量输入的时候，这是非常有用的，只有在需要时才会生成下一项。\nyield from是一个语法糖。等价于\n1 2 3 4 5 6 7 8 9 def a_then_b(a, b): for item in a: yield item for item in b: yield item def a_then_b(a, b): yield from a yield from b yield from 的作用就是简化这种“在生成器内部迭代另一个生成器并逐个产生值”的模式。 它本质上是做了三件事：\n自动迭代子生成器： 它会迭代 yield from 后面跟着的表达式（称为子迭代器或 subiterator），并把子迭代器产生的所有值直接传递给 yield from 所在的生成器的调用者（称为调用者或 caller）。\n传递 send() 方法的值： 如果调用者通过 send() 方法向委托生成器发送了值，这些值会直接传递给子迭代器。\n处理异常和 return 值： 如果子迭代器抛出了异常，这个异常会传递给委托生成器。如果子迭代器通过 return 返回了一个值（在生成器中 return 语句会引发 StopIteration 异常，并将返回值作为 StopIteration 的 value 属性），这个值会被 yield from 表达式捕获。\n面向对象编程 类是定义新数据类型的模板，类的实例称为对象。面向对象编程将数据和动作结合在一起形成对象。每个对象拥有的函数属性就是方法。\n注意一下，python的创建类属性和C++的不一样，python直接在__init__()方法中创建并且初始化属性。类方法第一个参数都是self，也就是对象本身。一个绑定方法绑定了函数和调用这个函数的对象。 class_name(args)为构造函数，调用会构造一个新对象，会调用类的__init__()方法，新对象是init方法的第一个参数。 在不是__init__()函数的类方法中声明类属性也可以。\n类变量：这是在类中而不是在方法中的赋值，那么对于某个对象来说，这个变量不在实例中，而在类中，访问某个实例的类变量会向上查找，看是否是实例中的成员变量，如果不是，就去类变量中查找。主要用于让一些对象共享某一点。当一个子类继承自一个父类时，它会自动获得父类的所有属性和方法，这包括类变量。 这意味着子类和其实例可以通过点运算符 (.) 直接访问父类中定义的类变量，就好像这些变量是它们自己定义的一样。如果直接通过子类名来修改继承的类变量，Python 不会修改父类中的原始类变量。相反，它会在子类中创建（或覆盖）一个同名的新类变量，从而遮蔽 (shadow) 或隐藏了父类的同名变量。其他兄弟子类或父类自身不受影响。 如果通过实例尝试修改类变量，Python 会在该实例上创建一个同名的实例变量。这个实例变量会遮蔽类变量，意味着后续通过该实例访问同名属性时，会优先找到实例变量。这不会影响类变量本身，也不会影响其他实例。\npython对于属性的访问非常随意，可以任意访问属性，甚至使用一个不存在的属性会自动创建它，所以使用_声明希望这个变量是私有的，但是python依旧允许使用，只不过把自觉性交给程序员自己。\n格式化字符串：f\u0026quot;We have {self._inventory} bars。可以直接在括号中引用变量。\n继承 继承的主要概念不多说了，主要记录一下python中的特性。 有时候在子类中重构方法时，仍需要调用父类的方法，可以使用super()。\n1 2 3 super().eat(food) #这两个等价 Animal.eat(self, food) #Animal是当前的父类 调用超类的函数通常在__init__()中常使用。\npython中可以进行多重继承，也就是一个类继承多个父类，但是不推荐这样做，这样的话，继承关系会变得非常复杂，重写方法要非常小心。\n组合 指的是对象由其他对象组成，说白了就是一个对象实例中有很多其他对象实例，一个对象的属性是别的对象。拥有多个相同方法的对象的好处是，可以用相同的方法处理这些对象，实际上，可以对一大堆子类调用同一个函数，即使他们不是同一个类。\n继承是is-a的关系，组合式has-a的关系。\ndir()函数返回一个对象所拥有的所有属性列表。 __repr__() 的主要目标是为开发者提供一个清晰、无歧义的对象表示。它的返回值通常是一个字符串，该字符串描述了创建对象的代码，该字符串如果作为 Python 代码被执行，能够重新创建出该对象（或至少是一个等价的对象）。使用eval()对__repr__()函数的返回值求值，会执行创建出此对象。\n在python中时常出现不确定是否一个对象有没有某个方法的情况，可以使用getattr(bunny, \u0026quot;ears_hang_low\u0026quot;, False)函数来确定，如果没有，会返回第三个参数的默认值。hasattr()可以检查是否一个对象有某个属性。 getattr和.运算符实际上都在背后调用了__getattr__方法。\n在类内部的方法中，给属性赋值通常不会触发__setattr__方法，而会触发__getattribute__方法。这是因为在方法中，属性赋值操作实际上是对属性进行访问，然后调用属性的__set__方法来完成赋值过程。\npython的列表实现是动态数组，内存连续的存储方式，但为什么python允许使用混合元素类型的列表？ 因为事实上python没有存储值，存储的是对象的引用，理解为箭头。 递归处理链表的一般模式是：基本情况是空链表，递归情况是通过处理rest来分解。\n上面的记忆化需要确定他们发生的顺序，可以提前做好，不需要提前测试以确保一切都是可用的，以固定的顺序提前计算之后查表。 泛型 如果能传递不同类型的参数，并从中得到相同功能的结果，那就是泛型函数。python提供了非常多的方法让我们可以在python中用泛型语法自定义类，它鼓励你把所有的对象变成像鸭子一样的东西。 鸭子类型，如果一个东西行为像鸭子，叫起来也像鸭子，那么就可以把它当作鸭子运行。 鸭子测试：去测试一个对象的行为而不是类型，被称为鸭子测试。\n总结 多态性：\n一个函数可以运行在不同类的对象上。 鸭子类型，一个通用性的函数能够运行在任何具有特定行为方式的对象上。 类型强制转换，一个函数可以转换参数来达到自己想要的类型。 类型分派，函数检查参数类型来选择正确的行为。 Scheme 函数式编程只用“表达式”，不用“语句”。\n“表达式”（expression）是一个单纯的运算过程，总是有返回值；“语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。\n原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。\n当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。\nScheme是一门早期的编程语言Lisp的一个方言，对于一个语言，必须了解这种编程语言操纵的值是什么，将Scheme数据分为两种，一种原子数据和一种是对数据。 Lisp早期是用来处理符号数据的， 这门语言有一个非常有意思的特性：Scheme程序就是Scheme数据，这意味着在执行Scheme程序是特别容易。 这些程序的基本情况是所有的原子值，大部分的list代表了Scheme程序中的函数调用。\nScheme 语言基础 这一部分介绍了 Scheme 这种函数式编程语言的基本语法和特性，与 Python 形成了对比：\nLisp 方言： Scheme 是 Lisp 家族的一员，其核心特点是极简的语法和同像性（homoiconicity），即代码和数据结构（列表）有着相同的表示形式。 前缀表示法： 所有操作符都放在操作数前面，并用括号括起来。例如，( + 2 3 )。 S-表达式： Scheme 程序由 S-表达式（S-expressions）构成，它们可以是原子（数字、符号）或列表（嵌套的 S-表达式）。 特殊形式 (Special Forms)： 区别于普通函数调用，特殊形式在求值时有独特的规则，例如 if、define、lambda 等。它们不先求值所有参数。 求值规则 (Evaluation Rules)： 强调 Scheme 的求值模型，包括如何求值基本表达式、组合式（函数调用）、特殊形式等。 高阶函数 (Higher-Order Functions)： Scheme 强调函数是“头等公民”，可以作为参数传递、作为返回值返回，从而实现更抽象和灵活的代码。lambda 表达式用于创建匿名函数。 1. 序列操作与 ADT 这部分关注如何用 Scheme 处理序列数据，并引入了抽象数据类型（Abstract Data Types, ADTs）的概念。\n列表作为基本序列结构： Scheme 中列表是核心的序列数据结构，通过 cons（构造）、car（取头）、cdr（取尾）等基本操作来构建和操作。 递归处理序列： 强调递归是 Scheme 中处理列表和序列的常用且自然的方式。 抽象数据类型 (ADT)： 讲解如何通过选择函数（selectors）和构造函数（constructors）来定义 ADT，从而将数据表示与其使用分离开来。这使得数据结构在底层实现变化时，使用它的代码无需修改。例如，用 cons、car、cdr 来实现一对数据，而用户只通过 make-pair、first、second 来使用。 2. 环境模型与求值过程 这是第三章最核心的部分，深入解释了 Scheme 代码是如何被解释器求值的，特别是关于变量绑定和作用域的规则。\n帧 (Frames) 和环境 (Environments)： 解释器使用环境模型来管理变量绑定。一个环境由一系列帧组成，每个帧是一个从变量名到值的映射。 查找规则： 当查找一个变量的值时，解释器会从当前帧开始，沿着环境链向上查找，直到找到第一个匹配的绑定。 定义 (Definitions) 与赋值 (Assignments)： define 用于创建新的变量绑定或修改当前帧中的现有绑定（如果存在）。 set! 用于修改环境链中已存在的变量绑定。如果没有找到绑定，则报错。 过程应用 (Procedure Application)： 解释函数调用时，会创建一个新的环境帧，其中包含形式参数到实际参数值的绑定，并将这个新帧链接到定义函数时的环境（闭包的概念）。 闭包 (Closures)： 函数在被定义时（而不是被调用时）“记住”它所处的环境。当函数被调用时，它会基于这个记住的环境（而非调用时的环境）来查找非局部变量。这是 Scheme（以及 Python）中词法作用域（Lexical Scoping）的核心。 3. 解释器与元语言抽象 这部分是将前面所有概念串联起来，构建一个简单 Scheme 解释器的概念。\n解释器的结构： 解释器通常包含两个核心部分：\n求值器 (Evaluator)： 负责根据语言的求值规则来计算表达式的值。\n应用器 (Applier)： 负责将过程（函数）应用于它们的参数。\n元语言抽象 (Metalinguistic Abstraction)： 指的是使用一种语言（如 Scheme）来描述或实现另一种语言（或同一语言的一个子集）。通过编写一个 Scheme 解释器，我们不仅理解了 Scheme 语言本身，更理解了语言的本质和解释器的工作原理。这是一种强大的抽象工具。\n计算器 1. 从表达式到结果：解析与求值 计算器部分的核心任务是：给定一个字符串形式的数学表达式（例如 \u0026quot;2 + 3 * 4\u0026quot;），如何让程序理解它并计算出结果？这涉及到两个主要阶段：\n解析 (Parsing)： 将输入的字符串表达式，从人类可读的形式转换成计算机更容易处理的结构化表示，通常是表达式树 (Expression Tree) 或 抽象语法树 (Abstract Syntax Tree, AST)。\n词法分析 (Lexical Analysis / Tokenization)： 原始字符串首先被分解成一系列有意义的“词法单元”或“标记”（Tokens）。例如，\u0026quot;2 + 3 * 4\u0026quot; 会被分解为 2 (数字), + (运算符), 3 (数字), * (运算符), 4 (数字)。在 Scheme 中： 想象一个 Scheme 解释器接收一个字符串，比如 (+ 2 (* 3 4))。词法分析器会把它分解成 (, +, 2, (, *, 3, 4, ), ) 这些独立的符号和数字。\n语法分析 (Syntactic Analysis)： 词法单元流根据预定义的语法规则（例如，运算符优先级、结合性）被组织成一个树形结构，通常是抽象语法树 (Abstract Syntax Tree, AST)。它验证代码是否符合语言的语法规则。对于 \u0026quot;2 + 3 * 4\u0026quot;，其表达式树的根节点会是 +，因为 * 的优先级更高，它会先被计算。在 Scheme 中： Scheme 的 S-表达式天生就是一种抽象语法树的形式。( + 2 ( * 3 4 ) ) 这个 S-表达式本身就已经是一个树形结构。编译器会根据语言的语法规则，将标记流构建成 AST。AST 是程序的一种标准化、结构化的表示，后续的语义分析、优化和代码生成都基于 AST 进行。CS 61A 中的求值器直接操作这种 S-表达式形式的程序结构。\n1 2 3 4 5 + / \\ 2 * / \\ 3 4 语义分析 (Semantic Analysis)：\n作用： 在 AST 的基础上，检查程序的语义正确性（例如，变量是否已定义、类型是否匹配等），并收集类型信息。\n在 Scheme 中： 在 Scheme 解释器中，这部分检查通常与求值过程交织在一起。例如，在查找变量时（环境模型），如果找不到绑定，就会抛出未定义变量的错误。函数调用时，也会检查参数数量是否正确。\n与编译的关系： 编译器在这个阶段会进行各种检查，确保程序的含义是明确和合法的。例如，如果 + 运算符被应用于一个数字和一个列表，编译器会在此时报错（或生成运行时检查）。\n求值 (Evaluation)： 遍历这个表达式树，根据树的结构和节点的含义（数字、运算符），递归地计算出最终的结果。\n对于叶子节点（数字），直接返回其值。\n对于操作符节点，首先递归地求值其子表达式，然后将求得的值应用相应的操作符。\n2. 表达式树 (Expression Tree) 计算器部分会重点讲解如何构建和操作表达式树。\n表示： 在 Python 中，表达式树通常可以用嵌套的列表或自定义类来表示。例如，(‘+’, 2, (‘*’, 3, 4)) 就可以表示上述表达式树。\n作用： 表达式树清晰地表达了运算符的优先级和表达式的结构，使得求值过程变得直接和递归。\n3. 操作符的优先级和结合性 这是解析阶段的关键挑战，决定了表达式树的正确结构：\n优先级 (Precedence)： 不同的操作符有不同的优先级（例如，乘法和除法通常高于加法和减法）。解析器必须知道这一点，才能正确地分组操作。\n结合性 (Associativity)： 当多个相同优先级的操作符连续出现时（例如 2 - 3 - 4 或 2 / 3 / 4），结合性决定了它们的计算顺序（左结合或右结合）。例如，大多数算术运算符都是左结合的，2 - 3 - 4 等同于 (2 - 3) - 4。\n4. 抽象数据类型 (ADT) 与接口 尽管可能没有直接提到“ADT”这个词，但计算器部分无疑在实践中运用了 ADT 的思想：\n分离表示与行为： 你会学习如何定义操作符、数字等抽象概念的接口，而不是直接操作底层的列表索引或字符串。例如，你可能会有 make_operand(value)、is_operator(exp)、operator_name(exp)、operands(exp) 等辅助函数来操作表达式树，而不需要知道它底层是用列表还是其他结构实现的。这使得代码更模块化，更易于理解和维护。 5. 错误处理 一个健壮的计算器还需要考虑如何处理无效的输入：\n语法错误： 例如，括号不匹配、非法字符、运算符使用不当。\n运行时错误： 例如，除数为零。\n通常会通过抛出自定义的异常来指示这些错误。\n好的，我们继续深入 CS 61A 第三章关于 Scheme 语言和解释计算机程序的内容。虽然 CS 61A 的重点是解释器 (Interpreter) 而非完整的编译器，但它确实触及了一些与编译相关的概念，尤其是在语言处理和程序表示的层面。\n5. 语言处理的阶段（广义上的“编译”） 中间代码生成 (Intermediate Code Generation)：\n作用： 将 AST 转换成一种更接近机器语言但仍独立于具体机器的中间表示（例如，三地址码、字节码）。\n在 Scheme 中： CS 61A 的解释器通常不会显式地生成一个独立的中间代码层。它直接操作 S-表达式（作为 AST 的一种形式）并在求值时即时解释执行。然而，Scheme 代码本身就可以看作是一种非常高层的“中间代码”，因为它结构化且接近程序的逻辑。\n与编译的关系： 这是编译器中一个重要的优化点。中间代码可以进行平台无关的优化，提高代码效率。\n代码优化 (Code Optimization)：\n作用： 对中间代码进行各种转换，以提高程序的执行效率（更快、更小）。\n在 Scheme 中： CS 61A 的解释器通常不涉及复杂的代码优化。它更侧重于语言的语义和求值过程的理解。但在现实世界的 Scheme 或 Lisp 实现中，优化是非常重要的，例如尾递归优化 (Tail-Call Optimization, TCO)。\n尾递归优化： 这是函数式语言（特别是 Scheme）编译器或高级解释器的一个关键优化点。如果一个函数的所有递归调用都是尾调用（即递归调用是函数的最后一步操作，其返回值直接作为函数的返回值），那么编译器可以将递归调用转换为迭代，避免栈溢出。CS 61A 会详细解释尾递归的概念，以及它如何让递归成为一种强大的、等同于循环的控制结构。 与编译的关系： 编译器在此阶段尝试使生成的机器代码更高效。\n目标代码生成 (Target Code Generation)：\n作用： 将中间代码翻译成特定目标机器（CPU）的机器码或汇编代码。\n在 Scheme 中： CS 61A 中的解释器直接在运行时求值 S-表达式，不生成机器码。它本身就是用 Python 或 Scheme 实现的“软件 CPU”。\n与编译的关系： 这是编译过程的最终阶段，生成可直接执行的二进制文件。\n总结编译相关内容 尽管 CS 61A 的第三章主要教授的是解释器的工作原理，但它通过 Scheme 的 S-表达式形式、环境模型和求值过程，隐式地触及了编译理论中的几个关键概念：\n程序表示： Scheme 的 S-表达式是程序的一种结构化表示，类似于编译器内部的 AST。\n语义检查： 变量查找、类型匹配等在求值时进行，这与编译器的语义分析阶段类似。\n求值策略： 对于普通组合式和特殊形式的不同求值规则，是所有语言处理的关键。\n尾递归优化： 虽然解释器可能不一定实现所有优化，但尾递归的概念是函数式语言的重要特性，它模糊了编译优化和语言语义之间的界限。\nMacros 实际上，函数和类的定义通过添加命令和数据类型来拓展语言，但语言没办法定义新的控制结构。 许多语言提供了宏。宏可以允许你来去定义一个能够生成程序文本的函数。实际上，调用一个宏函数就是将一段程序文本中的变量进行替换了。 C的宏不作为程序语言的一部分，而是由预处理器来提供的。而Scheme中的宏是语言的一部分，Scheme中，宏不进行参数计算，自动的将返回值作为Scheme表达式并且执行它。Scheme中有一个语法是Quasiquote，能够使列表表达像python中的f字符串。 宏可以帮助实现：如果想要定义一个新的Scheme表达式，以unless开头，能和if来做同样的事情。 宏做的事情，不像函数那样替换值，而是替换变量名。但是宏实际上是一个非常危险的东西，很多情况会出现你无法预料到的结果，小心使用。\n声明式编程 过去接触到的大部分是命令式编程，命令计算机去做什么，而声明式编程是描述结果的特点，把它交给系统去搞清楚怎么去得到结果。核心思想是：你告诉计算机“要实现什么” (what to do)，而不是“如何实现” (how to do it)。\n使用许多基本语句，这些语句是一些基本的逻辑性断言，这些断言指定想要的目标。这些逻辑断言组成了一个断言数据库，说白了就是一个知识库，我们问程序，基于程序现有的知识能否证明一个新的断言是否为真。\n正则表达式 正则表达式是一种声明式编程，处理文本时，可能存在一些特定的模式，根据这些模式来做些什么，比如说找到所有的整数，这时就要进行模式匹配，声明一个模式，让系统去进行匹配。正则表达式说的是，所有匹配正则表达式的字符串的集合。 python有一个库来处理正则表达式，import re，这个库中提供了非常多的方法来处理正则表达式，可以有创造性的来组合。详细参考文档： 正则表达式指南 — Python 3.13.6 文档\n这里记录一下贪婪匹配和惰性匹配，python默认选择贪婪匹配，尽量匹配多的，有时候，我们不希望匹配尽可能多的，希望匹配的越少越好，可以使用惰性模式操作符，*?,*+,??。\nBackus-Naur-Form(BNF) BNF（Backus-Naur Form），中文常译作巴科斯-诺尔范式，是一种元语言符号，主要用于描述计算机语言的语法结构，特别是上下文无关文法（Context-Free Grammar）。它提供了一种精确、形式化且无歧义的方式来定义语言的语法规则。\nBNF的核心概念包括：\n终结符（Terminals）：\n这些是语言中最基本的、不可再分割的符号或词汇，它们是语言的“原子”。 例如，在编程语言中，关键字（如if, else）、运算符（如+, -）、标点符号（如;, (, )）以及具体的标识符（如变量名x、数字123）都属于终结符。 在BNF表示中，终结符通常用双引号\u0026quot;括起来，或者直接写出。 非终结符（Non-terminals）：\n这些是表示语法范畴或语法结构的抽象符号。它们本身不是语言中的实际组成部分，但代表了可以由其他符号（终结符或非终结符）序列替换的“占位符”。 非终结符通常用尖括号\u0026lt; \u0026gt;括起来，例如\u0026lt;expression\u0026gt;（表达式）、\u0026lt;statement\u0026gt;（语句）、\u0026lt;digit\u0026gt;（数字）等。 每个非终结符都会有一个或多个生产规则来定义它可能由什么构成。 生产规则（Production Rules）：\n这是BNF的核心。一个生产规则定义了一个非终结符可以被替换或“展开”成什么样的符号序列。 规则的一般形式是：\u0026lt;非终结符\u0026gt; ::= 定义 ::= 符号表示“被定义为”或“可以由……替换”。 选择（Alternatives）：\n管道符 | 用于分隔一个非终结符的多种可能定义。这意味着该非终结符可以被定义为管道符左边的一种形式，也可以是右边的一种形式。 例如：\u0026lt;digit\u0026gt; ::= \u0026quot;0\u0026quot; | \u0026quot;1\u0026quot; | \u0026quot;2\u0026quot; | \u0026quot;3\u0026quot; | \u0026quot;4\u0026quot; | \u0026quot;5\u0026quot; | \u0026quot;6\u0026quot; | \u0026quot;7\u0026quot; | \u0026quot;8\u0026quot; | \u0026quot;9\u0026quot; 表示一个\u0026lt;digit\u0026gt;可以是\u0026quot;0\u0026quot;，也可以是\u0026quot;1\u0026quot;，以此类推。 连接（Concatenation）：\n在定义中，将符号（终结符或非终结符）并列写在一起表示它们按顺序连接。 例如：\u0026lt;number\u0026gt; ::= \u0026lt;digit\u0026gt;\u0026lt;number\u0026gt; | \u0026lt;digit\u0026gt;，这里的\u0026lt;digit\u0026gt;\u0026lt;number\u0026gt;表示一个数字后面跟着另一个数字序列。 BNF的简单例子：一个整数的定义\n假设我们想用BNF定义一个简单的整数，它由一个或多个数字组成。\n1 2 \u0026lt;integer\u0026gt; ::= \u0026lt;digit\u0026gt; | \u0026lt;digit\u0026gt;\u0026lt;integer\u0026gt; \u0026lt;digit\u0026gt; ::= \u0026#34;0\u0026#34; | \u0026#34;1\u0026#34; | \u0026#34;2\u0026#34; | \u0026#34;3\u0026#34; | \u0026#34;4\u0026#34; | \u0026#34;5\u0026#34; | \u0026#34;6\u0026#34; | \u0026#34;7\u0026#34; | \u0026#34;8\u0026#34; | \u0026#34;9\u0026#34; 解释： \u0026lt;digit\u0026gt;是一个非终结符，定义它是一个具体的0到9的数字字符（这些是终结符）。 \u0026lt;integer\u0026gt;是一个非终结符，它有两种可能的定义： 它可以仅仅是一个\u0026lt;digit\u0026gt;（例如\u0026quot;5\u0026quot;）。 它可以是一个\u0026lt;digit\u0026gt;后面跟着另一个\u0026lt;integer\u0026gt;（例如\u0026quot;1\u0026quot;后面跟着\u0026quot;23\u0026quot;，构成\u0026quot;123\u0026quot;）。这种递归的定义方式使得我们可以表示任意长度的整数。 BNF的应用：\n编程语言设计和规范： BNF是描述编程语言（如Java、C++、Python等）语法的标准方法。它的形式化描述有助于消除歧义，并作为语言实现的蓝图。 编译器和解释器： 编译器和解释器的语法分析器（Parser）就是基于语言的BNF（或EBNF）规则来构建的。 协议和数据格式： 常用于描述网络协议、文件格式或数据交换格式的结构。 文档： 作为语言或系统精确的语法参考文档。 BNF与EBNF（Extended Backus-Naur Form）的区别：\nEBNF 是 BNF 的扩展，引入了一些更简洁的符号来表示常见的语法模式，例如：\n[]：表示可选元素（出现0次或1次）。 {}：表示重复元素（出现0次或多次）。 ()：用于分组。 EBNF 使得语法定义更加紧凑和易读，但在表达能力上与 BNF 是等价的。\n","date":"2025-08-11T00:00:00Z","image":"https://oldlay.github.io/p/cs61a/Lambda.svg","permalink":"https://oldlay.github.io/p/cs61a/","title":"CS61A"},{"content":"哲学与人生 所以，有生之年，或者说余生，我会始终直面虚无主义的难题。\n讨论哲学是什么的时候，解答是由终极关怀的问题所引发的对于人生所能通达的最高理想的一种追求。但哲学家们对于这个问题的解答，通过认识宇宙和自然来认识人生就引发了一系列的问题，像滚雪球一样越滚越大，反而最初的问题看不见了。 哲学是时代精神的精华，在近代哲学确实如此，但在如今，学科制度化后，哲学学科技术含量与复杂程度越来越高，但是对社会的影响却越来越小。 哲学家在苏格拉底眼里的作用是启发人们思考，让人们认识自己。哲学要发挥作用，必须要通过每个人思想的理解才能发挥作用。 广义的人生哲学=人生观 哲学其实不是解决具体问题的方法，哲学其实是一种人生态度。提升人的境界，让你面对更多的问题， 哲学不能代替你回答问题，而是要你去面对问题，在发现问题是，哲学会给你提供各种可能性，需要的是我们去面对这些可能方式，去选择我们自己的方式，学哲学不是要找一个老师，而是找的一个对话伙伴。 如果说人的本质被发现了，终极真理被发现了，那么人只用按照既定的模式去活，而人生没有终极答案，魅力恰恰在于此，人生是开放的，没有继承的公式，我们面对的永远是明天和未来。所谓人生观无非是让你站到一定的高度来看待自己的人生。\n人生的意义 这是个活了一辈子都不见得解决的问题，活到老想到老的问题。人有了智慧意识到人的生死，某种意义上说，人生的意义恰恰在于人生的有限性。因为有限性，我们才会面对选择时取舍。 人生在世，一般两个问题：\n如何活，如何活得更好？ 为什么活？ 为什么活 = 人生的意义 实际上，这个世界就是没有意义的，盲目的，但人却需要一个意义来作为生存的根基。 人生之所以需要有意义，源于人类对于虚无主义的恐惧。 尼采：虚无主义就是绝对价值的丧失 对于人生的意义，存在两种思路：\n一种思路认为人生有某种客观存在的意义，我们可以认识人生的意义然后按照它去生活。 另一种思路则质疑人生的意义，认为人生的意义是我们自己赋予人生的。 以往的哲学更多的会体现为以看待宇宙万物的方式来看待人的时候，也把人看作像物一样有某种先在的本质，按照人的本质去做。但在19世纪下半叶西方哲学发生转向，人生的意义是自己赋予自己人生的。 质疑人生的意义使人类又走入了一个困境。人生的意义在哪？面对未知，充满危险的社会，人类如何确定人生的意义？因为人以意义而活为根基，那么人生就是一场冒险，没有回头路。这也就是人经常会放弃对自己意义的追问，放弃对人生意义的这种创造性的这样一种活动，逃避这些问题，按照一种本能的方式生活。 虚无主义在19世纪下半叶对西方人的影响非常大，陀思妥耶夫斯基的群魔说这个世界是丑恶的，所以应该有一个惩恶扬善的上帝，但我又没办法证明上帝的存在，我除了自杀还有什么出路？这也就是科学高歌猛进带来的结果。我不信上帝，如果世界没有上帝，善恶是非黑白曲直是模糊的，相对的，没有规则，那么人生的意义何在？ 物质条件在改善，但人的精神方面并没有得到改善，现代中国人需要转变思考方式。我们不要以为带有绝对真理和某种道德律条，所有人能按照这种人生观去做，这是我们过去这种道德的伦理学方面的失败，没有人有资格教育别人，这些问题是永恒没有答案的，没有人有这个权利能强加给所有人如何必须去做，需要我们每个人自觉地去思考。 萨特，在《存在主义是一种人道主义》，没有上帝人就没有本质，人的本质是由人自己赋予自己的，他在强调人的本性在于自由，自由就在于筹划和选择，无论如何政论自由是否存在，自由都是人生之为人生的前提条件，当自由真的落在每个人的身上时，只会感到负担，因为需要自己在诸多可能性中去筹划选择，而且必须为你的选择负责，那你必须承担这种选择最后带来的后果。这就造就了20世纪人一讲到自由就逃避自由。\n必然和自由的关系 命运——必然性——规律 当希腊人不满足于神话以命运来解释世界时，希望能够去认识自然， 哲学思考诞生，但希腊人只到必然性，还没有到自由。 科学描述世界，哲学解释世界的意义。而描述自然不可能获得自由。\n人生必须以自由为前提条件，但自由的实现是有条件的。 人之所以“与众不同”，是被抛入可能性的境域之中，我们是面对可能性塑造自己的人生，人生不是完全由必然性构成的过程，虽然存在因果链条，但不同阶段的选择是可变的。由于人的思维有很强的惰性，乐意于去将一切看作是必然的，但是对人生不能这么看，的确你的选择会有其后果，但是你的选择是可以改变后果的。 人是作为个体的自我而存在，人是以个体化的完善作为很大的标志，人类社会的发展也是个体性的越成熟越完善，越标志这个社会的发展，人的社会进化伴随着个体的完善，来打破原来有的那个社会规范。传统维系着这个社会的存在，但是到了一定的程度，传统就成了阻碍社会发展的，随着个体性的完善觉醒，去冲破传统的尖钉，然后重新开始变革。那就意味着我们每个人可以作为一个自我的存在。 海德格尔在《存在与时间》中，问我是谁？在现实中，我们每个人不是作为我自己，而是作为大家而生存的，在某种意义上，我们都是以大家作为榜样，向大家向公众看齐，甚至我们追求个性化是因为大家追求个性化，从某种意义上说大家拿走了我们的存在，替我们去做选择，不是我而是大家在主持着我们每个人的人生。在现实生活中，人完全是可以按照大家去生活的，但大家是谁？我们把存在交给大家时，一旦选择出现问题需要承担后果时，是找不到大家的。实际上每个人都是大家，但在谈论大家时是把自己剥离出去了，按大家去做的时候是逃避人生的责任。 我们应该意识到我就是大家，我们每个人都是大家，我们才能是我们人生的主人，才以一种负责任的方式去展开人生。自由是生命不可承受之轻，当人要做出自由的选择时，会逃避自己的自由抉择，选择安全感的大家。\n假如明天不再来临 为什么会逃避自由？归根结底是逃避死亡。中国人的世俗的生死观是个很奇怪的现象，死亡禁忌。只谈论生的事情，不谈论死的事情，按照习惯的方式生存，当终有一天问题来临时，恍然大悟去发问：我这个问题怎么没早想它？后悔说不会再这样庸庸碌碌的度过一生，可惜回不去了。 某种意义上说，逃避死亡的思考也是在逃避对生的思考，没有充分意识到人生的有限性，怎么在这只此一生的人生中过的有意义？\n死亡是人之最本己的、无所关联的、确知的而不确定的、超不过的可能性。——海德格尔\n如果可以，去看看临终人的那种感觉，看看他的眼神，只有那个时候才叫真正的无奈。\n而死亡是一种真正的可能性，随时可能发生，且不可避免。海德格尔强调提前到死中去，向死而在，置之死地而后生。不要庸庸碌碌，前怕狼后怕虎，人都要面临终有一死，有什么事情是我不能去做的呢，不能去尝试不能去实现自己的？ 这两种区别，代表的是两种时间观：向后看的时间观和向前看的时间观。始终面对死亡筹划选择自己的人生，恰恰让你以未来作为指规的死亡观。来来去去了无牵挂，而中间恰恰是有牵挂的人生，何不去牵挂一把。自己要达到自我完善，实现自己的程度，这就足够。 人总想着会有明天，会有希望，明天会更好，但考虑死亡时，终有一天会没有明天，明天是有限的，绝不是无限的。如果明天不再来临，怎么相信明天会更好？\n人生的境界 以前的过去了就过去了，我们面对的是现在和明天。与其延长人生的长度，不如加厚人生的厚度，在不同的领域看世界的角度不一样，所谓人生在于超越自我，在于它在自我之中超越自己，提升人的人生境界。不要奢望说事业做多大多完满，关键在于找到对你最有意义的事情去做。 找到自我、超越自我 首先是个自觉的过程，其次是个超越的过程，不断提升自己的人生境界。哲学所能提供的是，不可能让生命达到无限的高度，但可让思想在思考宇宙万物的时候与宇宙万物的东西融为一体，所达到喜悦。朝闻道，夕死可矣。亚里士多德的神学在哲学上提供了一种面对终极关怀的方式，哲学的最高层次就是人的思想对宇宙的理性的思考，当你去思考神圣理性的时候，你的理性和宇宙的理性融为一体，去分享对象的生命，达到了人生最高的境界。 对于信仰，信仰某个宗教是一场豪赌，信对了那就赚了，信错了那是以人生为赌注，赌上一生来信仰有上帝的存在，有来生来世。 对于我们自觉人生来说，不能把赌注放在来生来世，我们就是在人生之中，在当下，在人生之中不断的超越自己，人生虽然有限，但他是开放的，可能性是无穷尽的，只不过是去选择有限的可能性而已。可以把人生看作是始终向着未来，哪怕走到人生的最后一步，仍然在朝向着未来。\n回到苏格拉底，哲学的确不应该说教，不应该给大家提供一种所谓规范的世界观和人生观，应该启发人们思考。哲学史中莫衷一是，每个哲学家都有道理，学哲学史的好处就在这里，你不再迷信，它让你树立一种问题意识和批判意识。\n","date":"2025-06-21T15:06:22+08:00","image":"https://oldlay.github.io/p/life/picture_hu_ff576cd71161c65c.png","permalink":"https://oldlay.github.io/p/life/","title":"西方哲学史 哲学与人生"},{"content":"近代哲学 新时代的曙光：\n世界的发现 —— 大航海时代 人的发现 —— 文艺复兴和宗教改革 科学的发现 —— 哥白尼革命、牛顿力学 改造自然为人类谋福利的观念兴起，使得自然科学飞速发展。 早期近代哲学：经验论和唯理论（笛卡尔） 一般以笛卡尔作为近代哲学的开端者\n主体性的觉醒——两希传统碰撞中的近代哲学 雅典：希腊文明 耶路撒冷：希伯来文明 希腊哲学重视经验的自然主义和科学精神 基督教哲学重视超验性的形而上学\n这些基础就构成了现代哲学在自我意识、主体性的基础上的一些基本主题。也就是意味着，近代哲学不仅关注自然科学的问题，形成了比较系统的认识论和自然哲学的理论，而且也关注超越性的本体论的问题。 这个时期的很多哲学家同时是基督徒，受到基督教的影响更多的体现在形而上学上，但他们心中的上帝不是基督教的那个人格神，更多的体现为一种形而上学的终极原因和存在。\n这时的哲学家不断尝试使哲学成为科学 哲学的科学性如何体现？——通过体系性来体现 科学家尽可能的在描述我们面对的这个世界，但哲学家往往更希望给出一个理想的宇宙模型。\n文艺复兴使得理性衰落，而科学知识的发展使得人们重新树立起了对理性的信心。 科学知识的发展也给哲学家提出很多问题： 科学之为科学它的普遍必然性和科学性究竟根据何在？于是形成了经验论和唯理论之争。——围绕着认识论的问题。\n近代哲学的精神：启蒙主义 启蒙最根本的核心，就是讲理性和自由，让理性成为人的主导和世界的主导，将理性作为最高的权威来取代那个神学的权威。 启蒙主义三大敌人：\n封建专制制度 宗教迷信 愚昧落后 经验论与唯理论 经验与理性之争自古有之，柏拉图的两个世界使得经验和理性分离对立。但在当时实际上与科学发展密不可分，地心说建立在经验之上，而日心说建立在理性之上。\n唯理论 笛卡尔 整个近代哲学的自我意识原则、主体性原则由笛卡尔这开始。 经院哲学衰落，自然科学发展，而哲学百废待兴，于是笛卡尔肩负恢复理性地位，重建形而上学的基础，为整个人类知识大厦重新奠定基础的任务。 笛卡尔的思想：\n方法论 天赋观念 方法论 笛卡尔非常推崇几何学，而欧几里得的几何学从几条公理和定义诞生了几百个命题，是一个严密的演绎科学的体系。只要接受他的定义和公理，那么它的每一个命题都是无懈可击的真理。笛卡尔使用这个方法来构建哲学体系，找到第一原理，然后严格按照逻辑推演，就能推演出人类知识的整个大厦。 近代科学的发展，数学的演绎科学公理化体系的模型起了非常大的作用，任何一个理论科学一定带有这样一种公理化系统。\n笛卡尔并不排斥形式逻辑，但：“旧逻辑只能用来推理分析已知的知识而不能获得新知识。几何学方法能够推演出新知识来但却只研究抽象的符号，而不研究知识。” 笛卡尔认为他的理性演绎法，包括理性和演绎两个部分。 理性：理智直观。方法自身不能给出大前提，需要理性自身提供第一原理，笛卡尔称它为理智直观。\n笛卡尔要求哲学的基本原理必须满足两个条件：\n它们必须是明白而清晰的，人心在注意思考它们时，一定不能怀疑它们的真理； 我们关于别的事物方面所有的知识一定是完全依赖那些原理，可以单独研究原理，但没有原理无法了解事物。这个哲学原理是所有一切东西的前提。 这样的一个通过理智直观去找到的基本原理笛卡尔称为——天赋观念 天赋观念 根据观念的来源，分为三类：“天赋的”、“从外面来的”和“自己制造出来的”。 这三类观念对应着三种心理功能，外来的观念依赖于感觉，虚构的观念借助于想象，而天赋观念则出于纯粹的理智。 天赋观念在笛卡尔这里是一种先验的客观。\n笛卡尔提出了一种方法论上的怀疑，是一种怀疑方法，区别于怀疑论（以怀疑为目的），是一种以怀疑为方法，找到无可置疑的东西。 笛卡尔认为必须将自己心中一切信以为真且值得怀疑的东西全部清除出去，再从根本上重新开始，找到不容置疑的。\n构成笛卡尔形而上学体系的原理：\n我思故我在 上帝存在 物质世界存在 形而上学 我思故我在 笛卡尔的形而上学的第一原理。\n笛卡尔认为：\n感觉经验是不可靠的 梦境中的一切是不可靠的 所有形象都可能是梦境中的东西 数学也是可以怀疑的 上帝的存在也是可疑的 但有一点确实无可置疑的，那就是“我在怀疑本身。”否定了一切，就只剩下怀疑了。\n怀疑毕竟是个思想活动，是思想者在思想，于是得出了“我思故我在。”这样的命题。笛卡尔想说的是，思想是我的本质，我思想我就知道我是如何起作用的，我不思想我就不知道有我，不起作用了。我们不可能设想我们没有思想。\n“我思故我在”这个命题构成了整个近代哲学的开端。\n“我”是一个心灵实体，这个心灵实体的本质乃是“思想”。\n在笛卡尔时代，通过怀疑为哲学寻找无可置疑的基点，可能是唯一可行的策略。 在知识真假难辨的情况下，任何肯定的具有知识内容的判断，都无法确证自身的合理性，只能通过否定的方法。\n\u0026ldquo;我思故我在\u0026quot;是笛卡尔哲学体系中无可置疑的第一原理，笛卡尔由此确立了理性的地位。 即使我无法确证我知识是否真假，但我却可以确定一点，它们都是我的知识，以我为前提。也就是说我现在确立的是构成知识的一个逻辑前提，也就是一切知识一定以一个主体为前提。这也就是主体性的觉醒\n笛卡尔通过怀疑方法确立我思的过程，亦即通过否定性的方式，排除知识内容，最终剩下抽象一般的认识主体的过程，也就是确立主体性的过程。\n上帝证明和物质世界存在 “我们通过怀疑的方式确立了我思故我在，但是除此之外我们没有肯定任何东西。 在我的思想中有一个无限完满的上帝的概念。 我肯定不是上帝概念的原因，它一定另有原因。由此我们只能说，在我们之外，有一个无限完满的心灵，它把这种观念赋予我的心灵，所以我有上帝的观念。 就上帝这一表征着最完满的存在的观念而论，显然我不可能是它的原因，它只能源于一个更加完满的本性。所以，我们只能说有一个比我更加完满的存在将这个观念放进我的心灵之中，这个完满的存在就是上帝。 简单来讲，我是有限的，而上帝概念是无限的。 因为欺骗和谬误这些非实在的东西与上帝这样一个绝对实在的完满属性不相符合。如果上帝给予我们的认识能力是贻误人生的，他使我们认假为真，那他就是一个骗子。 现在，我们知道上帝是完满的，因而不可能欺骗我们，于是我们最大的怀疑便连根铲除了。这就是说，由于确信上帝的实在性和完满性，我现在也确信物质世界的存在。“\n而如果上帝存在能够证明，那我们对这个世界最大的怀疑，这个世界根本就不存在，那就可以烟消云散了。\n所以实际上是曲线救国的证明，由于怀疑，无法直接证明物质世界的存在，只能先通过上帝的证明来证明物质世界。\n身心二元论： 人的心灵能够思想而没有广延。物体有广延而不能够思想。\n广延：物体即广延。物体的本质，物体的规定即广延。所谓广延就是具有空间体积的有形体的东西。\n实体：所谓实体，我们只能看做是能自己存在而其存在并不需要别的事物的一种事物。\n在笛卡尔这里，物体和心灵各自独立存在，并不依赖，由此也可以看作是实体。那么这里必须要有一个上帝在之间建立联系。\n观念的东西与观念关联，物体和物体的东西相互关联，既然是两类，它们之间的关系如何解释？只好超出它们之外，求助于上帝。\n确立主体性使笛卡尔称为近代哲学的创始人，然而也引出了二元论的难题。笛卡尔的二元论给近代哲学打上了深深的烙印。\n我们要通过我和这个世界区别开，才能确立主体性，但一旦区别开，我再去讨论主体和客体的一致，思维和存在的一致，那就出现问题。因为前提是思想和存在，是两类不同的东西，现在要建立它们的同一性，如何建立，前提就预设了不可能实现这个理想。\n身心交感论： 笛卡尔早期认为身与心是对立的，无关的，晚期时认为存在一个“编译器”，可以将思想转换为身体指令。\n唯理论要从人的心灵中，而不是从外部事物的感觉经验中去推论整个世界。\n黑格尔：“思维与存在的关系问题是近代哲学的基本问题。“\n斯宾诺莎 黑格尔：\u0026ldquo;要达到斯宾诺莎的哲学成就是不容易的，要达到斯宾诺莎的人格是不可能的。\u0026rdquo; “斯宾诺莎是近代哲学的重点：要么是斯宾诺莎主义，要么不是哲学。要开始研究哲学，就必须首先做一个斯宾诺莎主义者。\u0026rdquo;\n斯宾诺莎是从实体一元论的角度:一般的哲学是从被创造物开始，笛卡尔是从心灵开始，我则是从神开始。 而斯宾诺莎所说的神，不是宗教的神，不是人格神，而是神圣的必然性。 所以从最高的神圣必然性出发，哲学的最高原则。 认识事物，要么从空间位置关系上认识它，要么事物被包括在神内，从神圣的自然之必然性去加以认识。\n斯宾诺莎的哲学有很强的伦理学色彩 斯宾诺莎的哲学体系：\n本体论——根据（基础） 认识论——方式和手段 伦理学——最终目标 斯宾诺莎的作品《伦理学》仿照欧几里得几何学的方式，从定义和公理出发，再到命题，之后还有推论、解说等等，构造了一个哲学体系。 但数学方法≠哲学方法，在这里表现得非常明显，妨碍了斯宾诺莎表达自己，也带来了读者的阅读困难 包括实体、属性、样式 本体论 实体 “实体，我理解为在自身内并通过自身而被认识的东西。换言之，形成实体的概念，可以无需借助于他物的概念。” 实体即自因。它自己是它自己存在的原因，不能是他因，否则会导致无穷后退。 实体即自因：\n实体是无限的 实体是永恒的 实体是不可分的 实体是唯一的 实体=自然=神 在斯宾诺莎这里，自然≠物质世界，是包括心和物两种东西在内的，是包括自然万物在内的大全。 能生的自然（作为原因的自然） 被生的自然（作为结果的自然） 最初的古希腊哲学中，这两种自然是统一的（古典唯物论），之后在柏拉图这里分离为理念世界（能生的自然）和现实世界（被生的自然）。 而在斯宾诺莎这里，又重新统一了。 自然是自己存在的原因，也是自己存在的结果，实体即自因。这个原因不在自然之外，它作为这个原因，产生了这个世界，这个世界就是他的结果。 斯宾诺莎认为神不在世界之外，而就在世界之内，即神圣的自然必然性。\n自然神论： 这基本上当时许多科学家和哲学家持有的观点，到休谟才去批判它。以牛顿作为最大的代表。对于一个封闭的宇宙，静者恒静，动者恒动，任何一个事物的运动会推动另外一个事物的运动，进行能量传递，而宇宙中能量守恒。那么需要一个第一动者， 牛顿认为上帝就是那个第一动者。上帝推动这个世界后就不需要管它了，这个宇宙以自己的规律运行了。 另外一个体现是设计论。在宇宙中拥有非常美妙的秩序，我们不能想象这种秩序是一个完全非理性的，那么它也一定有一个设计者。 泛神论： 是不承认有那个人格神的，这个神不在宇宙之外，就在宇宙之内，就在一花一草之中，它就是那个神圣的自然必然性。 斯宾诺莎等于把那个神等同于必然性。让这个神任意的创造世界改变世界，行使神迹就根本不可能。在某种意义上说，泛神论与无神论基本上差不多了。\n属性 “属性，我理解为由知性看来是构成实体的本质的东西。” 是实体的本质，但加了个限制，从理智的角度看。从实体的无限的角度来说，它有无限多个属性，但从人所能把握的角度，我们只知道两种，“思维和广延”。 斯宾诺莎将笛卡尔的两个实体（思维、广延）下降为一个实体的两个属性。 同笛卡尔一样，心不是物，物不是心，它们相互之间没有关系，但是因为它是同一个实体的本质，所以它们是同一的一致。 心物两面论：我们所知道的事物都有两面，思维的一面和广延的一面，思维只能影响思维，广延只能影响广延，但它们又是一致的，因为它们是同一个实体的两个方面。比如说一个杯子，它既是思维的存在也是广延的存在，占有广延，是一个物体的存在，同时也是一个概念的存在，杯子的概念是观念。\n斯宾诺莎认为心和物是一致的，统一于最高实体，反映的是最高实体的本质。\n样式 “样式，我理解为实体的分殊，亦即在他物内通过他物而被认知的东西。” 也就是实体的表现，我们所看到的大千世界就是实体的样式。 样式的世界是带有因果链条的世界，相互之间关联，一个事物的存在（在他物内、果），要以其他的存在为前提（通过他物被认知、因）。 斯宾诺莎认为这个样式的世界是个必然性的世界，认为物质界中没有偶然性，偶然性是人们无知的托辞。因为他物要通过他物被认识。 自然从原因的角度看是实体，是能生的自然。从结果的角度看是宇宙，是样式，是被生的自然。但是是一个东西，角度不同。\n实体即自因 属性是实体的本质 样式是实体的分殊\n我们人也有心的一面和物的一面，我们生活在样式世界，还好我们有心灵，我们想要摆脱这种限制而达到自由的境界，我们要去认识实体，去摆脱样式状态的束缚，通过认识神，认识那个神圣的必然性，而达到那个自由的境界。\n认识论 斯宾诺莎将知识分为三类：\n意见或想象 没有确定性 理性知识 需要推理来论证 直观知识 对本质的正确认识 直观的知识就是直接从神圣必然性去认识事物。 笛卡尔的天赋观念相当于斯宾诺莎的真观念。 真观念的解释是人的理智就像人的劳动，最开始有一些最原始的工具，这些原始的工具就是真观念，通过这些原始工具创造出复杂工具。通过使用这些原始工具，在思维劳作过程之中会锻炼的越来越复杂。\n伦理学 斯宾诺莎伦理学的主要问题是，既然自然中的一切事物都是“他因”的，都受严格的因果必然性的支配，那么作为自然的一部分的人如何可能达到至善的道德境界呢？ 虽然人们生活在自然必然性的限制下，但是他的心灵是有可能通过知神、认识神，然后他遵从神圣必然性而活动的这种能力，所以有可能达到至善的境界。 斯宾诺莎认为所谓的至善是真正的善，最高的善，是一经发现和获得之后，便可以永远享受连续无上的快乐的东西。 至善：就是认识人的心灵于整个自然（非物理的，是实体）相一致。 至善的境界是通过对神的认识而达到的。\n莱布尼茨 莱布尼茨已经意识到他那个时代机械论的宇宙观的问题。他认为哲学面对着两个问题：\n自由与必然之间的矛盾 —— 任何时代 不可分的点与连续性之间的矛盾 —— 当下时代 莱布尼茨面对的问题是：广延可以解释连续性，但是空间是可分的，如果可以无限分割，那么统一性从何而来？当时存在一种原子论的观点，原子是不可分的，原子论下的问题是连续性从何而来？ \u0026ldquo;数学上的点\u0026quot;是不可分的，但是没有广延，只是抽象思维的产物而没有现实的存在； \u0026ldquo;物理学的点\u0026quot;具有现实性，不过它是无限可分的，因而不是具有统一性的实体； \u0026ldquo;形而上学的点\u0026quot;是既现实存在又是真正不可分的实体。这种”形而上学的点“就是”单子“。 所谓“单子”就是客观存在的、无限多的、非物质性的、能动的精神实体。 单子的属性：\n单纯性 复多性 永恒性 单子之间相互独立 质的区别 单子是自因 “没有两片完全相同的树叶。” 普遍差别原则：一切都是有差别的。 那么如何解决不可分点和连续性的问题？ 连续性原则：单子可以排序为一个等级顺序，最高级的单子和最低级的单子间有无限的等级，但每两个单子中间有无限多个中间环节。 但是单子是自因，是自动机，是会自己发生变化的，这样无法解释变化的连续性。如果一些单子变化速度不一，也无法解释既定的顺序。 先定和谐： 上帝预定了一切，预定了各个单子的活动，就像交响乐团，整体永远平衡。\n偶因论：心身是独立的，上帝时刻协调两者的平衡。 对偶因论的反对：上帝预先给心和身设定了“程序”，让他们一致。这样解释了心身一致问题。\n认识论 单子即自因，它携带着过去，孕育着将来，一切都在它自身之中，当然是天赋。 这里的天赋是以一个禀赋的方式、习性或者潜能的方式的潜能在我们心中，人的心灵就像一块有花纹的大理石，在一个艺术家的面前，花纹不同，适合雕的雕像不同。感觉经验起到激发潜能的作用。\n经验论 唯理论的哲学家们非常注重数学，试图用一种公理化系统的模型来建立一套哲学科学，一种演绎科学。 经验论从经验出发，重视实验科学。以“心理论”的方式构建体系，是“经验——观念——知识”的模式。\n洛克 洛克不赞同天赋观念的理论，他认为天赋观念的证明是无法证明的，如果作为知识这种存在方式，存在于何处？对于不信上帝的民族，何处去找上帝带来天赋观念？实际上用不着天赋观念，只需要假定人有认识能力就可以解释。于是提出了“白板说”。 白板说：人的心灵就像一张白纸，外部事物刺激心灵，在上面就产生了印痕，这种印痕我们就称为观念，观念最后上升为知识。 经验-\u0026gt;观念-\u0026gt;知识\n人的感觉器官的两个接收消息的通道： 外感觉 感觉 内感觉 反省\n洛克经验论的基本原则：一切观念来源于经验。 观念（idea）是洛克哲学中的一个基本范畴，用以表示心灵所知觉、所思想的东西。 观念可分为：\n简单观念 复杂观念 简单观念的基本特点是被动性和单纯性。简单观念复合起来为复杂观念。 那么我的感知和外在事物之间有什么关系？ 第一性的质：就是物体各部分的大小、形状、数目、位置、运动和静止，也即事物广延的性质。 第一性的质是事物固有的原始性质。 第二性的质：是指事物本身所具有的一种运动方式在我们的心灵中所引起的感觉。 第二项的质是附属性质。 第二性的是主观的，物理的运动引起我的感知，但引起的是主观的反映，在事物中找不到原型。也就是事物的统一性就在于广延，其他的感觉性状不过是我们的主观的一种反映。 知识是理智对于两个观念的契合或矛盾的一种知觉。知识也就是对于两个观念之间关系的认识。 观念之间的关系有四类：\n同和异 关系 共存或必然联系 实在的存在 心外有物，心中有观念，那么如果我的观念是说从外部事物获得的，那么如何保证我们关于事物的知识和外部事物这个对象是否符合一致？ 对于这个问题，仍是二元论的问题，洛克也只能求助于上帝。 对于简单观念：证明的基点是感官是被动接受 感官是被动接受，不是我们创造的，所以各种事物通过自然途径引起我感知的能力，我的心灵也有接受这些刺激的能力。这些能力从何而来，只有上帝。 对于复杂观念，除了实体观念之外，一切复杂观念都是与自身相契合的。 为什么实体观念不能？ 对于事物，一定有一个载体作为各种属性的依托，这个依托就是实体。 在洛克这里，感知不到实体，实体更类似于复杂观念，但复杂观念只需要跟自身符合，只跟心灵中的对象有关系，但实体是对外部事物的一个规定，显然是无法证明它。 我需要假设这个实体，但我不知道它是什么。substance，sub-，在下支撑的。 也就是说，一切简单观念都是与事物符合一致的；复杂观念在心灵中和自身符合一致。而实体是个复杂观念却要与外部事物符合一致，这是我们无法知道的。 显然，我们存在对观念的遗忘，在范围上，经验 \u0026gt; 观念 \u0026gt; 知识。到了知识这个层面，我们认识的范围是越来越狭小了。在洛克这里，已经有了不可知论的因素在里面，在某种意义上，这是经验论的一个逻辑的结论。\n对于一切知识来源于感觉经验，有两个问题出现：\n我只知道经验，但经验究竟从何而来？我能不能超出经验去知道，引起经验的那个东西？ 如何解释普遍性和必然性？ 贝克莱 洛克的经验论一定会导向怀疑论，也就会导向无神论。贝克莱的做法是将那个物拿掉，所以他致力于的一项工作是非物质主义。 贝克莱认为，我们在知识中就两个因素，即感知观念的心灵和被心灵感知的观念。 在认识中，就是一个主体和一个客体，在认识中的那个客体，不是外部事物，是我们心中的观念。 推理：\n观念的存在即被感知。 物 = 可感物 = 观念的集合 物的存在即被感知。 贝克莱说他之所以用“观念”而不用“事物”，是为了反对心外有物的唯物主义。贝克莱不是想把事物变成观念，而是想把观念变成事物，即维护观念的客观实在性。 贝克莱并不是说把一切事物变成我们每个人自己主观的，唯我论，感知就存在，不感知就不存在。\n观念的存在即被感知和感知 证明过程： 因为这个世界上的事物是观念，所以心灵才能感知这个世界。如果是纯物质的存在，心灵怎么可能感知一个与心灵完全不同的物质存在？因此，一定有一个伟大无限的心灵，创造了这个观念的世界，也创造了我们有限的心灵，使我们能够感知这个世界。\n在他这里，观念是一种客观实在，心灵来感受它。 那么能否论证上帝存在作为外部这个观念世界的根据？如果说一切知识来源于感觉经验，那么经验从何而来的问题，使经验自己无法解决的。怎么判断观念和心灵都是上帝创造的？\n休谟 将经验原则贯彻到底，最彻底的经验主义者，结论自然是怀疑论。 康德认为：“自从有形而上学以来，对于这一科学的命运来说，它所遭受的没有什么能比休谟所给予的打击更为致命。”\n知觉：\n观念 印象 相当于一个是思想观念，一个是感觉印象。 休谟称自己是温和的怀疑论，只对感觉经验的来源保持怀疑，而对经验范围之内的事情能说清楚。知识来源于经验，不可能超越于经验，两者之间总有经验的帷幕。 其实更偏向于不可知论，承认某些东西是不可知的，而怀疑论是对一切都怀疑。 人类理智的对象可分为：\n观念的关系 实际的事情 知识可分为： 关于观念的知识 ——必然的知识 关于事实的知识 ——或然的知识 关于观念的知识：因为与外部事物无关，只要自身符合它的逻辑就没问题。“即使宇宙中不存在三角形，欧几里得的几何学仍是正确的。”并不依赖与有没有三角形，凭逻辑来判定真假。\n或然的知识：建立在感觉经验之上，事实之上。在休谟看来，牛顿力学是或然的知识。对于相对偶然的经验重复一万次也是相对偶然的，感觉经验只对已经经验过，和当下正在经验的东西有效。\n休谟问题 ——归纳问题 黑天鹅问题表明，一切归纳不能下全称判断。建立在经验观察基础上只能是或然的推论。\n那么为什么会将牛顿力学作为普遍必然的科学？ 休谟认为，它是建立在因果观念的基础上。在所有的原则里，只有因果观念使人们超出经验去下判断。 休谟对因果律的置疑：\n只看到结果，没看到原因，就无法推论产生结果的必然是这个原因。 只看到原因，也无法推论一定会产生一个那样的结果。 休谟认为： 从纯粹理性的角度是不可能做必然的因果推论的。一个事物的因果关系绝不是理性先天的就能推出来。 经验也不可能必然地推论因果。 对于一对因果A和B，总是经验到一个东西出现，另一个随之出现，经验到它们之间的所谓必然联系了吗，没有，只是表面。 那么所谓的因果观念究竟从何而来？ 因果观念：来源于习惯性联想 有点像心理学中巴甫洛夫效应。 他说：“习惯是人生的伟大指南。”如果没有习惯，我们每次看到都是新的事物，没有所谓的规则与规律。 一个知识要么在逻辑上的重言式，能够通过矛盾律去判断真假的，要么是经验的知识，能有经验的证实，除此以外什么都不是。\n罗素：“休谟是”英国经验论的逻辑终局。“，经验论的必然结果，也必然产生怀疑论。\n政治哲学 这部分不是很想记，但可以记一下卢梭的思想。\n卢梭 他采取了一种与人们完全不同的方式解释社会契约，与自然状态之间的关系。 \u0026ldquo;人生而自由，却无往而不在枷锁之中。\u0026rdquo; 回溯到人的自然状态，去除所有的社会性，这是个逻辑的假定。卢梭把“人所形成的人”即社会人与自然人加以比较，来说明人类社会的基础和不平等的起源。 人身上的自然本性就是一种自我保存，人就像游荡森林里的狼一样，相互之间是偶然的，人和人之间没有关系，虽然个体有生理差异，男女、力量强弱，但不在社会关系之下，是没有意义的，用不着去比较。\n“使人文明起来，而使人类没落下去的东西，在诗人看来是金和银，而在哲学家看来是铁和谷物。” 自然状态不可能持续太久，人需要生存，要利用自然去维持生机，形成了农民、渔夫等私有制。 卢梭认为劳动使人拥有了土地产品的权利，然后就拥有了土地本身。 我所劳动的付出和对土地的占有导致了私有制的产生，但这与人的自然权利冲突，他人不会认为我土地上的劳动成果是我应当占有的，自然中的东西每个人都有权获得它，这样就产生了冲突。于是有产者欺骗无产者来维护自己的利益，建立一个权利，这种状态催生出了一种社会契约，导致了社会制度的出现，这个出现导致了不平等的加剧。现在有了国家，有了社会权力，有了统治者和被统治者，不等进化到极致，那统治者会认为国家归我所有，其他一切皆奴隶。 卢梭等于在跟启蒙思想家唱反调，启蒙思想家认为人只要大胆的使用理性，提倡科学和知识进步，社会就会向进步的方向发展。卢梭给出一个相反的答案，社会越发展越不平等。 卢梭不仅将社会状态与自然状态对立，还显现出了对自然状态的美好描述。但卢梭不是要回到自然状态，而是说是否能找到一种社会制度不以自由平等的牺牲为代价，进入到社会状态下还能有平等和自由呢？ 《社会契约论》中说，合理的社会契约其要旨就在于“每个结合者及其自身的一切权利全部都转让给整个的集体“。在这个集体里，既是统治者也是守法者，是一种民主共和国的方式，每个人的权利都是一样的。 法律和制度制定的依据是公意，将众意中减去相异部分而剩下的相同部分。任何人拒不服从公意的，全体就要强迫它服从，对卢梭来说，这就等于说“迫使他自由”。\n我们可以思考，是否能在现实中创造这样的共和国？不依靠法律，而依靠每个人将自己的权利转让出来，自行当家作主，我们每个人既是立法者也是守法者，既是统治者也是守法者，靠公意来维持这样一个存在？ 在康德的伦理学中有一个想法，立法和司法真正能统一起来，只能在道德理想当中，现实中不太容易实现。\n在我看来，通过卢梭的思想可以窥见，在私有制的社会制度下，在拥有自然本性的人们对于不平等的不满是一种必然，进而共产主义思想的诞生也是一种历史必然。\n卢梭的思想影响到后来的法国大革命。在法国大革命雅各宾专政的时期，对当时的红色恐怖，黑格尔说：“砍一个人的头，跟砍一颗白菜喝一口凉水差不多。“我们会想，革命就是造反，革命总有成本，必然会威胁到一些人的安全，历史车轮总要撵倒一些小草，总会有牺牲，但历史车轮的前进，方向错误自不必说，如果那个方向是正确的，是不是它一定要以牺牲他人生命为代价，如果牺牲的还是无辜的生命，是否存在问题？ 在我看来，革命有正当性，但恐怖没有，而方向的正确与否，只能在未来评价，这反而有些悖论。\n康德 ”哲学在历史上参与了时代精神的塑造，虽然它确实十分晦涩。“ 德国古典哲学的书是有了名的难读。\n德国古典哲学创始人。\n康德生下来身体非常不好，他生下来之前的男婴全死了，他的母亲千方百计想激发起康德的生存欲望，求知欲望，但康德活了80岁。 他从很年轻的时候就给自己制定了一套非常严格的作息制度，严格的向钟表一样。他周围的邻居靠康德什么时候下来散步来对钟表。对康德思想最有影响的是卢梭和休谟。 康德一辈子没有离开自己的家乡戈尼斯堡，但博览群书，什么都知道，虽然独处一生，但经常参加社交活动。虽然“循规蹈矩”，但给我感觉应该是很有意思的一个人，他去世时，整个城市的人为他送行。 康德46岁在申请教授论文发表后，被划定为批判时期。康德的批判哲学来自于最重要的三部著作：《纯粹理性批判》、《实践理性批判》和《判断力批判》。\n老师认为：康德哲学是现代哲学的开端，黑格尔哲学是古典哲学的终结。实际上是黑格尔之后，他这条路没人走了，所以是终结，而后面的路与康德有千丝万缕的联系。\n康德哲学的问题 理性的危机 自由的失落 形而上学名存实亡 在唯理论和经验论的哲学下，实际上证明科学知识的普遍必然并没有成功。 启蒙最重要的指导思想是理性和自由，摆脱人们对思想的束缚，理性解放，追求自由。而在一切领域都可用自然法则说明下，自由失去了存身之地。 休谟的怀疑论、18世纪法国的无神论建立在经验基础上，形而上学名存实亡。 这三个问题在康德这里集中体现为知识的问题。理性的问题要证明科学知识的问题，自由的问题是因为把科学精神贯彻到所有领域里面，自由反而失去了，形而上学如此也是因为想成为科学但没有成为。\n休谟的提示打破了康德的独断主义的迷梦。 独断主义：没有对理性的认识能力进行深入的考察，就武断断定的哲学理论。\n启蒙带有一种知识分子精英要教化大众的历史使命，而卢梭说进入到社会状态社会越发展人越不平等，科学各方面的进步不足以是人们提高道德水准。 那么究竟什么能够体现人的价值和尊严？在启蒙思想中更提倡的是知识，而卢梭更提倡是道德。\n我过去认为唯有知识能够造福于人类，所以我以有知识为荣，鄙视那些无知的人们，但是卢梭纠正了我的偏见，教会了我尊重人。\n将康德的问题集中为一个问题：在一个严格受自然法则限制的世界上，人有没有自由？有没有不同于其他自然存在物的价值和尊严？\n康德认为形而上学体现的是人类理性试图超越自身有限性，通达自由境界的一种理想。 从这个角度考虑，是形而上学成为科学与这个理想背道而驰，让形而上学达到最高的普遍性和必然性能不能解决形而上学的理想，这是康德的“哥白尼革命”的实质问题。\n康德的“哥白尼革命” 康德同一经验论的基本原则，一切知识来源于感觉经验，但经验不够以说明普遍性和必然性，但科学知识又是存在的，如何说明？ 科学知识至少包含两方面的因素：一方面是后天经验，另一方面是先天形式。对于那些先天的知识是具有普遍和必然性的，而对于后天经验知识是或然的。\n在这里，康德对于“先天”的概念发生了变化。 后天的：\n个别偶然的 感觉经验的 先天的： 普遍必然的 独立于经验同时作为经验的条件 经验论与唯理论的困境：如果知识必须建立在经验的基础之上，知识就不可能有普遍必然性；如果知识有普遍必然性，它就必须是先天的，而不可能是后天的，来源于感觉经验。 康德将这个问题特别的表达：我们如何能先天的经验对象。\n在传统的思路上，真理必须符合对象，这种真理的符合论无法解决问题。 如果真理必须符合对象，我无法解释外部事物如何进入到我们头脑中来；即使外部事物及其属性可以进入到我们头脑中，也无法解释普遍性和必然性。 那么能不能像哥白尼一样，颠倒主体和客体的关系，不是知识必须符合对象，而是对象必须符合认识主体的先天认识形式。 康德认同经验论的基本原则：一切知识来源于感觉经验。但是仅仅有感觉经验还不够，主体自身需要有一套加工整理感觉经验的认识形式和结构。人的心灵不是像洛克说的就是一张白纸，而是有一套自己的认识形式和结构。 我们的认识形式不来源于感觉经验，是主体自身的，这套认识形式就是所谓独立于经验同时构成经验条件的东西。 构成知识要两方面的因素，一方面是感觉经验，一方面是主体的认识形式对感觉经验加工整理，这样获得的知识既具有经验内容，又被整理出了普遍性和必然性。 从内容上讲，知识是经验的、后天的。 从形式上讲，知识是先天的。 是认识主体赋予知识先天性。 康德的特殊之处在于，将认识形式类似于一套认识工具而不是天赋观念的知识，只要去认识，就要使用工具，大家使用的工具是一样的，结果也是一样的。\n只能看到你先天认识形式所能看到的，涉及形式范围之外，事物究竟自身如何，我们永远无法知道。物自体不可知。 事物对我们的显现，我们可以形成科学知识，但在这个东西之外，事物究竟是什么样子，我们无从得知。就是物自体究竟什么样，不可知。 这样，解决了普遍性和必然性的问题，但带来了不可知论。 形而上学的理想在这里遇到了严重的挑战，宇宙万物的终极原因是无法实现的。\n虽然认识形式的限制体现了认识能力的有限性，但是另一方面物自体不可知也表明在我们的认识领域之外还有一个不受认识形式限制，因而可能是无限自由的领域。 那么自由就有了可能性，人类理性的实践理性就有了用武之地。 人类理性的两大功能：\n理论理性 -\u0026gt; 认识能力 实践理性 -\u0026gt; 伦理、道德 不可知论是个消极的结果，但正因为不可知，自由才是在逻辑下可能的。如果它是可知的就没有自由，会在认识形式的限制之下。那么以自由为前提的道德伦理学就有其可能性。 哥白尼革命实际上做的是划界，同时让自然哲学和道德哲学都能成立。 即使我们能够证明人类可以认识物自身，那也无法解决自由的问题。更何况我们无法证明我们能够证明物自身。 恰恰是这不可知论给自由留有余地。形而上学要满足的是人达到自由境界的理想，要让他成为科学无异于南辕北辙，既然形而上学要超越自身的有限性达到自身的理想，我们也需要满足它，那么能实现人的自由的只有伦理学，科学的领域只能达到必然性。\n我必须限制知识，以便为信念留地盘。\n历史影响与地位 康德对形而上学的批判是最系统的最有利的批判，但不是舍弃形而上学，按照传统的方式走，形而上学不可能达到自己的目的。 人同时是两个世界的成员，同时受两种法则的影响，一方面作为有限的存在是自然的一份子，在这个领域自然法则起作用，一切都是必然的没有自由。另一方面人不仅仅是自然存在物，人还有理性，应该服从理性的法则。但自然法则是必须遵守，无法违背的必然法则，但理性法则是应该遵从但不必然遵从的法则。理性法则就体现为道德法则，应该如何去做。\n人之为人在于理性。 人不是单纯的理性存在，而是有限的理性存在。\n康德解决了两方面的问题，一个科学的普遍性必然性，另一个是自由、道德和形而上学的问题。\n问题在于，如何证明人有这个认识形式？康德将这一方面作为需要对理性它的能力进行分析和考察，康德将这种分析和考察叫做批判。 康德就是要考察一下理性究竟有哪些先天认识形式，对一般形而上学的可能性或者不可能性的裁决。真正要解决的问题是形而上学的问题。 批判是和独断论相对的。从此之后，批判几乎成了西方哲学的前提。 康德对理性认识能力的批判形成了三大批判组成的哲学体系（批判哲学）：\n《纯粹理性批判》 认识能力 《实践理性批判》 实践理性 《判断力批判》 沟通理论理性和实践理性的一个桥梁 康德哲学 归根结底，是启蒙主义出了问题。 工具理性——价值理性之间的冲突。 科学高速发展，信仰衰落，但问题在于理性能不能取代上帝空出来的那个位置？ 尼采认为一切建立在神学基础上的价值崩溃，如果还这么去做无法解决虚无主义的问题，绝对价值的丧失。 尼采与康德面对的是同样的问题。 我们当今也面对同样的问题，物质条件极大丰富，是否它的丰富能否解决我们的精神问题？反而现在人陷入了价值多元化，道德相对主义，人的精神找不到依托。实际上，这就是我进入哲学的原因。 如果接受不了尼采的方式，那么可以看看康德的方式。\n我们需要了解康德对于先天认识的存在证明。 康德把人的理性的认识能力区分为三个环节：感性、知性、理性。 注意：不是过程，是静态的条件、结构分析。\n康德强调知识是由判断构成的，知识的基本单位是判断。 比如说：地球是行星。\n判断分为两大类：\n分析判断 综合判断 分析判断：指判断的宾词原本就蕴含于主词中，是从主词之中抽出来的。 没有给我们带来新东西，说的原来就是那个概念所包含的。比如说：苏格拉底是人。 康德说这种判断的确是先天的，具有普遍性和必然性的，但是它不是严格意义上的知识。 综合判断：指的是宾词是后来通过我们的经验加在主词之上的。 比如说：物体是热胀冷缩的。 综合判断可划分为： 后天的综合判断 先天的综合判断 后天的综合判断是单纯的经验判断，不具有普遍必然性。而对于科学知识，要求有普遍性和必然性，就得是先天综合判断。 先天综合判断如何可能？康德将这个问题具体化为三个问题： 纯粹数学如何可能？——先验感性论 纯粹自然科学如何可能？——先验分析论 一般形而上学如何可能？——先验辩证论 实际上问的是构成一个科学知识需要哪些基本条件，找到这些基本条件后可以用它来判定一门知识是否是科学知识。 先验哲学：研究先天认识形式的科学 超验：指的是那个物自体，超越于经验之外的不可知的领域 他相信形而上学有两个方面，一方面是对自然的描述，另一方面是超越于它之外，给这个宇宙一个终极的原因，超越的原因。 康德认为我们描述世界的逻辑结构是可以成立的，但不是亚里士多德意义上的自然本身的逻辑结构，而是我们认识世界的结构，是我们主体的认识形式和结构。而超出这个领域之外，是不可知的领域。\n人类理性的两大功能： 理论理性——认识能力 实践理性——行动、意志功能\n人的认识能力分三个环节：感性、知性、理性\n纯粹理性批判分为：\n先验感性论 先验逻辑论 先验分析 先验辩证 先验逻辑与形式逻辑相对，形式逻辑只是处理已经有的知识，只关注于形式方面的逻辑关系，并不关注于知识内容。比如说：上帝是万能的。在形式逻辑上是合乎逻辑的，但在事实上不关注。 在形式逻辑分析的知识背后，我们要有起认识论作用的逻辑，这里的认识论是先天认识形式。 先验分析论——关于真理的逻辑 先验辩证论——关于假象或幻想的逻辑 先验感性论——研究感性先天的直观形式\n感性就是直观，当我们和对象发生关系中间不经过任何中间环节直接发生关系，在康德看来，我们只有一种直观能力，就是感性直观，康德坚决反对人有理智直观。\n先验感性论 空间和时间是感性的先天直观形式。 这一点是康德的独创，和我们通常的感觉经验和意识观念大相径庭，在我们看来这个世界就存在于空间之中，而康德说空间和时间不是外部事物的存在方式，而是我们看待事物的方式。 康德的证明分两类：\n形而上学的阐明 要证明空间和时间是先天直观形式 先验的阐明 这个先天直观形式构成了经验的先决条件 形而上学的阐明： 空间与时间是感知事物的先决条件，而不是感知的结果。以空间为例，如果要感知外部事物，就已经以空间为前提，不可能感知不在空间中的事物。 空间与时间是不是通过感性经验而获得的经验概念。不是经验了许多个空间，然后得出一个空间的概念，而是只要感觉发动，就一定以空间为前提。人的直观能力、空间感是先天的。所以空间是直观不是概念。概念总是有很多个个体，不可能想象一个概念涵盖无限多的个体，在形式逻辑中，概念有一个内涵和外延的关系：内涵越少，外延越大。如果想象一个没有内涵的东西，那他就不是概念了。而空间只有一个，不同空间是整体空间的部分，并且是无限的。 如果时间和空间是先天直观形式如果证明了，他们对经验的客观有效性也就证明了，因为构成了经验的先决条件。 康德要说明数学问题。 康德认为数学可以分为几何学和算数。几何学就是关于空间的科学，算术就是关于时间的科学，必须把它们看作是先天综合的判断。 比如说两点构成一条直线，包含了量和质的关系。5+7=12，只分析5和7怎么也得不出12，只有将他们加起来才能得到12，它们的关系最基本的是时间上的前后相继。如果不是将时间和空间看作先天直观形式，无法解释几何学和算术的普遍性和必然性。 当然，康德的物理知识和数学知识对于现代来说落后了，但我们将他解决问题的方式和意义剥离出来： 即使在感觉经验之中我们也必须考虑到主体的认识形式。 用一种大而化之的话说，我们每一个人都是站在自己的立场观点方法看待世界，每个人看到的世界会有区别，不同的文化看待世界有不同的立场观点方法。 对于感性，空间和时间构成了经验的两个通道。\n先验分析论 知性的先天认识形式是“知性纯概念”。亦即“范畴”。 感性认识和理性认识的结合问题，在康德这里着手解决。\n感性之所司在直观，知性之所司在思维。直观物概念是盲的，思维无概念是空的。\n康德强调感性与知性结合才能形成知识。要有感性直观提供的材料，要有知性提供的范畴作为认识工具。 康德通过形式逻辑论证知性范畴。四组十二个范畴就是我们知性的纯概念、先天认识形式。 康德关注的问题： 知性范畴对于经验的作用。 按照通常观念，感性提供对象，主体是认识的对象。而康德要证明没有知性范畴就没有经验。所以康德将这个证明称为先验演绎，这是个法学上的概念，要区别事实与权利的区别。康德要检查这个概念范畴的合法性依据，也就是范畴应用于经验的客观有效性。证明范畴是经验的先天条件。 这部分的证明是最困难的。 康德证明的先决条件：\n感性直观 先验自我 感性直观和自我是两种不同的能力。感性直观提供经验杂多，自我自己不能直观，自己不能给自己提供经验内容。 形成知识需要综合。综合是两个不同表象的连接，综合不可能来源于物自体，它不可知，也不可能来源于感性，感性是被动的接受，只是提供给我们表象的杂多，综合就是知性，唯一要归于知性的自发性。 康德关于范畴的演绎核心命题是：我思必须能够伴随着我的一切表象。 否则，我的表象不为我所知就不是我的表象，只要在我认识之内，我的一切感觉经验、认识和情绪，所有的活动都以我为前提，所以我与我自身的同一性是最高原理。而表象不是自我提供的，是由感性提供的，就意味着我们需要解决同一的我和杂多表象之间的关系，怎么将这些杂多的表象变成我的表象，而我思和感性直观是两种不同的认识能力。我思行使认识的功能，感性行使直观的功能，我们要解决同一的我和杂多表象的多之间的关系，要把杂多表象变成我的表象，而我是同一的，表象是杂多的，是一对多的关系，而杂多表象能进入我的意识中来，就一定要成为我的杂多表象，说明我们要在我和杂多表象中找到一个中间环节，可以把杂多表象带到同一的自我之下来。 范畴对于经验的客观有效性，范畴体现的就是自我的综合统一功能，范畴一方面把杂多表象带到自我中来，另外一方面把自我的同一性带给每一个杂多表象，才能说我思伴随着我的一切表象。 感性和知性怎么沟通？ 先验的想象力(头脑中形成图像的能力)。 感觉经验面对这个图像，在感性直观中起作用，形成一个图像就需要综合，将不同属性连接，综合起来所需要的规则却是范畴的规则。提供综合的规则只有范畴。所以想象力介于知性和感性之间，在感性中实施的是范畴的作用。 形成你的认识对象是有认识活动参与其中的，只不过是盲目的在感性直观中起作用，我们不知道，我们再去认识它，我们发现范畴不只是知识的形式，也是对象的形式。来源于同样一个根源，知性范畴的综合统一规则。\n最高原则：知性为自然立法。 康德说得“自然”并不是自然本身，而是一切可能经验之表象的总和。表象作为经验就要符合连接表象的规则，连接表象的法则是知性的法则，亦即范畴，因而“知性为自然立法”。 亚里士多德：范畴是体现存在的意义。 康德：范畴是认识世界的工具。 所以在康德这里，形而上学要能解释这个世界就有可能了，考虑到人的认识世界方式，内在形而上学是可以成立的。在现象界可知，而且可以形成科学知识，超出经验之外，不可知的领域。\n我们的认识从感觉经验开始，通过和知性范畴结合形成判断，但是人类理性不满足于此，它希望我们的知识能够构成更大的体系，能够使我们所有的知识形成完满的体系，这就需要理性的作用。 理性是进一步把知识调整为体系的作用。可以理解为对于知识的知识，而如果将理性作为认识的对象，问题就出现了，形而上学犯的就是这个错误。 感性的先天认识形式是空间与时间。——接受性 知性的先天认识形式是范畴——构成性 理性的先天认识形式是理念——调整性 理性的三个理念：灵魂、宇宙、上帝 三个理念体现的是理想的统一性：\n灵魂主观世界的统一性 世界万物的统一性 上帝大全的统一性 将他们作为目标引导知识进步是有意义的，但加入把它当作现实的统一性要去认识它，就会陷入到幻象之中。 幻象是混淆了理想的统一性和现实的统一性。\n就认识而言，离开了经验不可能有有效的知识，而形而上学是超验的。 传统形而上学分三部分：\n理性心理学——灵魂 理性宇宙论——世界 理性神学——上帝 二律背反： 宇宙中的东西都是可以经验的，但宇宙不是一个经验，将宇宙作为对象，会形成两种相反的理论，但它们各自都能够自圆其说。 对同一个对象形成两种矛盾的理论，但是各自又都能成立，就是“二律背反”。 第一组二律背反： 世界是无限的还是有限的？ 正题——世界在时间上有开端，在空间上有界限，世界是有限的。 反题——世界没有开端也没有界限，它在空间和时间两方面都是无限的。 第三组二律背反： 自由和必然的关系问题 正题——仅仅以自然因果律解释自然是不够的，有必要引入自由因。 反题——没有自由，世界是按照自然因果律解释的，一切是必然的。 康德说这对二律背反产生的原因是将宇宙当作一个整体，陷入到矛盾中。如果用哥白尼革命把世界对我们区别为：物自体和现象，这个矛盾可以解决。在现象界有知性的先天认识形式范畴立法，一切都要服从于因果律，没有自由因的问题。将现象背后的物自体看作为不再有原因的原因是说得通的。在现象之内服从自然因果律，引起现象，在现象之外看作是用不着再找原因的原因。\n我们不可能真正认识到宇宙有自由因，我们只是思想上的逻辑假设。但是在人身上发现有一种可能性，它有自由因，有绝对开始行为的一个原因，用不着找因的原因，即“人有应该”。 自然既不可能引起一个“应该”，也不可能制止一个“应该”。\n康德理论的核心批判：“关于上帝存在的本体论证明”。 上帝的问题是纯然的超验，完全理想的东西。 批判的核心： 判断的逻辑必然性和事实的现实必然性两者之间的区别。 关于上帝存在的本体论证明混淆了逻辑必然性和现实必然性。康德举了个非常有名的例子：我头脑中的100块和口袋里的100块有区别吗，逻辑上没区别，但是如果我到商店去买东西，区别就体现了。\n在哲学史上，康德对形而上学的批判是最深刻、最系统和最全面的。\n实践理性 在近代哲学中，康德是把实践范畴引入哲学的第一人，不过他所说的实践还只限于伦理学的范围。在黑格尔到马克思是将实践作为改造世界的活动。 自然法则是不得不遵守的必然的法则。理性法则是人应该遵从但不一定遵从的法则。 康德的伦理学是典型的动机论。在当时存在一种将道德归结为功利主义的思想，从效果的角度来衡量。而康德认为，从结果或者行为本身来判断，不能辨别一个行为是否具有道德意义。 比如说一个诚实的行为可能有很丑恶的动机。只有因为诚实而诚实的行为，才能称之为道德行为。而现实中是否存在这种道德行为？ 康德认为，道德行为在现实中没有并不意味着理想中不应该有。对于理性，恰恰要创造的是自然中没有，但是应该有的东西，这是体现人的价值和尊严的地方。\n道德法则如何可能？ 道德就是说你的主观准则不仅对个人有效，而是对一切有理性者都有效，这样的行为叫道德行为。 所以有一个关系： 一个道德行为一定是落在个人身上的，个人的动机一定出于主观准则的意义，当你的主观准则对所有理性者都有效时，那就可以称为客观法则。或者说将客观法则作为个人的动机。\n康德将道德法则也叫做定言命令。 所谓“假言命令”是一种有条件的命令式。如果……就……，手段和目的是分开的。 道德命令目的与手段是统一的。这类命令即定言命令。 如果一个法则可以叫做道德法则，应该具备的条件：\n普遍性的公式 要只按照你同时认为也能成为普遍规律的准则去行动。你的行动，要使你的准则通过你的意志上升为普遍的法则。 质料公式（如何判定一个主观准则的内容可以上升为普遍法则） 你的行动，要把你自己的人格中的人性和其他人格中的人性，在任何时候都同样看作是目的，永远不能仅仅看作是手段。（人是目的，不是手段） 实践的功能是目的性的活动，如果一种动机能够成为所有有理性者的动机，意味着能够成为所有有理性的目的，那只能是理性自身。源出理性自身目的而行动，才能叫做不是手段而是目的。衡量的标准也就是动机怎么能成为对所有有理性的奏效，这个行动的目标，考量一下能不能对所有有理性者来说都是它们的目的。如果符合，那我就是出于理性自身而行动，理性为自身立法。 自律性公式 每个有理性者的意志的观念都是普遍立法意志的观念。每个有理性的存在，在任何时候都要把自己看作是一个由于意志自由而可能的目的王国中的立法者。 我出于自身目的而行动，我自己立法，我自己遵守。自由就是出于自身内在必然性而行动，自由就是自律，自由和道德法则是一而二、二而一的，是同一个东西。 康德不会把自由理解为任意的去做什么，往往在这样的自由背后会发现利益的原因，经验的原因，欲望的原因，什么情况下才有真正的自由？那就是出于自身内在必然性。 人类理性有两大先天立法权：\n知性为自然立法 理性为自身立法 对于实践理性和理论理性，康德强调的是实践理性的优先地位。因为不可能让理论理性去统帅实践理性，那样意味着没有自由。但在人身上有一个动机出发，作出一个行为，行为落在现实中是不必然的条件所限制，动机超越于经验条件的限制，但行为是受到经验限制的。 那么问题在于如何协调两个领域的行为和动机的关系？康德把它具体化为实践理性的二律背反。 将自然存在物的幸福为目标和实践道德领域的道德为目标两者间的关系如何协调？ 二律背反： 幸福是获得德行的原因 追求德行的实现也能带来幸福的结果 以幸福为目的不一定是德行的行为。而追求德行不一定会获得幸福：好人受苦，恶人当道。 德行是配享幸福的首要前提； 在此前提之下，能享受到幸福，此为至善。 实践理性的“公设“：\n意志自由 灵魂不朽 上帝存在 意志自由，能够将主观准则上升为普遍法则，有这个自律道德才是可能的。 康德认为人的一生都会受到自然法则的限制，在有生之年都不可能达到完全的德行那个境界。除非假设人格具有无限的延续，否则我们不可能实现德行。灵魂不朽才能实现德行。而灵魂不朽是必须假设的，这样我们才能追求德行。 必须假设上帝存在能保证两个世界的协调一致。但是康德没有要把道德建立在上帝的这个基础之上，在康德心目中，没有建立在神学基础上的道德，但可以有建立在道德基础上的神学。 在实践理性的最后，康德有一段话脍炙人口：\n有两样东西，我们愈经常愈持久地加以思索，它们就愈使心灵充满始终新鲜不断增长的景仰和敬畏：在我之上的星空和居我心中的道德法则。\n头上的星空和内心的道德法则都和我们的生存密切相关，地球和浩瀚无垠的宇宙连起来在一起，我们生存的地球不过是浩瀚银河中的一粒沙尘，我们也只不过是生活在沙尘上微不足道的生物，我们不知道为什么有了生命，但再过几十年我们又会将生命还给自然，敬畏头上的星空感受到的是人的渺小。人的内心的道德法则，自律，就使我和一个超感性的一个理智的世界一个自由的世界发生了关系，那么人的价值和尊严就体现在这个方面。\n康德哲学意识到了近代哲学启蒙主义中理性和自由的冲突，或者说科学和道德和自由的冲突，而康德的解决的方式弥补了启蒙主义的理性概念。启蒙主义的理性主要是科学理性，但康德这里讲要把实践理性加进去，而且把实践理性体现为人的价值和尊严的东西，科学发生的信仰动摇，那么人的精神方面由谁来负责。近代的发展这个社会越来越合理化组织化，却会带来非理性的结果，价值理性基本被工具理性所取代。\n康德哲学的局限性： 康德自觉的从二元论和不可知论出发，但他绝对不想把二元论和不可知论贯彻到底。但康德自己已经无法解决这个问题了，晚年的康德已经无能为力了。后来的费希特、谢林和黑格尔就要解决康德这个二元论的问题。\n黑格尔 黑格尔对法国大革命的同情和赞赏保持终身，说：”法国大革命是人类历史上一次光辉灿烂的日出。“ 康德哲学在当时对年轻人的影响非常巨大。\n朝霞伴随着康德升起，自由贯彻全部哲学而始终。——谢林\n人类自身像这样地被尊重就是时代的最好标志，它证明压迫者和人间上帝们头上的灵光消失了。——黑格尔\n但后来人显然面对康德的二元论和不可知论的问题。 黑格尔的主要著作：《精神现象学》、《逻辑学》、《哲学科学全书纲要》和《法哲学原理》。其他的都是讲演录。后两本是纲要、教材，主要的书就只有前两本。\n谁若想理解黑格尔，只能靠他自己。 有多少研究黑格尔的人，就有多少个黑格尔。\n对于我们来说，阅读黑格尔存在一个解释学循环的问题：不把他读完不了解他的精神，如果不了解他的精神又怎么读他的东西。所以黑格尔的东西的确难读。黑格尔的辩证法给人们理解留下了充分的空间，他要按照事物自身辩证运动的方式来描述这个世界，黑格尔只是描述，让事物自身运动呈现，不看到最后不了解黑格尔的思想。\n康德对形而上学的批判造成了形而上学的崩塌，但康德没有很好的建立起形而上学，黑格尔要做起这个工作。 黑格尔对康德的回应： 康德要求对理性进行批判亦即分析是有道理的，但批判本身是不是理性活动？ 因此真正的批判应该是理性的自我批判。但这种批判如何可能？\t黑格尔也是从知识和对象的关系入手，如果承认知识和对象是有差别的，我们用不着超出知识范围之外去检查，在知识范围内就可以检查我的知识和我的对象是否一致，如果它们有区别，显然我要改变知识符合对象。但是改变知识后，对象也会变化，所以我们的认识活动就构成了知识和对象的矛盾运动，因为它们的差别，构成了意识的自身矛盾运动，认识是一个发展的过程，根据知识改变对象，根据对象改变知识。感性的对象是感觉经验，理性认识的对象是事物的本质，从感性认识上升到理性认识，从感性认识上升到理性认识是知识发生变化，对象也从简单的感觉经验上升到了对事物的本质的认识。 康德是一个静态的结构分析，而黑格尔是一个动态的发展过程，那也就意味着物自体在发展过程之中逐渐转化为被我们认识到的东西。 上面还只是局限于认识论上，但在认识论上挑战康德是很难的，黑格尔更重要的一点是统一认识论和本体论。 黑格尔相比之前主客体的分析站在一个更高的层面，不要把我们和这个世界分离开来看待，我们就在世界之中。 人就是这个宇宙的产物，人的活动必然和宇宙有关，如果人没有认识到世界，站在世界的角度我和这个世界发生了矛盾，那么如果我认识了这个世界，扬弃了这个矛盾，不仅仅发生在主观范围内的事情，其实是这个世界本身的发展和变化。 从这个角度看人类的精神活动，那么人类对宇宙的认识就不单纯是人作为主体看待这个世界，你就存在于这个世界之中就是宇宙的产物，人对世界的认识就可以看作是世界的自我认识。 黑格尔的哲学最伟大的地方在于，黑格尔的哲学立场比其他哲学家要高。 《精神现象学》展示的过程就是从最基本的感性认识一直进展到对那个绝对精神的认识。在某种意义上，黑格尔心目中来讲，人类精神其实在黑格尔心目中就是那个宇宙万物那绝对精神的具体体现，黑格尔把宇宙看作是绝对精神的展现，而宇宙的展现最高阶段是人类精神， 而人类精神对宇宙的认识，其实就是在替绝对精神做的一项工作，对宇宙的自我认识。\n实体即主体 实体是活的，黑格尔称为活的实体，自身具有能动性。\n只有当我们把实体同时也理解为主体，理解为自己展开自己的运动的时候，才能说明它的现实性； 实体作为主体的能动性就表现在它自身之中就包含着纯粹的否定性； 实体自身带有自己否定自己的否定性，把自己一分为二，展开为对立面，把潜在的东西展开为这个自然，然后发展到人类精神这个层面去认识这个自然，重新达到自身的同一性。\n实体的运动就成了以终点为目的的自己展开自己、自己完成自己的”圆圈“。 目的和目的的实现的一个目的论的过程，最初的存在是潜在的东西，展开为自然，最终达到人类精神认识的这个自然，更高层面的重新回到了自身。 绝对精神——人的精神的绝对化 但绝对≠绝对精神 绝对还没有成为精神，潜在的，展开为外在的自然，只有通过人类精神的活动，绝对才真正成为绝对精神，这就意味着人类意识这个世界的活动是参与到了宇宙的本体论里面去了。从绝对到绝对精神是一个自我运动、自我发展、自己实现自己的过程。 黑格尔的宇宙观：就像一颗树种长为大树，一颗树种蕴含着成为大树的所有因素，但是那颗树种在没有长成大树之前，它只能是潜在的大树，只有当它长成参天大树的时候，我们才说它成为真正的现实。黑格尔哲学不会强调真理，只会说是发展的过程，到结果才真正成为现实。 辩证法 黑格尔认为当时的人类生活在抽象的观念之中，因此很难体验和再现事物活生生的生命。 ”辩证的否定“乃是黑格尔辩证法的核心。\n否定性是毁灭的力量，但唯独有一种东西能在毁灭中仍然保持生命，那就是精神。\n黑格尔的哲学前无古人后无来者，后人不再做这个工作了。 黑格尔哲学是古典哲学淋漓尽致的发挥，也是古典哲学最后的生命力。\n黑格尔把宇宙看为一个合理性的存在，是个统一的整体，这个统一的整体具有完美的这个秩序，是由一个统一的东西展开的一个现实，那黑格尔哲学就是真理。可惜的是这些都被我们所质疑，我们说这个宇宙是盲目的，非理性的，我们看待世界是我们看待世界的方式，世界本身是个盲目的存在，就意味着黑格尔的那个古典哲学的根基发生动摇。 所以对于黑格尔哲学，我们就当艺术品去欣赏他。 黑格尔哲学的很多思想已经成为人们的共识，融入后世的哲学思想中。但黑格尔给古典哲学画上了句号，既是完成，也是终结。后世探讨形而上学的方式与古典哲学完全不一样了。\n","date":"2025-06-21T14:29:17+08:00","image":"https://oldlay.github.io/p/modern/picture_hu_c6e488b93840cef2.jpg","permalink":"https://oldlay.github.io/p/modern/","title":"西方哲学史 近代哲学"},{"content":"3. 中世纪哲学 公元二世纪到公元十六世纪的哲学形态。在这个时期，基督教渗透了社会生活的各个方面，完全统治了西方社会。\n西方文明两大源头：\n希腊文明(雅典) 希伯来——基督教文明(耶路撒冷) 基督教的思想可以说已经融化到西方人的血液之中。 无论是教父哲学还是基督教哲学，作为哲学就要讲理性，它要调和理性和信仰。\n中世纪的三个基本要素：\n罗马帝国 基督教 日耳曼人 基督教要成为一个神学体系要借助于哲学，于是基督教开始哲学化，所以带来了理性和信仰的关系问题。\n日耳曼人是生活在欧洲北部的一个部落群，里面包含了法兰克人、汪达尔人、哥特人等等，统称日耳曼人。他们处于一个军事共产主义阶段，全民皆兵，没有文化的类似原始社会形态，甚至没有语言。中世纪真正的黑暗时期是西罗马灭亡，希腊罗马文明被一扫而空。他处于一种西欧的封建庄园制度。\n基督教对哲学的贡献 贡献：\n超验性（对于超越于这个世界之外的那个世界的关注远远胜过任何一个时代） 内在性（在于人的信仰层面，回到人的内心） 自由的问题 超自然的观念 自由的问题：亚当偷吃智慧之树的果子，这里面似乎有一些悖论。上帝是全知、全能、全善的，如果从这个角度去看亚当偷吃智慧之树的果子，会发现很大的矛盾。如果上帝不知道智慧之树的果子，他不是全知的。如果上帝知道却不制止，他不是全善的。如果知道，想去制止却不能制止，你不是全能的。上帝创造了亚当去犯罪，会给整个人类带来原罪。 后来教父哲学代表人物奥古斯丁解释：上帝创造亚当，按照他的形象是给了他的自由意志，上帝交付了他命运也劝导了亚当不要吃果子，但是亚当滥用了自己的自由意志，选择了恶而没有选择善，原罪在此。人本来有自由不犯罪，但是当他犯罪之后，他就不得不犯罪，原罪就变成了你的遗传。\n超自然的观念：希腊人认为自然是神圣的，有生命的存在，与人是同质同构的，要做的是如何回归到宇宙之中去，所以希腊人有认识自然的观念，但没有改造自然的观念。但基督教不一样，上帝创造人把人放在地球上成为这个宇宙的中心，一切自然的东西都是为人服务的。这样基督教的自然观为后来近代科学技术的发展，提供了某种前提。\n教父哲学 公元2世纪到公元5世纪，基督教会中一批具有哲学修养的信徒，在理论上论证和捍卫了基督教信仰，由于他们对教会的贡献，被教会尊称为“教父”，即教会的父亲。\n奥古斯丁 奥古斯丁是浪子回头的典范，他母亲是虔诚的基督徒，但他出生没有受洗，接受的是希腊教育。他是一个纨绔子弟，但他每次做完坏事就会忏悔，他觉得自己遏制不了自己的这种欲望。上帝既然是全知全能全善的，那么为什么还允许创造的世界有恶的存在。于是他皈依了摩尼教，是一个二元教派，最后觉得仍然不能解决问题。之后受到了新柏拉图主义的影响，皈依了基督教，他的皈依称为花园里的奇迹。\n他找到一种为神的正义辩护的方式——神正论 神正论：基督教哲学名词，认为世界之所以存在是由于上帝的存在。 根据流溢说，完满后流溢，但是逐层越来越不完善。上帝是完满的，但是上帝创造的世界是不完满的，你不可能想象上帝创造一个和他同样完满的世界，那就有两个上帝。恶是善的缺失，恶不是实体的存在，因为世界的不完满。\n大学是中世纪对人类文化的一大贡献。\n经院哲学 经院哲学：最初在查理曼帝国的宫廷学校以及基督教的大修道院和主教管区的附属学校发展起来的基督教哲学。\n安瑟伦关于上帝的本体论证明：上帝的存在，对于那些信仰上帝的人不是问题，是针对不信上帝的愚人。对于愚人，上帝是可设想的至高无上的存在，思想中的上帝是无与伦比的，一个无与伦比的东西不可能只是在思想中存在而在现实中不存在，所以他强调我们可以通过上帝的观念来推论上帝的存在。 是讲存在的，而且是从概念推论出存在。\n而阿奎那是从经验事实反推必然存在。 阿奎那关于上帝的本体论证明：\n任何事物都以另一事物为动力因，以此类推就必然有一个最初的动力 因。 任何事物都以其他事物作为其存在的条件。在这些偶然的相对之中，最 后一定会出现一个绝对的必然作为它们的根据。 万世万物都是向好的方向发展，都是要达到完善。由此推论下去你就会 一定会推出一个最高的完善。 阿奎那是从现实出发，具体有限的东西，去推论上帝存在。 经院哲学关注的一个重要问题：\n一般——个别 根据这个问题，分为了两派： 唯实论（实在论）： 主张普遍的共相是真正的实在，殊相或个别的东西不过是现象。 唯名论： 认为个别的东西才是真实存在，共相不过是概念、语词而已，并没有实际存在的意义。 将亚里士多德和柏拉图之争归结为三个问题：\n共相是独立存在的实体，还是仅存于人的思想之中？ 如果共相是实体，它是有形的还是无形的？ 如若共相是无形的，它与可感物是分离的还是存在于可感物之中？ 为什么经院哲学遇到了与希腊哲学相似的问题？ 经院哲学利用希腊哲学来进行哲学思考，因而也就继承了希腊哲学的问题。 日耳曼人开始进行知识活动时，需要接受逻辑训练，但缺少具体内容，使他们陷入空洞抽象的争论而不能自拔。 由于神学的限制，哲学所能讨论的范围很狭窄，一般与个别之间的关系问题成了学者们有可能思考和讨论的主要哲学问题。 唯实论当时是教会正统，因为维护教会权威，而唯名论会维护皇权权威。\n经院哲学的衰落是从这个唯名论的兴盛开始的，唯名论后来走了一个很极端的路子，坚决强调理性和信仰是不可调和的，要通过理性证明上帝信仰是不可能的，共相概念不过是声音而已。 著名代表是威廉·奥卡姆：“如无必要，勿增实体。” 没必要在现象（那个具体事物）背后还非要找到它的实体，找他的普遍共相，用不着。\n在某种意义上唯名论是意识到了想要调和理性和信仰有可能给信仰带来危险。信仰和理性本来就是两个领域的东西。\n经院哲学是一种理性主义，导致之后文艺复兴时期人们对理性厌烦了，文艺复兴是个感性爆发的时代。\n文艺复兴与宗教改革 文艺复兴：14世纪到16世纪在欧洲兴起的一场有关艺术、文学、自然科学和建筑各方面的思想文化运动。由于其搜集整理古希腊文献的杰出工作，通常被称之为“文艺复兴”，而它的实质则是人文主义运动。\n人文主义：指与神学相区别的那些人文学科，包括文法、修辞学、历史学、诗艺、道德哲学等等。到了19世纪，人们开始使用“人文主义”一词来概括文艺复兴时期人文学者对古代文化的发掘、整理、研究工作，以及他们以人为中心的新世界观。\n人文主义突出人的地位，不是和神学对立，而是将人和自然对比，体现出人的价值和尊严。\n在长期禁欲主义思想的禁锢下，一旦松动的结果，人一下子走向了感情，导致了文学和艺术方面的爆发。\n文艺复兴的重要作用：使希腊哲学与近代哲学的关系接通了。\n宗教改革：基督教在16和17世纪进行的改革。最总分割出了新教和旧教。 由于当时基督教会腐败严重，马丁路德发起了宗教改革。\n天主教与新教的对立：天主教号称上帝与世人不发生关系，教会作为中介，由教会把守着通往天堂的大门。而马丁路德说每个人因信仰得救，因信称义，意味着我们不需要教会，是我们灵魂与上帝的直接关系。\n原教旨主义：指某些宗教群体提倡对基本的经文或文献做出文字解释，并且相信从这些阐释中获得的教义应该被运用于社会、经济和政治生活的所有方面。\n黑格尔说：“你所追求的东西，不在你之外，它在你的内心。”神的神圣的东西，真理的东西，不要在外界追求，要向你内心追求。 马丁路德所做的就是重新回归人类本体，重回主体性。\n","date":"2025-06-21T14:09:08+08:00","image":"https://oldlay.github.io/p/mid-age/The%20Creation%20of%20Adam_hu_cc9b1dc121bd1f34.jpg","permalink":"https://oldlay.github.io/p/mid-age/","title":"西方哲学史 中世纪哲学"},{"content":"城堡 “谁也不能责怪，谁也不能不那样做，这一切都是受城堡的影响。”\n我觉得最接近卡夫卡作品本质的评论来源于德国哲学家时本雅明：\n“卡夫卡有为自己创造寓言的稀有才能，但他的寓言不会被善于明喻者所消释。”\n《城堡》的内容简言概括之：\n主人公K应聘来城堡当土地测量员，他经过长途跋涉，穿过许多雪路后，终于在半夜抵达城堡管辖下的一个穷村落。在村落的招待所，筋疲力尽的K遇到了形形色色的人，它们都是挣扎在社会底层的平民。其中有招待所的老板、老板娘、女招待，还有一些闲杂人员。城堡虽近在咫尺，但他费尽周折，为此不惜勾引城堡官员克拉姆的情妇，却怎么也进不去。K奔波得筋疲力竭，至死也未能进入城堡。\n关于城堡主题的解释争论不休，大致有这么几种：\n城堡是权力的象征，国家机器的缩影。\n城堡是犹太人无家可归的写照。\n城堡是“圣恩”。（这个解释来源于卡夫卡的好友，马克思布罗德。）\n城堡是社会的形象，卡夫卡始终无法融入社会环境。\n主要描写的可以总结为桥头客栈和信差一家，而且两家能反映出在城堡影响下的对比。\n阿玛尼亚受城堡权力的支配，但是反抗它，招致来了痛苦。她不仅忍受痛苦，而且还有头脑，能看清自己的痛苦。她面对事实，正视事实，继续生活，忍受这种生活，那时如此，现在还是如此，阿玛尼亚很像尼采所说的忍受痛苦并从中超越的超人。而弗丽达视与城堡的关系为荣耀，就算不存在这层关系，也要硬创造出这层关系，并从中获得力量谋求利益。\n从不同的角度去理解城堡，都会看到不一样的指代，“城堡”可以是任何事物。但在我看来，无论怎么理解城堡，“城堡”都是施加于人们头上的一层重压，追求而不可得，最后陷入虚无。村子和城堡作为一个健康的人运转着，而k作为外来者，像病毒一样注入到这个健康的人里，造成了一点似有似无的扰动，“K”抗争着一切，扰乱着村子，追求着城堡，但最后被消灭。所以重点实际上已经不是城堡了，而是\u0026quot;K\u0026quot;的行为。这一点我们可以在卡夫卡手稿中被删除的一个部分可以窥见。\n“城堡本来就已比你们强大不知多少倍，尽管如此，还是可以怀疑它是否会胜利，可你们不去利用这一点，而是似乎把全部的努力都用在确证城堡会胜利上，因此你们在斗争中会突然毫无根据的害怕起来，结果就使你们更加软弱无能了。”\n城堡甚至不需要真的施加什么实际影响于人们，人们自己对城堡的狂乱的想入非非就能让他们自己受折磨。所以重点就落在了“斗争”的行为上，不应该自身在路上就预设了悲观的胆怯，而是诉诸于本真的力量去进行诉求。不妨积极一点，人们本可以光明正大通过正常渠道实现公平与正义的诉求，由于人们自身对官方的畏惧和胆怯，使他们永远也无法进入城堡。\n但是故事的底色就是悲观的，“K”在寻求融入这个社会的过程中自我异化，经历过抗争、拉拢、分化等等计谋，最终却无法避免被同化和被毁灭的趋势。\n我这里把城堡理解为一种至高的权力，一种大他者的观念，也是国家与法律机器的缩影。不妨将此上升为一个更广博的解释之中，也是布罗德在出版小说的后记中进行的解释：\n”城堡是一种被神学家们称之为“仁慈”的那种东西，是上天对人的（即村子的）命运的安排，是偶然事件、神秘的决定、天赋与损害的效力，是不该得到和不可得到的东西，它超越于一切人的生命之上。在《审判》和《城堡》里，神的（在犹太神秘哲学意义上的）这两种表现形式——法庭和仁慈——恐怕就是这样来表现的吧。“\n人是怎样茫然地倾听着外面那个对他关于善与恶的永恒的问题不予作答或是只作最含糊不清的回答的世界，而心灵深处却怎样不可磨灭地埋藏着对那条给我走的、我注定要走的唯一光明的道路的希望。（比较《在法的门前》）\n《城堡》与《在法的门前》基本上是统一的故事。这里的解释就很有神秘和命运的色彩了，但这里的“被决定的命运“与国家权力的解释我认为并没有太大的区别，在我看来无非是是否存在神秘性，实际上都是个人对于被支配被戏弄而进行反抗的无力与徒劳。\n我想单纯的就“K”的奋斗来说说：\n书中的人物对“K”所施加的帮助在她们各自的经验上完全不同，也带有她们自己目的的诠释。小说中每个角色的态度都十分真诚，他们以真诚的姿态劝诫、警告主角“K”，和主角说着推心置腹的话语，但话语本身在主角眼中却显得模棱两可——既没有正面回应，也没有直接否定。主角尝试去见证城堡的所有努力都在理清这些话语、行为的过程中被消耗殆尽。对于主角来说，他们嘴里的话只会加重“城堡”的模糊性，弗丽达若即若离的行为，在爱的解释和心机设计的解释下完全不一样了，我要是“K”我也觉得莫名其妙。\n“K”是卡夫卡的一次尝试，他尝试跳出既定经验的束缚，不像通常的人们一样活在自己的经验里。把自己的自由意志拔高，尝试去看清周围发生的一切，理清整个事件——现实的全景，他相信存在一种真实，这种真实就是所谓“城堡”。\n《城堡》的抑郁色彩很严重。徒劳感是抑郁情绪中最常见的一种感受，而在小说中，主角无时不刻不在和徒劳感战斗，他的徒劳感来自于对城堡存在的坚信——这没什么，大家都相信城堡存在——但重点在于，城堡的存在不可以（不需要）被言明。这就像人们对真理的诉求，所有人在追求真理，而真理在每个人手上都莫衷一是。而真理的存在不需要被言明，我却能看到如此多各色各样的真理，只会感到徒劳与虚无。这就是问题。“K”追求生活中的某物要真实明晰，而不愿意接受混沌是生活的本质。对普通人来说，这是不需要去思考的。而K作为一个敏感的另类，他目的就是追求到某个至高的观念，但在路途上被形形色色的力量下扯的粉碎。这种至高的追求给人希望，因为它的确存在，但却像芝诺的飞矢，永不可达。\nK的结果是被毁灭，那我们呢？\n参考： 如何理解卡夫卡的《城堡》\n关于《城堡》的读书笔记\n","date":"2025-06-20T00:00:00Z","image":"https://oldlay.github.io/p/castle/picture_hu_66d488ef6f1ed758.webp","permalink":"https://oldlay.github.io/p/castle/","title":"城堡 卡夫卡"},{"content":"地洞 如果一个人进不了城堡，那么他可以自己为自己去挖一个地洞，城堡是别人的，但他自己挖出来的地洞是自己的。\n保持恐惧，在恐惧中才有存在感。有恐惧才会获得对这个世界的一种警惕，通过警惕保持距离，在距离之中来确立你和世界的关系。\n选择地洞不能在一个远离尘嚣的地方，真正安全的地方是最热闹的地方。要在喧嚣中构建独特的自我世界。\n地洞必须很坚固，来抵御外部世界的侵蚀，但又不能太封闭，还要和世界保持一定的联系。别的动物能感知我，我也能获知别的动物，我在相互的博弈式的生活中保持警惕感。曲曲声是我内心深处的恐惧的回声，我需要这么个曲曲声来获知我的存在。\n不要让任何外人进洞，这是你的一个最私密的世界，是你的一个不兼容于外部世界的一个个人天地。为别人干活总是不开心的，而为自己劳动能获得快乐。\n挖洞这件事永远不要完工，要不停的往下做。用一生的时间把挖洞当做一个事业。真正能抵抗外部世界侵蚀的不是这个洞，而是你不停去挖洞的行为，通过为自己劳动去抵抗这个世界的虚无。\n解读的太好了，分析的很有结构： 卡夫卡《地洞》解读｜六条“地洞”生存法则【周可】_哔哩哔哩_bilibili\n","date":"2025-06-20T00:00:00Z","image":"https://oldlay.github.io/p/hole/picture_hu_b87cc38cd948b459.webp","permalink":"https://oldlay.github.io/p/hole/","title":"地洞 卡夫卡"},{"content":"2. 古希腊哲学 希腊文明诞生的历史背景 考古学上发现，希腊文明实际与其他古文明一样诞生于中央集权制度，但由于外族入侵，皇宫烧毁，文化衰落，此时期的历史成为神话传说流传。在之后希腊文明重新辉煌的过程中，由于古老的中央集权制度和文化等传统、风俗习惯和宗法制度全部消亡，（这些传统实际上是人们赖以生存的，人们必须依赖他应对自然挑战，人们甚至不能去怀疑他，必须依靠传统才能生存），希腊文明并未受其影响。希腊文明再度兴起时并未受其影响，采用了一种城邦式的制度。 希腊哲学诞生于小亚细亚沿岸的一个殖民国家，但繁荣于雅典。由于雅典实行了一种城邦民主制度，希腊哲学鼎盛于雅典并不是偶然。 伯里克利在伯罗奔尼撒战争时期的《阵亡将士国葬礼上的演说》说到，我们的民主制度给后世所有制度树立了一个典范。伯罗奔尼撒战争以雅典战败告终，从此希腊走向衰落，实际上繁荣的时期非常短暂，但就是在这短暂的时期，给后世留下了巨大的影响。毫无疑问，民主的制度是哲学诞生的土壤。 哲学诞生满足的三个条件： 4. 人们开始关注终极关怀的问题。 5. 人们有时间去思考这些问题。 6. 必须有思想的自由的条件。 由于民主制度下每个人作为公民来说是平等的，不会受阶级、财富影响，那么人与人之间的影响中，最重要是语言的力量。对于某个我要提出的政治提案，我必须使用语言来提供充分的说明和论证，反对者必须提出理由进行反驳。所以只有自由才容得下思想。\n哲学的诞生 古希腊哲学脱胎于古希腊神话。最早给人们提供世界观的是宗教和神话而不是哲学，远古人们没有根据，只能从幻想的角度给这个世界一种说明。但神话的方式最后的落足点是一个神秘的东西——命运。命运是无法言说的，对于无法解释的我们就会用命运去解释他，命运就是不合情理。 命运是古希腊悲剧的核心，在《俄狄浦斯王》中体现的淋漓尽致。俄狄浦斯知道自己的命运，想尽办法去规避命运，但在无意中已经杀死了真正的父亲。有道理吗，没有道理。不合情理，怎么解释？只能借助于命运来解释，命中注定如此。 但是当人们不满足于用命运这个既定的、带有决定色彩的东西去解释世界，试图给出一个更合理的说明的时候，开始让命运向必然性、向规律来转变。——哲学由此诞生。\n希腊哲学分期 前苏格拉底哲学（早期自然哲学，宇宙生成论） 雅典哲学（苏格拉底，柏拉图，亚里士多德） 晚期希腊哲学 早期自然哲学 世界是生灭变化的，世界能够存在，一定有某些东西是永恒不变的，否则无法解释生灭变化的世界为什么是个永恒的存在，于是，引出了一个最根本的原初的开端、西方哲学第一个哲学概念——本原。 本原的词义两个最重要的： 1. 开端 2. 主宰 亚里士多德：所谓就是本原（arche），万物从它那里来，毁灭之后又回到它那里去，万物生灭变化唯独它不变的东西。 本原就是一个产生宇宙的终极原因，不可能消失不见，只是存在，永远主宰。即是开端又是主宰。\n泰勒斯：水是万物的本原。 由于古时的人们没有过多的概念可以使用，他们只能使用比喻的方法，也就是说这里的“水”不是水，是一个比喻，以水的流动性可塑性来体现本原应有的特征：不失去自身，始终流转不已。\n赫拉克利特：这个万物自同的宇宙，既不是任何神，也不是任何人所创造的，它过去是、现在是、将来也是一团永恒的活生生的火，按照一定的分寸燃烧，按照一定分寸熄灭。 人不能两次踏入同一条河流。 他想强调的是变，自然一切都在变化之中，宇宙始终处在流变不已之中的，只有变化是不变的。 希腊人追求的是一种对自然的知识，知识不同于意见，必须带有普遍性和必然性。变化的知识的根据何在？——变化是有规律的。于是他最早提出了Logos这个概念。\nLogos是什么？在赫拉克利特那里，就是永恒活火在一个尺度上的生灭，这个尺度就是变化的规律。\n早期自然哲学的局限：\n缺乏自然科学的支持。 建立在经验观察的基础之上。 众说纷纭，莫衷一是。 “无穷后退是不可能的。” 本体论的转向 巴门尼德：我们要认识的对象是不动不变的。 当时的问题在于：一个关于自然的知识问题。究竟我们如何能够对自然形成具有普遍性和必然性的知识？ 显然，在赫拉克利特那里的永恒变化只能得到意见，而不能获得知识。 非存在既不能被诉说，也不能被思想，只有存在才能被诉说被思想。所以作为思想和作为存在是一回事。\n存在(being)是西方哲学的核心概念，必须从语言学上分析存在，存在这个概念的提出有西方语言的必然性。 西方印欧语系存在系词(is)结构，于是A是B就构成了其语言的基本结构。希腊人要寻找那个自然中的不变物，而且当时希腊人并没有将自然和语言分开，那么在语言中很自然就有不变物的对应——那个系词是不变的，人们自然就会想一切东西先是什么才是什么，先存在才能存在成那个存在物。自然这个“是”(is)有了名词的特征，一切对事物的描述都离不开它。 实际上这里的存在不是中文意义上的实际的存在物，而是存在物得以存在的那个前提，那个看不见摸不着的那个东西。 巴门尼德这里给之后形而上学的发展奠定了基础。 形而上学与本体论是同义语。本体论是研究存在的。 巴门尼德的贡献：\n确定了形而上学的研究对象。 确定了思辨哲学的一个基本公式：思维与存在的同一性。 在哲学中开始了推理论证。 比如说：桌子椅子都是木头做的，那么使桌子之为桌子的是什么？ 于是出现了两条路径（意见之路和真理之路）：\n从时间上，从构成事物的材料上问要追求关于自然的知识。 从构成事物的本质规定，从概念的角度，从这个事物定义的角度去追问事物的知识。 巴门尼德所代表的转向，相当于从感觉经验的对象转向了思想的对象。感性认识到理性认识。\n苏格拉底 早期自然哲学在如何获得知识上遇到了困境，人们对是否能够关于自然获得知识感到失望。智者采取了另一种方式，使知识成为不可能。 由于雅典的民主制度，语言的论辩愈发重要，智者从中兴起，也标志着雅典民主制度的衰败。智者教授修辞学、论辩术， 不再考虑是非真假对错曲折的问题，成为了诡辩者。既然关于自然的知识不可能，关于人世的知识也没有，认为一切都是意见，既然是意见，那么就看你的论辩是否能让他人哑口无言。——事物没有对错，只有论证方式。 普罗泰戈拉的两个命题：\n人是万物的尺度。 一切理论都有其对立的说法。 万物的尺度在于作为感觉经验的个人，每个人都有属于他的尺度，那么自然没有尺度。 苏格拉底的生平 苏格拉底的时期伯罗奔尼撒战争结束，雅典走向衰败。早期苏格拉底追随自然哲学，发现无法解决问题，总说纷纭，无法获得自然的知识，道路走错了。于是他认为：自然万物真正的主宰和原因并不是物质性的本原，而是它的内在目的，即善。这里的善是一种完满，在他看来，万物都有一个向善的实现自身的目标（人总是向人格的完善发展），那么宇宙也就有一个最高的目的。我们想认识自然是不可能的，但我们可以认识人自己。 苏格拉底之死很大程度上是因为苏格拉底的政治理想和当时的雅典城邦发生了冲突。他提出的是知识救国论，强调一定要对国家、对政治生活有知识，才能够参与政治生活，才能有效地、有意地去做这些工作。但雅典的民主制度下，人生下来就是公民，可以参加政治生活，于是，苏格拉底与整个城邦的观念发生了冲突。他认为救国的良方最终会落到知识上，必须重新树立知识的信心。\n苏格拉底的思想 每一个事物一定是由他的本质所决定，也就是任何事物的生成总是自身本性的实现，如果宇宙万物作为一个整体，那么宇宙万物也有一个向善、向最好状态、完满状态实现它自身的一个目标，但认识宇宙和自然是我们力所不能及的，我们只能认识人自己，认识作为人的本性的那个“善”，这个东西，他称为“德性”。 德性（arete）：事物的特性、品格、特长，使一事物成为该事物的本性。 在苏格拉底看来，鸟会飞，能飞就是鸟的德性。也就是说是一个东西特有的功能。认识人也就是认识人的特有的本性。 每个人都有德性，但是个潜在的东西，需要得到自觉，必须对他有知识，才能让他发挥作用。 于是他提出了一个命题：无知即罪恶，德性即知识。\n未经理性审慎的生活是不值得过的生活。 “苏格拉底认为人要以对自己德性的自觉作为一切行动的一个根本前提，一切行为要以一个善的意志为前提，人的行为才是善的。”\n那么如何获得关于德性的知识？ 首先得知道认识什么，也就是”是什么“的问题。苏格拉底倡导认识事物的类本质和类概念。也就奠定了通过理性认识把握事物的本质的基本思路。苏格拉底通过两个人不断的对话和追问的方法，被他称为”助产术“。也就是辩证法。在黑格尔那里两个人变成了事物的自身的矛盾运动推动着事物的发展。 苏格拉底认为，知识是不可教授的，是先天的。建立在经验基础之上的知识是不可能是知识的，既有普遍性和必然性的知识不可能建立在相对偶然的感觉经验基础之上，那么知识从何而来？苏格拉底认为人的知识是先天的，人们把它忘了，他要做的工作是是人头脑中的东西表现出来。后来柏拉图把这种方式称为”学习就是回忆“。\n关于知识问题的争论，这里始终才哲学史上存在着经验论和先验论的矛盾，任何知识需要有感觉经验的内容，感觉经验是相对的、偶然的，那么科学知识如何获得普遍性和必然性？于是很多哲学家会从先验论的方式去考虑。 实际上，科学的知识是相对的普遍性和必然性。 休谟问题，经验的归纳不可能下一个全程判断，它一定是只对一定的归纳的范围内有效。实验科学建立在归纳的经验基础之上，那么从我们把握事物本质的这个角度来讲，建立在感觉经验基础之上能否获得具有普遍性和必然性的科学知识？ 苏格拉底作为哲学家，他是一面镜子，启发人们去认识自己，不是说教者。 当下哲学非常严重的问题是被社会边缘化或者自我边缘化，哲学从业者研究方向越来越专，读者群越来越窄。哲学的影响力越来越狭窄。但在苏格拉底那个时代，哲学就是一种生活方式，在生活中起作用。\n柏拉图 生平 柏拉图28岁时，苏格拉底死亡，他非常痛苦和费解，为什么城邦会判处自己最好的公民死刑，一定是出问题了。于是他离开雅典，寻求如何拯救雅典，展开了十几年的游历生活，最后毫无疑问失败了。 哲学必须面对时代问题，要面对这个时代重大现实问题和理论问题，否则哲学只能是自娱自乐的东西。《理想国》与苏格拉底的思想一脉相承， 我们需要找到国家的本质，也就是找到一个理想国家模型，以他为典范，说国家应该是什么样的，来规范现实中的国家。 统治者应该体现理性、战士应该体现的是激情、生产者表现的是欲望，当这三个阶层都能体现出这三种德性，那么这个国家就是正义的国家。所以柏拉图提出了古希腊传统的四种美德，即智慧、勇敢、节制、正义。从这个角度出发，柏拉图提出了一种”哲学王“的理想。\n理论 不要把柏拉图理论作为一个系统的完整的系统，实际上柏拉图的理论在不断变化，后期柏拉图存在自己对自己的理论进行了批评。\n柏拉图早期和中期的理念论的思想 在国家篇里，柏拉图为了说明他的理念论，用了三个比喻：太阳的比喻、线段的比喻和洞穴的比喻。 太阳的比喻：柏拉图将世界划分为现象世界和实在世界。现象世界是可见事物的世界，实在世界是不可见的理念世界。现实世界中太阳是主宰，理念世界中善的理念是主宰。 线段的比喻：把一条线分成两部分，一部分相等于可感世界，一部分相等于理念世界；然后根据真实性与明确性再次划分。 洞穴的比喻：比较明确地讨论可感世界与理念世界的区别。 哲学家充当的角色是试图将人们从洞穴中引导出来，走向这个阳光普照的大千世界中去。就是说要从这个现实的我们信以为真的可感世界能够看得到的这些现象界转向看不见的理念世界。 问题：仍然与早期自然哲学一脉相承，试图给世界以合理的说明，追求对自然的知识，但陷入了困境。苏格拉底重新来确立知识的基础，把问题集中在讨论事物是什么的问题上。柏拉图与这个思路一脉相承。 区别两个世界：可感世界和理念世界。 柏拉图认为对于现象的感觉经验的可感世界，我们不可能从中获取知识。而理念世界可以思想但不能感觉，知识的对象不是这个感觉经验的世界，而是由他们的本质所构成的世界。 柏拉图最核心的概念——理念\nIdea——客观的”理念“ idea——主观的”观念“ 是一种看，肉眼的看是形象，而灵魂的看是理念。”理念“是从苏格拉底关于”是什么“的定义而来，它的基本规定之一就是”由一种特殊性质所表明的类“。所有的花都叫做花，花的概念就是花的理念，实际上就是相当于我们所说的那个抽象的和普遍的概念，那个共相。但并非单纯的抽象概念，而是超越于个别事物之外并且作为其存在之根据的实在。在他的理念中包含了理念和理念之间的区别，就像万物之间有区别一样，有多少不同的事物就有多少种不同的理念。可以把理念理解为事物和概念关系，但增加了本体论的作用。 柏拉图对事物和理念关系的两种解释：\n分有：具体事物之所以存在是因为它们分有了同名的理念。 摹仿：造物主是根据理念来创造具体事物的，所以事物因摹仿理念而存在。 人在解释世界时，无法摆脱人的视角。尽管是在认识世界本身，但仍是从人的角度出发。木工是根据理念来制造我们所使用的床和桌子，所以造物主按照理念的模型创造了这个世界。是把认识的关系做了一个颠倒，我们可能会说，我们是认识了很多花之后形成了对花的概念，但柏拉图和苏格拉底会说是因为先有了花的概念，具体的花和事物才能存在。所以，是一般和个别之间的关系问题。 柏拉图主张，一般和个别是完全分离的两个世界。理念世界是存在于可感世界之外的另一个世界，可感世界是由于分有或者摹仿了理念世界的模型而变成的。简单来说，就是现在所说的客观唯心主义，强调理念、事物的概念就是客观的存在，而且构成这个世界存在的根据。 理念的四种含义： 3. 理念是事物的共相 4. 理念是事物存在的根据 5. 理念是事物摹仿 的模型 6. 理念是事物追求的目的 美的事物要成为美的，那个美就成为它追求的目标。虽然事物都是相对的，但是它们总以追求那个最完满、最完美的自身作为他们的目标。 两个世界的划分相当于柏拉图的本体论，但也是和认识论相关的。 那么问题在于，如何认识理念？怎么知道有理念世界的存在？ 回忆说和灵魂转向说。我们不可能通过感觉经验去认识理念，要超越感觉经验才能把握那个理念。 回忆说：他说，人的灵魂本来高居于理念世界，和理念是融为一体的，通晓理念世界的一切，但下降到尘世后将一切都忘掉了。学习就是通过各种方式诱导，让人回忆起原本知道的东西。 经验论无法解决普遍性和必然性的问题，回忆说可以看作最早的先验论的模型。 先验论：认为人的知识是先于感觉经验、先于社会实践的东西，是先天就有的。 灵魂转向说：正如”洞穴比喻“所表明的，我们不可能通过洞壁上的影像认识身后的事物，除非转过身来。灵魂的转向就是需要从感觉经验的世界转向理念世界。 在这样一种灵魂转向说里面，柏拉图其实有点提出一种我们具有先天的认识能力，而不是先天的知识就在头脑中，肉眼看到的是感觉经验的世界，灵魂转向的是理念世界。 回忆说对应了知识是先天的，而灵魂转向说对应了认识能力是先天的。 总而言之，建立在经验观察基础上不足以给知识提供基础，柏拉图的理念论最重要的目的是给知识提供根据。\n对于理念论的反思 最早对理念论提出批评的不是别人，正是柏拉图自己。甚至可以说，后来人对柏拉图的批评都没有超过柏拉图的自我批评。 古人在讨论问题的时候，他更重要的是我以什么方式解决我面对的问题，而不太在意我这个体系如何，当我的体系，解决不了问题的时候，我毫不讳言我面临的问题，只要有必要，我会毫不犹豫抛弃我以往的体系，去找到那个能够解决问题的方式，也就是说哲学是要解决问题。但后来很多哲学家以维护自己体系为更重要的工作。 理念论的困境： 7. 理念的普遍性 8. 理念的分有的问题 9. “第三者” 10. “分离”的问题\n每类事物都有其对应的理念，这就是理念的普遍性，但理念论有很强的伦理色彩，理念世界善是主宰，那么问题在于肮脏的事物是否存在理念？这个问题在后来圣奥古斯丁的神正论中也遇到了，善的上帝创造的世界为什么还有恶？一个带有伦理色彩、价值论色彩的体系怎么处理这个恶的问题。\n神正论：基督教哲学名词，认为世界之所以存在是由于上帝的存在。维护神的正义。\n事物是分有理念的一部分还是整体的理念。如果一个杯子分有一整个属于这个杯子的理念，那么所有杯子的理念达不到统一，如果只是分有一部分，同样也无法统一。\n理念是事物之间的相似性，花的事物和花的理念之间有没有相似性，如果有，那么会存在一个“第三者”。\n如果理念世界与可感世界是分离的，我那么如何认识理念世界。而理念世界又怎么对可感世界发生作用。\n但就算存在这些问题，柏拉图还是必须坚持理念论的立场，如果后退一步，那么知识将无立足之地。\n所以后期柏拉图思想发生了变化，开始探讨理念和理念之间的关系。产生了通种论。之前理念与理念之间分离，但现实世界相互联系，那么理念世界也应该提供这样的根据。所以柏拉图修改了自己的观点，有些理念可以相互分有，有的不行。 《智者篇》里的六大概念:\n存在 非存在 相同 相异 静止 运动 这六个是最大的理念，被称为种（Genos）。 通种论：打通理念和理念之间的关系的学说。\n柏拉图的这个思想对后世影响很大，如果哲学按照柏拉图的这个思路可以能够完成他这个工作的，那么理想的模型应该是把构成世界本质的所有的概念，能够构成一个有机的体系，作为整个现实世界的逻辑结构。柏拉图指明了一条道路，要想通过思想理性认识来认识事物的本质。这条基本思路奠定了西方哲学后来的基本思路。\n哲学要追问的是现象界背后的本质。\n亚里士多德 亚里士多德流传下来的著作中，里面真正涉及哲学的不超过20%。大部分是关于自然哲学和其他知识的。真正涉及哲学的主要是那一部《形而上学》。 知识的科学分类：\n理论知识 实践知识 创制知识 他把人类的所有知识分成了这三大类，我们现在对知识不会这样划分，但哲学离不开他。比如康德的《纯粹理性批判》探讨的是理论知识，《实践理性批判》探讨的是实践知识，《判断力批判》有一部分谈论的是美学问题。 原因论 通常在物理学中讨论这个概念，在亚里士多德的时代更多是自然哲学的意义。\n亚里士多德时期的“原因”，意义接近于一个事物存在所需要或者说必备的、充分的条件。亚里士多德将构成事物存在的条件归结为四种，即“四因说”。\n四因说： 11. 质料因 12. 形式因 13. 动力因 14. 目的因\n质料：构成事物的材料，是构成事物持续存在的一个基本条件。 形式：相当于柏拉图那里的理念，构成事物之为事物的那个东西，就是构成事物的一个本质规定。 动力：对于生成世界的动力。 目的：一个事物存在之目的，追求的目标。，相当于柏拉图那里的善。\n目的因是引导事物运动的原因，事物追求自身完善，所以引起他的生成的运动，达到最佳状态的那个形式。所以可将形式因、动力因、目的因概括为形式，而将质料因归为质料。\n柏拉图强调现实世界之外存在一个本质世界，而亚里士多德与柏拉图最根本的分歧在此。 亚里士多德认为没有与这个事物分离的理念，真正实在存在的就是具体个别的事物，事物的形式和质料是结合在一个事物里边的。 现实的事物是不存在分离的，只有当我们去意识事物的形式，这个过程才存在分离。\n潜能、现实：潜能就是潜在的力量，有可能成为什么但还没有成为。现实也可以翻译为实现，就是一个实现的过程，相对于潜能来说是另一种存在方式，获得了形式的过程。 在亚里士多德看来，质料是潜能，形式是现实，质料有成为自己的能力，但它还不是，当他一旦成为某个形式，他也就成为了现实。 亚里士多德排了一个等级，最原始的质料是完全没有形式的水火土气，最高的存在就是最完满的现实性。中间的就是形式与质料的生成关系。 那个最完满的现实类似于宇宙万物那个最高的目的，那个最完满的现实是纯形式，它是引起万物运动，但他自身不动的东西。\n形而上学 亚里士多德阐发了“第一哲学”的科学。实际上这个概念的诞生是罗马图书馆的管理员在整理完物理学后，不知道给这卷取什么名字，就取了物理学之后诸卷，后人觉得麻烦，于是直接省略短语加上词根meta-造了个词。但meta这个词根有元，超越的意思。于是这个概念的名字成为物理学基础的意义了。 对应到中文翻译，最初翻译的意义是考究形而上之对象（即实在）对于考究形而下之对象（即现象）。 黑格尔认为：近代形而上学是片面、静止、孤立地看问题的，以区别于辩证法。\n由于形而上学这个词不太能反映出它的内容，于是之后造了本体论这个词。（to on + logos = ontology） 形而上学的概念实际上于本体论是同义语。 本体论：研究存在的理论。 形而上学于他而言是：“研究存在者之为存在者的一门科学。”就是对存在(being)及其“诸原则”和“诸原因”的研究。\n亚里士多德的形而上学：\n存在论 实体论 神学 所有的学科只研究存在的某些方面和属性，至于这些存在的属性方面的前提，存在本身它们是不研究的，所以就应该有一门学问，专门研究存在。专门把存在作为其本身作为研究对象。\n存在是不可定义的，我们没有办法说存在是什么，但我们可以说存在是怎么存在的，即存在的意义是什么？\n存在的两类意义：\n偶然的意义 本然的意义 亚里士多德要探讨的是事物本然的意义，也就是必然为其所属的，这样的意义，亚里士多德就称之为范畴。 范畴这个概念来源于语言逻辑，只要我们思考到某个特殊的对象，我们就会想到一个主词和它的谓词，也就是说想到某个实体和它的偶性。那些不可分的主词就是实体，谓词就是范畴。 范畴：在希腊语中，意思即“关于神的诉说”。也可以理解为是对一个事物的规定。也就是对事物最大、最普遍、最一般的说明。 亚里士多德认为，范畴有多少种，存在就有多少种。这里希腊人并没有将自己于自然分开，不要以现代人的角度去看待。所以不要把范畴看为主观的概念，其实将的是事物的存在方式。 亚里士多德概括了十个范畴：\n实体 数量 性质 关系 地点 时间 状态 动作 所有 承受 这十个范畴对一切东西都有效，在亚里士多德心目中，实际上是说对万事万物一个最普遍、最一般的说明。也构成了世界的一个逻辑说明。 范畴体系 = 世界的逻辑结构 实体(ousia) = essence(本质、实质) 回答存在是什么也就是回答实体是什么的问题。亚里士多德时代的“ousia”这个词，是指构成一个事物是什么的那个本质。\n西方哲学史实际上是概念演变的历史。\n事物被称之为ousia有两种方式：ousia是终极的主体（主词），它不再述说其他事物；以及ousia是某个“这个”（tode ti），它也是独立的。 什么是实体？ 最早亚里士多德主张个别的具体事物是第一实体。但这个想法后来发生变化了，后来又把一个具体的事物区别为形式和质料，亚里士多德主张形式是第一实体。 要回答是什么的问题，只有形式可以解决。\n另外，亚里士多德还主张神是最高实体。引出了亚里士多德的神学。亚里士多德所说的神是哲学意义上的神，最高的神圣的存在；而不是指宗教的信仰的那个东西。 在《物理学》中亚里士多德根据“无穷后退不可能”原理论证了“第一推动者”即“不动的推动者”。 在《形而上学》中亚里士多德论证存在着永恒的实体。\n如果实体是可以生灭的，那么一切事物都是可以生灭的； 时间和运动是不会生灭的； 生灭变化以时间和运动为前提，那么时间和运动以谁为前提？只有假定有永恒存在的实体，才能讲时间和运动是永恒的。 因此一定存在着一个不会生灭的实体。 最高的质料的纯形式的那个东西，隐德莱希，其实就是那个自身不动，引起万物运动的东西，那个善。 哲学和宗教都起源于人类的终极关怀。 最高的那个存在就是就其自身而存在的一个纯思想的东西，纯粹的理性。我们人最高的使命就是去认识思想这个理性，当我去思想这个神圣的思想的时候，我就与它融为一体，分享它的生灭。 亚里士多德认为，人生所能达到的最高境界是思想到神圣的存在。\n\u0026ldquo;思辨是最高的幸福。”\n伦理学 伦理学属于实践知识范围，探讨不是为了获知德性是什么，而是为了成为善良的人。 什么是最好的生活方式？ 希腊人认为的幸福是一个人在各个方面获得成功，这个幸福需要运气。而亚里士多德认为：幸福就是合乎德性地实现活动。幸福就是自身就是目的的那个目的，就是自足，达到自我完善。\n当情况不明显的时候，我们怎样确定什么是应该做的？ 中道，亚里士多德认为，我们面对的变化不一的事物往往有一个过度和不及，我们要取其中，因为实践这个东西一定要在生活之中去选择筹划。比如说恐惧和自信之间叫做勇敢。 实践智慧：实际上是一种选择能力。认识这个世界是没有选择的，是确定的。但一个人的实践活动是要在通过选择来去实现的，实践智慧就是利用理性和各种各样的能力，选择对你最好最有利的可能性。涉及到实践和伦理的活动，一定是以善良意志为前提的。\n晚期希腊哲学 晚期希腊哲学四大主要流派：\n伊壁鸠鲁主义 斯多亚学派 怀疑主义 新柏拉图主义 晚期，社会动荡不安，个人命运无法掌握的情况下，那么人们对哲学的要求，更多的会倾向在人生和伦理学的问题。\n哲学需要回答的问题：对神和死亡的恐惧。\n伊壁鸠鲁主义 利用德谟克里特的原子论，提出了快乐主义的伦理学。 这个世界是原子和虚空构成的，原子聚合是一个事物的构成，原子2分散就是一个事物的死亡，那么这个过程是自然而然的，我们也就没有必要对死亡和神去恐惧了，神不在我们这个世界上，神明与我们无关。“当我们活着的时候，死亡还没有来临；当死亡来临的时候，我们已经不在了。”我们根本感受不到死亡，我们只需要按照自然方式去生存，追求快乐，人生的目的就是达到幸福，达到快乐。“肉体上的快乐，只是粗糙的原子运动，是暂时的，有时会带来痛苦。只有精神上那些精致的灵魂原子运动，才能带来宁静、愉快和持久的快乐。”\n斯多亚学派 斯多亚学派的芝诺更强调灵魂和肉体的区别。对后期的基督教的影响非常大。斯多亚学派认为灵魂是神圣之火的火花，自然就是智慧就是理性，按照自然去生活就是按照理性去生活，灵魂和肉体结合就被污染了。 斯多亚学派认为人生的目的是要拜托肉体的限制，让灵魂得到净化，更强调精神方面的东西，所以里面也有禁欲主义的观念在里面。\n怀疑主义 社会动荡不安，我唯一能做的是让我自己灵魂得到安宁。怀疑主义认为通过认识自然来去按照自然去生活就会陷入到烦扰之中，永远不得安宁，因为我们的知识就是始终无法获得的，知识都是建立在感觉经验基础之上的，感觉经验是不可靠的，那么知识也就不可靠，所以才会有各种纷争。怀疑主义认为要想得到安宁，唯一的办法就是对一切不下判断，不置可否，达到不动心的境界。\n新柏拉图主义 主要代表是普罗提诺，利用柏拉图的理论去加工改造构成的一种体系。 两个最重要的改造：\n普罗提诺在柏拉图的理念世界之上，加了一个更高的存在，即“一”。——太一。由于他是最完满的存在，它就充溢而流溢， 就像太阳发射光芒一样，完满而流溢出来就创造了理念的世界，一层一层的产生，是有等级的。 他用“流溢说”解释事物和理念之间的关系。流溢的向下的路，就到了具体的事物。对于人的灵魂需要回归，有一条向上的路，当人的灵魂关照理念世界和最高的那个一融为一体，才能达到绽出（灵魂出窍）。\n流溢说：普罗提诺用以解释万物从某个先验本原产生的学说。\n新柏拉图主义对基督教早期的教父哲学影响很大，非常适合构建基督教的那个等级体系。\n希腊哲学是从神话脱胎而出，发展到普罗提诺，又回归到了神秘性。\n","date":"2025-06-20T00:00:00Z","image":"https://oldlay.github.io/p/ancientgreek/picture_hu_3c222e015b60a5eb.jpg","permalink":"https://oldlay.github.io/p/ancientgreek/","title":"西方哲学史 古希腊哲学"},{"content":"主要基于张志伟西方哲学史。\n摘自评论：\n老年康德写书时，写着写着就把记账的内容写了上去。我们的生命简直就像露水一样的短暂，穷极一生我们可能都无法窥探到真理的哪怕冰山一角，但是人们却仍然不知疲倦去追寻着，这个伟大的宇宙可能根本不存在着的终点。人类不能抛弃对形而上学的追求，在自然轮回生灭面前我们都是渺小的，但当我们开始追逐真理的时候，我们便不朽了。\n1. 绪论 哲学不是科学，但哲学和科学一样讲理性，哲学和宗教一样，起源于终极关怀的问题。\n怎么学习哲学 哲学等于哲学史等于问题史：我们不要太关注于哲学家的理论的内容和知识，大部分都过时了，我们要关注他们面对的问题以及解决问题的方式。\n我们只能通过哲学家的经历体会他的思想\n如何了解哲学家的思想：\n了解哲学家的问题 熟悉哲学家的术语 沿着哲学家的思路 理解哲学家的思想 希腊人哲学思维的特点：\n偏爱非个人性的，更关注带有普遍性的东西 试图给事物的存在找出合适的原因 希腊哲学的特点：学以致知\n","date":"2025-06-20T00:00:00Z","image":"https://oldlay.github.io/p/introduction/picture_hu_3223b40fbed778f8.jpg","permalink":"https://oldlay.github.io/p/introduction/","title":"西方哲学史 绪论"},{"content":"这本书篇幅非常长，而且其中存在很多哲学观点的讨论，语句也有些超长议论性难句，但好在我之前看过一点哲学史，读起来较轻松了点，最后还是坚持读完了。\n书名叫\u0026quot;魔山\u0026quot;，还是德国人写的，在我看来应当是冷峻、庄重和肃穆的气氛，但读完却发现，充满了温情与人道主义。\n时间，疾病，死亡，理性与激情\n同时从时间和空间出发的两个维度，构建起了魔山这个极富象征性的社会病态图景。\n这本书厉害的地方在于，面对世界的病态幻象，不是选择逃避归隐，而是选择直面，构建出自己的生命观念。\n空间 书的主题是疾病，疾病借助于空间法则的实施，完成了对个体的一次有效的控制，个体又通过时间完成了对这种控制的有利反噬。也就是说主人公汉斯卡斯托普在空间上被疾病监禁，在时间上找到了自由。这里的“疾病”不一定真的是指身体上的疾病，也可以理解为一种异己力量，“文化病态”。作家把这个世界比喻做一个巨大的病院。疾病的出现会使人产生严重的挫败感和依赖性，进而形成对医学科学的非理性的崇拜和对体制规则的一种盲目顺从。科学与规则的理性与盲目崇拜的非理性，人在这种疾病幻象和非理性之中会自觉和不自觉的用疾病来建立自己的身份认同，进而确立对这个世界的基本认知。\n这本书中涉及到了几个学科内容，比较有意思的是：\n疾病社会学 疾病重构了社会空间，一方面表现了物理的隔离，一方面山上世界和山下世界的分隔。另一方面是原来平面的社会关系在疾病的作用下变成了医生和病人之间的一个垂直关系，构成了一个垂直状态的社会空间。 疾病伦理学 如果一个人一旦成为病人，会有一种对社会道德上的负罪感，背负了沉重的精神负担。 疾病心理学 揭示了个体和体制关系中的微妙的心理共振，一个人到底有没有病归根到底还是个心理问题，汉斯原本是健康的，或者说疾病的症状没有显现，并且他自己也认为与其他病人不同，只住下21天。但在山上的疾病幻象中成功的被催眠了，疾病焦虑出现在他身上，配合着做各式各样的检查，后来身份认同出现变化，汉斯真的认可他是个病人。并且在这种认同之下，汉斯被驯化了，医院都是为我好，就会认为它做什么都是合理的， 治疗不仅仅是一种医学上的救治，其实同时还是一种极为有效的社会规训形式。 这篇小说的价值在于不仅仅写出了我们这个世界日益严重的病院幻象，还在于透过汉斯的奇特经历，写出了一个个体走出这种具有集体性和体制化特征的病院幻象的一种可能。\n汉斯对舒舍夫人有着狂热的迷恋，这种狂热的迷恋是一种病态的表达，作品中强调了一个观点：爱情其实和病是同理的，疾病和情欲是异质同构的一个事物，汉斯之所以能够最终摆脱这个病院幻象，其实是不是因为他相爱，而是因为他不爱，最终摆脱了爱的诱惑。爱为什么是疾病？在我理解看来，爱情对于个体来说是一份异己的力量，我会因为爱情丧失理性而产生变化，无论是生理上还是心理上，与疾病相同。\n纳夫塔和赛特姆布里尼分别代表了理性和非理性两个不同的思想立场，汉斯在这两个思想力量中不断摇摆，通过理性和非理性在两人辩论中的拉锯，不断地显示出对绝对真理的一种消解力量。我一直觉得这些作家受尼采影响非常大，赛特姆布里尼是个理性主义者和人文主义者，他身上代表的理性风格有点像“日神精神”中的阿波罗精神。纳夫塔有点像“酒神精神”（从生命的绝对无意义性中获得悲剧性陶醉）。但在他两的不断辩论中，可以发现，有时候纳夫塔的观点会变成赛特姆布里尼所应该支持的，而赛特姆布里尼对因为这一点反驳出纳夫塔应该支持的观点，就是说纳夫塔的观点会变的带有一定的理性主义，赛特姆布里尼的观点会变的有一定的非理性。所以其实他们的观点是你中有我，我中有你，很难说谁对谁错，结果就是消解了绝对真理的权威性。汉斯的思想就找到了一条出路，既不是一个理性派也不是一个非理性派，汉斯是一个行动派，他从两人的辩论中获得了行动的力量，思想最终对行动做出了让步。所以，汉斯在山上所经历的是精神觉醒，正因为他被动的成为了病人，他才惊讶的发现，原本他原来所向往的所认同的所追求的那种所谓健康的、优雅的、和顺从的生活，那才是一种病。一个半真半假的病让汉斯知道了另一个真正的病，这可能才是托马斯曼告诉我们的最终摆脱“病院幻象”的唯一出路。\n雪的章节让我印象深刻，汉斯不顾疗养院等束缚他的规则，拿上雪橇，在岑寂虚无的白雪世界中漫无目的的游行，甘冒回去太晚的风险，奋力深入那旷野的沉默，深入那阴郁恐怖、岌岌可危的境界。他以不辨方向，抛开一切，甚至是回去的可能，抛弃了日常主宰他的理性、秩序和规则，将自己完全投入自然和激情。\n时间 还在于托马斯曼揭示了疾病和时间关系的隐秘逻辑，以及在这个关系逻辑当中，他找到了每一个个体，去追求自由的可能性。魔山上的空间自由，而时间严格。疾病让病人摆脱日常状态，进入一种更具规范性和统一性的时间系统，是一种在封闭状态下的，具有很明显强制性的一个公共时间。汉斯并没有完全被病院时间所同化，他之所以能够成功的出走，靠的是他有意无意之中积攒的和病院公共时间相抗衡的私人时间，正是靠着这种个体的时间经验的建立，他得以获得自由。\n托马斯曼用时间来构造故事框架，故事中的时间基本单位是七。七天不仅仅是个自然时间，其实还是一个文化时间，就拥有文化的建构性，用七这个数字可以建构出一个全新的时间秩序，病院的时间是机械化的时间和含混性的时间的一个诡异的结合。病院在严格时间规范下却无法承诺时间，在每天机械性的日程规定下，却无法获知出院时间，确定性和不确定性下的诡异结合了，这是体制时间最不人道的地方，也是所有体制维持其有效统治的关键之所在。汉斯用了三周的时间完成了身份的转变，从一个健康的人变成了一个病人，然后又用七个月的时间去爱舒舍夫人，最后用了七年的时间治疗，之后下山。七这个数字在这个作品中既预示了完整性，同时又包含了新生和转型，时间到了，一段新的生活就必须重新开始，无视含混的存在。\n魔山的神奇之处还在于它的动态时间态势的呈现，小说每一章的篇幅都要比前一章篇幅要长，开始时是按日作为时间单位来写，后面是按一周一周来写，在第五章又是按一个月一个月来写，最后按年为单位，时间的运行方式越走越长，因此时间就成为了叙事单位。所以，在艺术上形成了一种时间的节奏感，不同位制的钟摆产生出的摆动，如同交响乐团所发出的和谐共鸣。这种时间和医院的整齐划一的体制时间形成了鲜明对比，并且是截然对立的。时间一旦体制化，就会变得空洞化，没有生命感，身处其中的病人麻木不仁，汉斯在遵循铁板一块的时间规范当中，又很神奇的找到了一些裂缝，随着个体的时间系统的逐渐膨胀和丰富，病院体制时间表现在汉斯身上就趋于彻底的崩溃，固有的时间崩溃，新的生命就开始，旧的秩序自然的瓦解。魔山的动态时间节奏，是汉斯从病院体制时间的各种大一统的、刻板的规范和体制当中逃逸出来，形成了一种自我成长的生命轨迹。\n七年的变化本质上是时间经验的转变，约阿希姆和佩佩尔科恩的死给汉斯带来了很大的冲击，正是这种死进入到汉斯的灵魂深处，转化为身体的体感，死亡使得汉斯自己营造出来的个人时间具有了一种生命的质感。疾病最可怕的一点是剥夺了一个人的时间，疾病把人拖进了一个似乎是有利于治疗的刚性的时间状态中，把人变成了听天由命的被动客体，托马斯曼的使命是要把原本属于我们每个人的时间从体制时间的监狱中抢夺回来。汉斯在作品中出现是以时间主体的角色出现，汉斯也因此主导了全书的时间节奏，慢慢成为了时间的主人。开始的时间描写都是具体的，之后对于时间变成了形而上的思考，时间的存在与观念被汉斯内化，汉斯成为了时间本身，病院的时间是与自然界的时间脱节的，而汉斯的时间从自然界变换莫测的气象中去体验和把握那样一种时间的无差别的晕眩感。汉斯越过了病院，从大自然中获得感悟，达沃斯山区混乱的气象，让汉斯享受到一种时间失控的状态，以及这种状态下晕眩体验。\n植物给汉斯带来了宝贵的时间经验，观察植物也将时间微观化了，使得我们平时空洞的注意力在最小的时间单位面前得以集中，进入到植物中和时间里，托马斯曼说时间如果拉长了，对我们人没有任何意义，时间必须要缩小，通过时间的缩小不断把事物加以放大，这样我们的时间经验变得很丰富扎实。其次就是循环性，循环是我们赋予时间的一种运动形式，不是重复，循环有变化，而重复没有变化，植物的循环性有助于我们人去建立一套个体时间的运转系统，强化了汉斯对生命的理解。像植物一样活着，该繁茂的时候便繁茂，该凋谢的时候便凋谢，一切都顺其自然。\n","date":"2025-06-19T00:00:00Z","image":"https://oldlay.github.io/p/magic-mountain/picture_hu_e1207ecdbc1dff77.jpg","permalink":"https://oldlay.github.io/p/magic-mountain/","title":"魔山 托马斯·曼"},{"content":"乡村医生 卡夫卡的短篇小说都是始于窘迫，终于虚无。\n这里的虚无就是一种陷入失败主义的无助与徒劳。\n这部小说是寓言和超寓言的统一。\n这样的一个寓言故事的模式是一个事情不断的出错又不断的纠正，最后趋于解体的一个模式。人生的失败不是具体指某一次的失败，而是无数次的失败加希望再失败再加希望的永无止境的总和。\n寓言故事关注于理性，一个共识，但超寓言关乎的是非理性，关乎个体的欲望的满足，是私人化的。隐秘的精神关联的私人读者。在这部超寓言中，卡夫卡完成了一次个人欲望的不动声色的表达和释放。\n医生代表了超我，是社会责任，作品中的本我是马夫，躲藏起来了。马就是自我的形象，在柏拉图的《斐德罗篇》中将人的灵魂比作一匹马车，车夫，代表着理性，马，代表着欲望，理性主宰着欲望。超我时常主宰着本我，小说开头的窘迫使超我松动，本我的马夫以冒犯的姿态出现，冒犯着女仆。之后本我的马夫将超我的医生和本我的马驱赶出去，超我裹挟着本我上路了 。但在医生就诊的过程中，自我的马不断的提醒医生要赶快回去，自我与超我在这个过程中不断的冲突。之后病人死去，医生陷入虚无，不需要再回家了，因为本我欲望已经得到了替代性的满足。马夫就是本我摆脱了超我和自我的欲望化身，是人的欲望的软着陆，也就是马夫是“我”这个在社会身份医生下想实现但实现不了的欲望，马夫实现了替代性的满足。\n所以最后的结局我理解为超我被本我战胜后所陷入的虚无，理性与欲望不断的纠缠缠斗，最后欲望占了上风，欲望的洪水得以宣泄，却留下了一地虚无， 感觉就是贤者时间。驾着尘世的车，非尘世的马，到处去流浪。超我、本我和自我的和解后，进入了一个流浪的境界，流浪的真相是在欲望实现后的虚无和责任放弃后的自由这两者间了无牵挂，永无止境的漂泊。\n","date":"2025-06-19T00:00:00Z","image":"https://oldlay.github.io/p/doctor/picture_hu_9a8dd343acbdaf2c.png","permalink":"https://oldlay.github.io/p/doctor/","title":"乡村医生 卡夫卡"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://oldlay.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://oldlay.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://oldlay.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://oldlay.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://oldlay.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://oldlay.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://oldlay.github.io/p/emoji-support/","title":"Emoji Support"}]